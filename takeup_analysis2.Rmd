---
title: "TakeUp Analysis Notebook"
output:
  html_notebook:
    code_folding: show
    fig_caption: yes
    fig_width: 8
    number_sections: yes
    toc: yes
header-includes:
   - \usepackage{bbm}
date: "`r format(Sys.time(), '%B %d, %Y')`"
---

```{r setup, include=FALSE}
library(plyr)
library(dplyr)
library(multidplyr)
library(tibble)
library(tidyr)
library(lubridate)
library(purrr)
library(readr)
library(haven)
library(lmtest)
library(car)
library(broom)
library(ggplot2)
library(viridis)
library(ggrepel)
library(ggmap)
library(stringr)
library(knitr)

source("../util.R")
source("takeup_rct_assign_clusters.R")

knitr::opts_chunk$set(cache = TRUE, echo = FALSE, fig.width = 8, fig.height = 5, fig.align = "center", cache.path = "takeup_analysis2-cache/", fig.path = "takeup_analysis2-fig/")

config <- yaml::yaml.load_file("../local_config.yaml")

doParallel::registerDoParallel(cores = config$cores)

wgs.84 <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
kenya.proj4 <- "+proj=utm +zone=36 +south +ellps=clrk80 +units=m +no_defs"

options(dplyr.show_progress = FALSE)
```

# Data

```{r load-data, include=FALSE}
# This data was prepared in takeup_field_notebook.Rmd
census.data <- read_rds("data/takeup_census.rds")
baseline.data <- read_rds("data/takeup_baseline_data.rds") 
takeup.data <- read_rds("data/takeup.rds")
all.endline.data <- read_rds("data/all_endline.rds")
reconsent.data <- read_rds("data/reconsent.rds")
sms.content.data <- read_rds("data/takeup_sms_treatment.rds")
cluster.strat.data <- read_rds("data/takeup_processed_cluster_strat.rds")  
```

These are the _monitored_: baseline and endline survey respondents, as well as a sample of people from whom we will receive reconsent without surveying.

```{r}
census.data %>% 
  filter(!is.na(wave), # Actually in the study (not in one of the dropped clusters)
         monitored) %>% {
    count(., endline.type) %>% kable %>% print
    
    filter(., is.na(endline.type)) %>% count(baseline.sample.wave)
  } %>% 
  kable
```

Below is the name matching code. We are using this function to identify individuals in a census who received treatment in their cluster's point-of-treatment and were not recorded by enumerators during their take-up monitoring. This is necessary to estimate take-up for non-phone owners, who were not included in the monitoring list provided to enumerators, in four of the six experiment strata (wave 1).

We consider two individuals (in the take-up and census data) to be matched if the sum of edit (Levenshtein) distances of the first and last names is less than or equal to 1.

```{r name-matching-code, echo=TRUE}
# Name matching function. Given the census data and take-up from a particular attempt to 
# find individuals whose names were recorded at the PoT.
name.match.monitored <- function(census.cluster.data, 
                                takeup.cluster.data, 
                                max.cost = 1) { # This is the maximum number of "edits" or difference allowed between names
  dist.mat <- adist(census.cluster.data$name1st, takeup.cluster.data$name1st, ignore.case = TRUE) %>%
    add(adist(census.cluster.data$last_name, takeup.cluster.data$last_name, ignore.case = TRUE)) 
  
  census.cluster.data %>% 
    mutate(min.name.match.dist = aaply(dist.mat, 1, . %>% min(na.rm = TRUE)) %>% na_if(Inf),
           which.min.name.match.dist = ifelse(!is.na(min.name.match.dist), 
                                              aaply(dist.mat, 1, . %>% which.min %>% magrittr::extract(takeup.cluster.data$KEY.survey.individ, .)),
                                              NA),
           dewormed.matched = !is.na(which.min.name.match.dist) & min.name.match.dist <= max.cost)
}
```

Below we are linking the consent, census (including take-up status), and endline data to generate the analysis data set. At this stage, we are including everyone in the cenus--the entire cluster populations. For our analysis, we will filter on consent.

```{r data-preparation, echo=TRUE, warning=FALSE}
consent.dewormed.reports <- list(endline.survey = all.endline.data, 
                                 reconsent = reconsent.data) %>% 
  ldply(.id = "data.source", . %>% select(KEY.individ, monitor.consent, dewormed.reported)) %>% # Get reported deworming status and consent info
  filter(!is.na(monitor.consent), !is.na(dewormed.reported)) %>%  
  group_by(KEY.individ) %>%  
  summarize(monitor.consent = any(monitor.consent), # Consider as reconsented if at least one acceptance
            dewormed.reported = ifelse(n_distinct(dewormed.reported) == 1, first(dewormed.reported), NA)) %>% # Multiple contradictory responses
  ungroup

analysis.data <- census.data %>% 
         filter(!is.na(wave)) %>%  # Remove clusters no longer in study
  left_join(consent.dewormed.reports, "KEY.individ") %>% 
  mutate(dewormed = KEY.individ %in% takeup.data$KEY.individ, # TRUE if individual found in take-up data
         dewormed = ifelse(monitored, dewormed, NA)) # NA if not in the monitored group

endline.data <- all.endline.data %>% 
  filter(present, interview, consent) %>% 
  arrange(KEY.individ, SubmissionDate) %>% 
  group_by(KEY.individ) %>% # If more than one entry for an individual, take first one (there are 22 such individuals)
  filter(row_number() == 1) %>% 
  ungroup

analysis.data %<>% 
  filter(is.na(dewormed) | !dewormed) %>% # For anyone in study with with unknown or negative deworming status
  group_by(cluster.id) %>% 
  do(name.match.monitored(., filter(takeup.data, cluster.id %in% unique(.$cluster.id)))) %>% 
  ungroup %>% 
  select(KEY.individ, dewormed.matched, ends_with("min.name.match.dist")) %>% 
  right_join(analysis.data, "KEY.individ") %>% 
  mutate(monitored = !is.na(wave) & monitored, # Remove those dropped from the study 
         dewormed.any = dewormed | dewormed.matched) %>% 
  left_join(select(endline.data, KEY.individ, school, floor, ethnicity), "KEY.individ") %>% 
  left_join(select(cluster.strat.data, wave, county, cluster.id, dist.pot.group), c("wave", "county", "cluster.id")) 
```

Below we want to identify outlier clusters. 

```{r outliers}
is.outlier <- . %>% { . < quantile(., 0.25) - 1.5 * IQR(.) | . > quantile(., 0.75) + 1.5 * IQR(.) }

cluster.takeup.data <- analysis.data %>% 
  filter(monitored, monitor.consent) %>% #, sms.treatment == "sms.control") %>%
  select(county, dist.pot.group, cluster.id, assigned.treatment, sms.treatment, dewormed.any) %>% 
  unite(stratum, county, dist.pot.group, sep = " ") %>% 
  group_by(assigned.treatment, sms.treatment, stratum, cluster.id) %>% 
  summarize(takeup.prop = mean(dewormed.any)) %>% 
  group_by(assigned.treatment, sms.treatment, stratum) %>% 
  mutate(outlier = is.outlier(takeup.prop)) %>% 
  ungroup
```

```{r, echo=FALSE, fig.width=12, fig.height=10}
cluster.takeup.data %>% 
  ggplot(aes(stratum, takeup.prop)) +
  geom_boxplot() + #aes(color = assigned.treatment)) + 
  geom_text_repel(aes(label = cluster.id), data = . %>% filter(outlier)) +
  xlab("Strata") +
  scale_y_continuous("Cluster Proportion Proportion", breaks = seq(0, 0.8, 0.05)) +
  # scale_color_discrete("Treatment") +
  facet_grid(sms.treatment ~ assigned.treatment) +
  theme(legend.position = "bottom", axis.text.x = element_blank(), axis.text.y = element_blank())
```

The outlier clusters are:
```{r, echo=FALSE}
outlier.clusters <- cluster.takeup.data %>% filter(outlier) #c(249, 141, 343)

outlier.clusters %>% 
  select(cluster.id, sms.treatment) %>% 
  kable
```


# Analysis

```{r, echo=FALSE}
bstrp.uniquify <- function(.data) {
  .data %>% 
    group_by(KEY.individ) %>% 
    mutate(KEY.individ.unique = paste(KEY.individ, seq(1, n()), sep = "-")) %>% 
    ungroup %>% 
    mutate(KEY.individ = KEY.individ.unique)
}
```

```{r neyman-code, echo=FALSE}
nest_exclude <- function(data, key_col, exclude_nest_cols = character()) {
  dplyr::select_vars(colnames(data), everything()) %>% 
    unname %>% 
    dplyr::setdiff(exclude_nest_cols) %>% 
    nest_(data, key_col = key_col, nest_cols = .)
}

calc.strata.stats <- function(.data, 
                              .treatment = c("assigned.treatment"), 
                              .strat.by = c("county", "dist.pot.group"), # This is what we stratified the experiment by
                              .interact.with = NULL) {
  calc.stratum.ate <- function(.stratum.data) {
    make.cross.assign.tibble <- function(.col) {
      matrix(.col, 
             nrow = length(.col), 
             ncol = length(.col), 
             dimnames = list(.stratum.data$treatment.group)) %>% 
        t %>% as_tibble %>% 
        mutate(lhs.treatment.group = .stratum.data$treatment.group) %>% 
        gather(rhs.treatment.group, val, -lhs.treatment.group) 
    }
   
    .stratum.data %>% {
      generated.cross.tbl <- select(., 
                                    stratum.assign.mean.dewormed, 
                                    stratum.assign.size, 
                                    stratum.assign.sample.var.dewormed) %>% 
        map2(paste0("stratum.", c("ate", "size", "sample.var")), 
             ~ make.cross.assign.tibble(.x) %>% 
               set_names(str_replace(names(.), fixed("val"), fixed(.y)))) %>% 
        reduce(function(.left, .right) left_join(.left, .right, c("lhs.treatment.group", "rhs.treatment.group")))
        
      left_join(., generated.cross.tbl, c("treatment.group" = "lhs.treatment.group")) 
    } %>% 
      filter(treatment.group != rhs.treatment.group) %>% 
      mutate(stratum.ate = stratum.assign.mean.dewormed - stratum.ate,
             stratum.size = stratum.size + stratum.assign.size,
             stratum.sample.var = stratum.sample.var + stratum.assign.sample.var.dewormed)
  }
 
  calc.strata.ate <- function(.data) .data %>% 
    unite_("treatment.group", .treatment) %>% 
    group_by_(.dots = c(.strat.by, "treatment.group")) %>% 
    summarize(stratum.assign.size = n(),
              stratum.assign.mean.dewormed = mean(dewormed.any),
              stratum.assign.sample.var.dewormed = var(dewormed.any)/stratum.assign.size) %>%  
    ungroup %>% 
    mutate(total.size = sum(stratum.assign.size)) %>% 
    group_by_(.dots = .strat.by) %>% 
    do(calc.stratum.ate(.)) %>% 
    group_by_(.dots = c("treatment.group", .interact.with)) %>% 
    do(mutate(., treatment.mean.dewormed = weighted.mean(.$stratum.assign.mean.dewormed, .$stratum.assign.size))) %>% 
    ungroup
  
  strata.data <- .data %>% 
    calc.strata.ate
  
  strata.data %>% {
    left_join(distinct_(., .dots = c(.strat.by, "treatment.group", .interact.with), .keep_all = TRUE) %>% 
                select(-c(rhs.treatment.group, stratum.ate, stratum.size, stratum.sample.var)) %>%
                nest_exclude("strata.data", c("treatment.group", .interact.with)),
              group_by_(., .dots = c("treatment.group", "rhs.treatment.group", .interact.with)) %>%
                summarize(ate = weighted.mean(stratum.ate, stratum.size),
                          sample.var = sum(stratum.sample.var * ((stratum.size/total.size)^2)),
                          treatment.mean.dewormed = first(treatment.mean.dewormed)) %>% 
                ungroup %>% 
                nest_exclude("treatment.data", c("treatment.group", .interact.with)),
              c("treatment.group", .interact.with))
  }
}


analyze.neyman.blk.bs <- function(.data, .reps = 1000, .interact.with = NULL, ...) {
  .data %<>% 
    select(county, dist.pot.group, cluster.id, assigned.treatment, sms.treatment, dewormed.any) %>% {
     original.stats <- calc.strata.stats(., .interact.with = .interact.with, ...)
     
     if (.reps > 0) {
       bs.analysis <- block.bootstrap(., .reps, "cluster.id") %>%
         do(calc.strata.stats(., .interact.with = .interact.with, ...)) %>% 
         ungroup %>% 
         select_(.dots = c("replicate", "treatment.group", .interact.with, "treatment.data")) %>% 
         unnest(treatment.data) %>% 
         group_by_(.dots = c("treatment.group", "rhs.treatment.group", .interact.with)) %>%
         summarize_at(vars(ate, treatment.mean.dewormed), funs(mean(., na.rm = TRUE), sd(., na.rm = TRUE))) %>%
         mutate(ci.lower.treatment.mean.dewormed = treatment.mean.dewormed_mean - 1.64 * treatment.mean.dewormed_sd,
                ci.upper.treatment.mean.dewormed = treatment.mean.dewormed_mean + 1.64 * treatment.mean.dewormed_sd,
                ci.lower.ate = ate_mean - 1.64 * ate_sd,
                ci.upper.ate = ate_mean + 1.64 * ate_sd,
                treatment.mean.dewormed_tstat = treatment.mean.dewormed_mean/treatment.mean.dewormed_sd,
                ate_tstat = ate_mean/ate_sd,
                ate_pvalue = calc.pvalue(ate_tstat))
       
       original.stats %<>% 
         unnest(treatment.data) %>% 
         left_join(bs.analysis, c("treatment.group", "rhs.treatment.group", .interact.with)) %>% 
         nest_exclude("treatment.data", c("treatment.group", .interact.with)) %>% 
         left_join(original.stats %>% select(-treatment.data), ., c("treatment.group", .interact.with))
     } 
     
     return(original.stats)
   }
}
```

Below is the main regression specification, where $m(\cdot)$ and $m_1(\cdot)\dots m_{K-1}(\cdot)$ define the causal effects to estimate. $l(\cdot)$ and $l_1(\cdot)\dots l_{K-1}(\cdot)$ define the regression intercepts.

$$
\begin{equation}
Y_{ij} = \left(m(Z_j, B_j;\theta) + l(B_j;\theta^c) + X_{ij} \cdot \beta \right) \cdot \frac{B_{j}(K)}{N(K)/N} + \sum_{k=1}^{K-1} \left(m_k(Z_j, B_j;\theta_k) + l_k(B_j;\theta^c_k) + X_{ij} \cdot \beta_k \right) \cdot \left( B_{j}(k) - B_{j}(K)\cdot\frac{N(k)}{N(K)} \right) + \varepsilon_{ij} 
\end{equation}
$$

* $i$ indexes individuals, $j$ clusters
* $Z_{j}(z) = \mathbf{1}\{Z_j = z\}$ is an indicator for whether cluster $j$ was assigned treatment $z$.
* $B_{j}(k) = \mathbf{1}\{B_j = k\}$ is an indicator for whether cluster $j$ is in stratum $k$.
* $X_{ij}$ is a vector of covariates
* $N(k)$ is the size of startum $k$.
* $N$ is the total number of observations

## Basic Treatment Effect

Here we estimate the below models

$$
\begin{align}
m(Z_j, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} \tau(z) \cdot Z_{j}(z)  \\
m_k(Z_j, B_j; \theta_k) &= \sum_{z\in \mathcal{Z}\setminus\{control\}} \tau_k(z) \cdot Z_{j}(z) \\
l(B_j; \theta^c) &= \alpha \\
l_k(B_j; \theta^c_k) &= \alpha_k
\end{align}
$$
where $E[Y_{ij}(z) - Y_{ij}(control)] = \tau(z)$ and $E[Y_{ij}(control)] = \alpha$.

### Regression Without Controls

Without controls (using cluster robust standard errors). Also including block bootstrapped standard errors and p-values.

```{r, echo=FALSE, warning=FALSE}
reg.output.sms.ctrl <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg #(.bstrp.reps = 10) 
    
reg.output.sms.ctrl.calendar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate( assigned.treatment = relevel(assigned.treatment, ref = "calendar")) %>% 
  run.strat.reg 

kable(tidy(reg.output.sms.ctrl), digits = 4)
```

With _calendar_ as the omitted category, to estimate $E[Y_{ij}(bracelet) - Y_{ij}(calendar)] = \tau(bracelet) - \tau(calendar)$:
```{r}
reg.output.sms.ctrl.calendar %>% 
  tidy %>% 
  filter(term %in% c("(intercept)", "bracelet")) %>% 
  kable(digits = 4)
```

```{r incentive-barplot-fun, echo=FALSE}
prep.ref.group.col <- . %>% {
      intercept.est <- filter(., term == "(intercept)") %$% estimate
      mutate(., 
             ate = estimate,
             estimate = if_else(term != "(intercept)", estimate + intercept.est, estimate))
    } 

incentive.treat.barplot <- function(.data) { 
  .data %<>% 
    filter(ref == "ctrl.ref" | term == "bracelet") %>% 
    mutate(term = factor(term, levels = c("(intercept)", "ink", "calendar", "bracelet"), 
                         labels = c("Control", "Ink", "Calendar", "Bracelet")),
           p.val.label = sprintf("p-value = %.3f", p.value),
           ci.lb = estimate - 1.64 * std.error, 
           ci.ub = estimate + 1.64 * std.error) 
  
  .data %>% 
    ggplot(aes(term, estimate)) +
    geom_col(aes(fill = term %in% c("Control", "Ink")), color = "black", alpha = 0.25, data = . %>% filter(ref == "ctrl.ref")) +
    geom_errorbar(aes(color = ref, ymin = ci.lb, ymax = ci.ub), 
                  width = 0.1, position = "dodge", 
                  data = . %>% filter((term != "Control" & ref == "ctrl.ref") | (ref == "calendar.ref"))) +
    geom_text(aes(y = max(.data$ci.ub) + 0.055, label = p.val.label, color = ref), 
              data = . %>% filter(term != "Control", ref == "ctrl.ref")) +
    geom_text(aes(y = max(.data$ci.ub) + 0.02, label = p.val.label, color = ref), 
              data = . %>% filter(term != "Control", ref == "calendar.ref")) +
    geom_text(aes(label = sprintf("%.3f", estimate)), nudge_x = 0.2, nudge_y = -0.02, data = . %>% filter(ref == "ctrl.ref")) +
    geom_text(aes(y = 0.02, label = sprintf("ATE = %.3f", ate), color = ref), 
              data = . %>% filter(ref == "calendar.ref", term != "Control")) +
    geom_text(aes(y = 0.055, label = sprintf("ATE = %.3f", ate), color = ref), 
              data = . %>% filter(ref == "ctrl.ref", term != "Control")) +
    scale_y_continuous("Proportion of Take-up", breaks = seq(0, 1, 0.05)) +
    scale_x_discrete("Treatment") +
    scale_color_manual("Reference Arm", values = c("red", "black"), labels = c("Calendar", "Control")) +
    scale_fill_manual("", values = c("red", "black"), labels = c("Calendar vs Bracelet", "Control vs Ink")) +
    theme(legend.position = "bottom")
}
```

```{r}
lst(ctrl.ref = reg.output.sms.ctrl, calendar.ref = reg.output.sms.ctrl.calendar) %>% 
  map_df(tidy, .id = "ref") %>% 
  group_by(ref) %>% 
  do(prep.ref.group.col(.)) %>% 
  ungroup %>% {
    incentive.treat.barplot(.) +
      labs(title = "Estimated Take-up", subtitle = "Without Controls")
  }
```


```{r, echo=FALSE, eval=FALSE}
reg.output.sms.ctrl$linear.tests %>% 
  select(linear.hypo, estimate, statistic, p.value) %>% 
  kable(digits = 4)
```

<!-- Below is the corresponding estimates using Neyman's approach (using block bootstrap standard errors): -->

```{r, echo=FALSE}
neyman.results <- analysis.data %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  analyze.neyman.blk.bs(2000) %>% 
  mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet")))  
```


```{r, echo=FALSE, eval=FALSE}
neyman.results %>% 
  unnest(treatment.data) %>%
  filter(rhs.treatment.group == "control" | (treatment.group == "bracelet" & rhs.treatment.group == "calendar")) %>% 
  select(treatment.group, rhs.treatment.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
  kable(digits = 4)
```

Stratum-level deworming probability:

```{r, echo=FALSE}
neyman.results %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, treatment.group, stratum.assign.mean.dewormed) %>% 
  spread(treatment.group, stratum.assign.mean.dewormed) %>% 
  kable(digits = 4)
```

```{r, echo=FALSE}
neyman.results %>% 
  unnest(treatment.data) %>% 
  distinct(treatment.group, .keep_all = TRUE) %>% 
  ggplot() +
    geom_col(aes(treatment.group, treatment.mean.dewormed), alpha = 0.5, color = "black") +
    scale_x_discrete("Treatment") +
    scale_y_continuous("Proportion Dewormed", breaks = seq(0, 0.6, 0.05))
```

```{r, echo=FALSE}
neyman.results %>% 
  unnest(strata.data) %>% 
  ggplot(aes(factor(treatment.group))) +
  geom_col(aes(y = stratum.assign.mean.dewormed), color = "black", alpha = 0.5) +
  scale_x_discrete("") +
  scale_y_continuous("Take-up Proportion") +
  facet_grid(county ~ dist.pot.group)
```

Strata sizes:

```{r, echo=FALSE}
neyman.results %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, treatment.group, stratum.assign.size) %>% 
  spread(treatment.group, stratum.assign.size) %>% 
  kable()
```

### Regression With Controls

```{r covariates, echo=FALSE}
reg.covar <- c("school", "floor", "ethnicity", "sms.ctrl.subpop")
```

```{r, echo=FALSE}
reg.output.sms.ctrl.covar <- analysis.data %>%  
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(.covariates = reg.covar) 

reg.output.sms.ctrl.calendar.covar <- analysis.data %>%  
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate( assigned.treatment = relevel(assigned.treatment, ref = "calendar")) %>% 
  run.strat.reg(.covariates = reg.covar) 

kable(tidy(reg.output.sms.ctrl.covar), digits = 4)
```

```{r, echo=FALSE}
reg.output.sms.ctrl.calendar.covar %>% 
  tidy %>% 
  filter(term %in% c("(intercept)", "bracelet")) %>% 
  kable(digits = 4)
```

```{r, echo=FALSE}
lst(ctrl.ref = reg.output.sms.ctrl.covar, calendar.ref = reg.output.sms.ctrl.calendar.covar) %>% 
  map_df(tidy, .id = "ref") %>% 
  group_by(ref) %>% 
  do(prep.ref.group.col(.)) %>% 
  ungroup %>% { 
    incentive.treat.barplot(.) +
      labs(title = "Estimated Take-up", subtitle = "With Controls")
  }
```


```{r, eval=FALSE}
reg.output$linear.tests %>% 
  select(linear.hypo, estimate, statistic, p.value) %>% 
  kable(digits = 4)
```

## Phone Ownership

```{r, echo=FALSE}
reg.output.nonphone <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% #, sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.ctrl.subpop"))

reg.output.phone <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% #, sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate(sms.ctrl.subpop = relevel(factor(sms.ctrl.subpop), ref = "phone.owner")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.ctrl.subpop"))

reg.output.nonphone.calendar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% #, sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate(assigned.treatment = relevel(assigned.treatment, ref = "calendar")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.ctrl.subpop"))

reg.output.phone.calendar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% #, sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate(sms.ctrl.subpop = relevel(factor(sms.ctrl.subpop), ref = "phone.owner"),
         assigned.treatment = relevel(assigned.treatment, ref = "calendar")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.ctrl.subpop"))

kable(tidy(reg.output.nonphone), digits = 4)
```
```{r, eval=FALSE}
linear.tester(reg.output.nonphone.covar, c("ink:phone.owner"))
```

```{r, fig.width=12}
phone.prep <- . %>% map_df(tidy, .id = "phone") 

lst(ctrl.ref = lst("Phone Owners" = reg.output.phone,
                   "Non-phone Owners" = reg.output.nonphone) %>% 
      phone.prep,
    calendar.ref = lst("Phone Owners" = reg.output.phone.calendar,
                       "Non-phone Owners" = reg.output.nonphone.calendar) %>% 
      phone.prep) %>% 
  bind_rows(.id = "ref") %>% 
  filter(!str_detect(term, "phone")) %>% 
  group_by(ref, phone) %>% 
  do(prep.ref.group.col(.)) %>% 
  ungroup %>% { 
    incentive.treat.barplot(.) + 
      facet_wrap(~ phone) +
      labs(title = "Estimated Take-up Phone Ownership", subtitle = "Without Controls")
  }
```

```{r, echo=FALSE}
reg.output.nonphone.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% #, sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.ctrl.subpop"),
                .covariates = setdiff(reg.covar, "sms.ctrl.subpop"))

reg.output.phone.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% #, sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate(sms.ctrl.subpop = relevel(factor(sms.ctrl.subpop), ref = "phone.owner")) %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.ctrl.subpop"),
                .covariates = setdiff(reg.covar, "sms.ctrl.subpop"))

reg.output.nonphone.calendar.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% #, sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate(assigned.treatment = relevel(assigned.treatment, ref = "calendar")) %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.ctrl.subpop"),
                .covariates = setdiff(reg.covar, "sms.ctrl.subpop"))

reg.output.phone.calendar.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% #, sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate(sms.ctrl.subpop = relevel(factor(sms.ctrl.subpop), ref = "phone.owner"),
         assigned.treatment = relevel(assigned.treatment, ref = "calendar")) %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.ctrl.subpop"),
                .covariates = setdiff(reg.covar, "sms.ctrl.subpop"))

kable(tidy(reg.output.nonphone.covar), digits = 4)
```

```{r, fig.width=12}
lst(ctrl.ref = lst("Phone Owners" = reg.output.phone.covar,
                   "Non-phone Owners" = reg.output.nonphone.covar) %>% 
      phone.prep,
    calendar.ref = lst("Phone Owners" = reg.output.phone.calendar.covar,
                       "Non-phone Owners" = reg.output.nonphone.calendar.covar) %>% 
      phone.prep) %>% 
  bind_rows(.id = "ref") %>% 
  filter(!str_detect(term, "phone")) %>% 
  group_by(ref, phone) %>% 
  do(prep.ref.group.col(.)) %>% 
  ungroup %>% { 
    incentive.treat.barplot(.) + 
      facet_wrap(~ phone) +
      labs(title = "Estimated Take-up By Phone Ownership", subtitle = "With Controls")
  }
```

```{r, echo=FALSE, eval=FALSE}
neyman.results.no.phone <- analysis.data %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control", sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  analyze.neyman.blk.bs(2000) %>% 
  mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet")))  
```

```{r, echo=FALSE, eval=FALSE}
neyman.results.no.phone %>% 
  unnest(treatment.data) %>%
  filter(rhs.treatment.group == "control") %>% 
  select(treatment.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
  kable(digits = 4)
```

## Treatment Effect Heterogeneity by Distance to PoT

Here we estimate the below models

$$
\begin{align}
m(Z_j, D_j, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} Z_{j}(z) \cdot \left\{\tau(z) + \lambda(z) \cdot D_j \right\} + \delta \cdot D_j  \\
m_k(Z_j, D_j, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}}Z_{j}(z)  \cdot \left\{\tau_k(z) + \lambda_k(z) \cdot  D_j \right\} + \delta_k \cdot D_j 
\end{align}
$$

where $D_j$ is an indicator for whether cluster $j$ is in the _far_ group. The average treatment estimated here is
$$
E[Y_{ij}(z) - Y_{ij}(control) | D_j = d] = \tau(z) + \lambda(z)\cdot d 
$$

### Without Controls

```{r, echo=FALSE}
reg.output.sms.ctrl.dist <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "dist.pot.group"))

reg.output.sms.ctrl.dist.calendar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate(assigned.treatment = relevel(assigned.treatment, ref = "calendar")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "dist.pot.group"))

reg.output.sms.ctrl.dist.far <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate(dist.pot.group = relevel(dist.pot.group, ref = "far")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "dist.pot.group"))

reg.output.sms.ctrl.dist.calendar.far <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate(assigned.treatment = relevel(assigned.treatment, ref = "calendar"),
         dist.pot.group = relevel(dist.pot.group, ref = "far")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "dist.pot.group"))

kable(tidy(reg.output.sms.ctrl.dist), digits = 4)
```

```{r}
c("ink", "calendar", "bracelet") %>% 
  map(~ paste0(., c("", ":far"))) %>%
  map(~ paste(., collapse = " + ")) %>% 
  linear.tester(reg.output.sms.ctrl.dist, .)
```

```{r}
c("ink", "calendar", "bracelet") %>% 
  map(~ c(paste0(., ":far"), "far")) %>%
  map(~ paste(., collapse = " + ")) %>% 
  linear.tester(reg.output.sms.ctrl.dist, .)
```

```{r}
reg.output.sms.ctrl.close <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control", dist.pot.group == "close") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(.treatment = "assigned.treatment", .strat.by = "county")

reg.output.sms.ctrl.far <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control", dist.pot.group == "far") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(.treatment = "assigned.treatment", .strat.by = "county")

kable(tidy(reg.output.sms.ctrl.close), digits = 4)
kable(tidy(reg.output.sms.ctrl.far), digits = 4)
```

```{r, fig.width=12}
far.close.prep <- . %>% map_df(tidy, .id = "dist.pot.group") 

lst(ctrl.ref = lst(close = reg.output.sms.ctrl.dist, 
                   far = reg.output.sms.ctrl.dist.far) %>% 
      far.close.prep,
    calendar.ref = lst(close = reg.output.sms.ctrl.dist.calendar, 
                       far = reg.output.sms.ctrl.dist.calendar.far) %>% 
      far.close.prep) %>% 
  bind_rows(.id = "ref") %>% 
  filter(!str_detect(term, "far|close")) %>% 
  group_by(ref, dist.pot.group) %>% 
  do(prep.ref.group.col(.)) %>% 
  ungroup %>%  
  mutate(dist.pot.group = factor(dist.pot.group, levels = c("close", "far"), labels = c("Close", "Far"))) %>% {
    incentive.treat.barplot(.) + 
      facet_wrap(~ dist.pot.group) +
      labs(title = "Estimated Take-up By Distance from PoT", subtitle = "Without Controls")
  }
```


Below is the corresponding estimation using Neyman's approach:

```{r, echo=FALSE}
neyman.results.dist <- analysis.data %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  analyze.neyman.blk.bs(2000, .interact.with = "dist.pot.group") %>% 
  mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet"))) 
```

```{r, echo=FALSE}
neyman.results.dist %>% 
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "control") %>% 
  select(treatment.group, dist.pot.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
  kable(digits = 4)
```

Stratum-level deworming probability:

```{r, echo=FALSE}
neyman.results.dist %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, treatment.group, stratum.assign.mean.dewormed) %>% 
  unite(incentive_dist, treatment.group, dist.pot.group) %>% 
  spread(incentive_dist, stratum.assign.mean.dewormed) %>% 
  kable(digits = 4)
```

```{r, echo=FALSE}
neyman.results.dist %>% 
  unnest(treatment.data) %>% 
  distinct(treatment.group, dist.pot.group, .keep_all = TRUE) %>% 
  ggplot(.) +
  geom_col(aes(treatment.group, treatment.mean.dewormed, fill = dist.pot.group), alpha = 0.5, color = "black", position = "dodge") +
  scale_x_discrete("Treatment") +
  scale_y_continuous("Proportion Dewormed", breaks = seq(0, 0.6, 0.05)) +
  scale_fill_discrete("Distance to PoT")
```

Strata sizes:

```{r, echo=FALSE}
neyman.results %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, treatment.group, stratum.assign.size) %>% 
  unite(incentive_dist, treatment.group, dist.pot.group) %>% 
  spread(incentive_dist, stratum.assign.size) %>% 
  kable()
```

### With Controls

```{r, echo=FALSE}
reg.output.sms.ctrl.dist.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "dist.pot.group"), .covariates = reg.covar)

kable(tidy(reg.output.sms.ctrl.dist.covar), digits = 4)

reg.output.sms.ctrl.dist.calendar.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  mutate(assigned.treatment = relevel(assigned.treatment, ref = "calendar")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "dist.pot.group"), .covariates = reg.covar)

reg.output.sms.ctrl.dist.far.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  mutate(dist.pot.group = relevel(dist.pot.group, ref = "far")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "dist.pot.group"), .covariates = reg.covar)

reg.output.sms.ctrl.dist.calendar.far.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  mutate(assigned.treatment = relevel(assigned.treatment, ref = "calendar"),
         dist.pot.group = relevel(dist.pot.group, ref = "far")) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "dist.pot.group"), .covariates = reg.covar)

# reg.output <- analysis.data %>%  
#   mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
#   filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
#   anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
#   left_join(calc.strat.interaction.terms(., .treatment = c("assigned.treatment", "dist.pot.group")), "KEY.individ") %>% 
#   run.strat.reg(.covariates = c("school", "floor", "ethnicity", "sms.ctrl.subpop"),
#                 .linear.hypo = c("ink", "calendar", "bracelet") %>% 
#                   map(~ paste0(., c("", "_far")) %>% 
#                   map(~ paste(., collapse = " + ")))) 
# 
# kable(reg.output$reg.summary, digits = 4)
# 
# reg.output$linear.tests %>% 
#   select(linear.hypo, estimate, statistic, p.value) %>% 
#   kable(digits = 4)
```

```{r, fig.width=12}
lst(ctrl.ref = lst(close = reg.output.sms.ctrl.dist.covar, 
                   far = reg.output.sms.ctrl.dist.far.covar) %>% 
      far.close.prep,
    calendar.ref = lst(close = reg.output.sms.ctrl.dist.calendar.covar, 
                       far = reg.output.sms.ctrl.dist.calendar.far.covar) %>% 
      far.close.prep) %>% 
  bind_rows(.id = "ref") %>% 
  filter(!str_detect(term, ":|far|close")) %>% 
  group_by(ref, dist.pot.group) %>% 
  do(prep.ref.group.col(.)) %>% 
  ungroup %>% 
  mutate(dist.pot.group = factor(dist.pot.group, levels = c("close", "far"), labels = c("Close", "Far"))) %>% {
    incentive.treat.barplot(.) + 
      facet_wrap(~ dist.pot.group) +
      labs(title = "Estimated Take-up By Distance from PoT", subtitle = "With Controls")
  }
```

```{r, echo=FALSE}
reg.output.sms.ctrl.close.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control", dist.pot.group == "close") %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(.treatment = "assigned.treatment", .strat.by = "county", .covariates = reg.covar)

kable(tidy(reg.output.sms.ctrl.close.covar), digits = 4)

reg.output.sms.ctrl.far.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control", dist.pot.group == "far") %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(.treatment = "assigned.treatment", .strat.by = "county", .covariates = reg.covar)

kable(tidy(reg.output.sms.ctrl.far.covar), digits = 4)
```

<!-- ### Non-Phone Owners Only -->

```{r, echo=TRUE, eval=FALSE}
reg.output <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control", sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  left_join(calc.strat.interaction.terms(., .treatment = c("assigned.treatment", "dist.pot.group")), "KEY.individ") %>% 
  run.strat.reg(.linear.hypo = c("ink", "calendar", "bracelet") %>% 
                  map(~ paste0(., c("", "_far")) %>% 
                  map(~ paste(., collapse = " + ")))) 

kable(reg.output$reg.summary, digits = 4)

reg.output$linear.tests %>% 
  select(linear.hypo, estimate, statistic, p.value) %>% 
  kable(digits = 4)
```

```{r, echo=TRUE, eval=FALSE}
neyman.results.dist.no.phone <- analysis.data %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control", sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  analyze.neyman.blk.bs(2000, .interact.with = "dist.pot.group") %>% 
  mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet"))) 
```

```{r, eval=FALSE}
neyman.results.dist.no.phone %>% 
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "control") %>% 
  select(treatment.group, dist.pot.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
  kable(digits = 4)
```

## SMS Treatment

Here we estimate the below models

$$
\begin{align}
m(Z_j, M_{ij}, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}}Z_{j}(z) \cdot \left\{\tau(z) + \sum_{s \in \mathcal{M}\setminus \{none\}} \gamma(z, s) \cdot M_{ij}(s) \right\} + \sum_{s\in\mathcal{M}\setminus \{none\}} \psi(s) \cdot M_{ij}(s)  \\
m_k(Z_j, M_{ij}, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} Z_{j}(z) \cdot \left\{\tau_k(z) + \sum_{s \in \mathcal{M}\setminus \{none\}} \gamma_k(z, s)\cdot M_{ij}(s) \right\} + \sum_{s\in\mathcal{M}\setminus \{none\}} \psi_k(s) \cdot M_{ij}(s)  
\end{align}
$$
where $M_{ij}(s)$ is an indicator of whether individual $i$ received SMS treatment $s$.

The average treatment estimated here is
$$
E[Y_{ij}(z, s) - Y_{ij}(z', s')] = \tau(z) - \tau(z') + \gamma(z, s) - \gamma(z', s') + \psi(s) - \psi(s'),
$$
where 

* $\tau(control) = \psi(none) = 0$ 
* $z = control \lor s = none \implies \gamma(z, s) = 0$

The following table simplifies thinking about the analysis outlined in the pre-analysis plan:

|                             | Control  | Ink | Calendar | Bracelet |
|-----------------------------|:--------:|:---:|:--------:|:--------:|
| No SMS                      | 1        | 4   | 6        | 8        |
| Reminder SMS                | 2        | --- | ---      | ---      |
| Reminder  + Peer Info SMS   | 3        | 5   | 7        | 9        |

:Cluster-level Treatment Arms\label{tab:cluster-level-treatment}

### Without Controls

```{r, echo=TRUE}
reg.output.sms <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>% 
  anti_join(outlier.clusters, "cluster.id") %>% 
  mutate(sms.treatment = factor(sms.treatment, levels = c("sms.control", "reminder.only", "social.info"))) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.treatment"))

reg.output.sms %>% tidy %>% kable(digits = 4)
```

Some linear hypotheses testing:
```{r}
c("ink", "calendar", "bracelet") %>% 
                  map(~ c(paste0(., ":social.info"), "social.info")) %>% 
                  map(~ paste(., collapse = " + ")) %>% 
                  c("bracelet - calendar",
                    "ink - social.info", 
                    "bracelet - calendar - calendar:social.info - social.info",
                    "ink + ink:social.info", 
                    "bracelet - calendar + bracelet:social.info - calendar:social.info") %>% 
  linear.tester(reg.output.sms, .) %>% 
  kable(digits = 4)
```


Corresponding Neyman's approach:

```{r, echo=TRUE}
neyman.results.sms <- analysis.data %>% 
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>% 
  anti_join(outlier.clusters, "cluster.id") %>% 
  analyze.neyman.blk.bs(2000, .treatment = c("assigned.treatment", "sms.treatment")) %>% 
  separate(treatment.group, c("assigned.treatment", "sms.treatment"), sep = "_") %>% 
  mutate(assigned.treatment = factor(assigned.treatment, levels = c("control", "ink", "calendar", "bracelet")))  
```

```{r}
neyman.results.sms %>% 
  unnest(treatment.data) %>% 
  filter(str_detect(rhs.treatment.group, paste0("^", assigned.treatment)) | 
           (assigned.treatment == "ink" & str_detect(rhs.treatment.group, "^control")) |
           (assigned.treatment == "bracelet" & str_detect(rhs.treatment.group, "^calendar"))) %>% 
         # sms.treatment != "sms.control") %>% 
  select(assigned.treatment, sms.treatment, rhs.treatment.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
  kable
```

```{r, echo=FALSE, fig.align="center"}
neyman.results.sms %>% 
  unnest(strata.data) %>% 
  select(assigned.treatment, sms.treatment, county, dist.pot.group, treatment.mean.dewormed) %>% 
  distinct(assigned.treatment, sms.treatment, .keep_all = TRUE) %>% 
  mutate(sms.treatment = factor(sms.treatment, 
                                levels = c("sms.control", "reminder.only", "social.info"),
                                labels = c("None", "Reminder Only", "Social Information")),
         assigned.treatment = factor(str_to_title(assigned.treatment))) %>% 
  ggplot(aes(sms.treatment, treatment.mean.dewormed)) +
  geom_point(aes(color = assigned.treatment, group = assigned.treatment)) +
  geom_line(aes(color = assigned.treatment, group = assigned.treatment, linetype = "Including Reminder-Only"), 
            data = . %>% filter(assigned.treatment == "Control")) +
  geom_line(aes(color = assigned.treatment, group = assigned.treatment, linetype = "Excluding Reminder-Only"), 
            data = . %>% filter(sms.treatment != "Reminder Only")) +
  scale_x_discrete("Text Messaging Treatment") +
  scale_y_continuous("Take-up Proportion", breaks = seq(0, 0.7, 0.025)) +
  scale_color_discrete("Incentive Treatment") +
  scale_linetype_manual("", values = c("solid", "dashed"))
```

Stratum-level deworming probability:

```{r}
neyman.results.sms %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, assigned.treatment, sms.treatment, stratum.assign.mean.dewormed) %>% 
  unite(incentive_sms, assigned.treatment, sms.treatment) %>% 
  spread(incentive_sms, stratum.assign.mean.dewormed) %>% 
  kable(digits = 4)
```

Strata sizes:

```{r}
neyman.results %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, treatment.group, stratum.assign.size) %>% 
  spread(treatment.group, stratum.assign.size) %>% 
  kable()
```

### With Controls

```{r, echo=TRUE}
reg.output.sms.covar <- analysis.data %>%  
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>% 
  anti_join(outlier.clusters, "cluster.id") %>% 
  mutate(sms.treatment = factor(sms.treatment, levels = c("sms.control", "reminder.only", "social.info"))) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.treatment"),
                .covariates = c("school", "floor", "ethnicity"))

reg.output.sms.covar %>% tidy %>% kable(digits = 4)
```

Some linear hypotheses testing:
```{r}
c("ink", "calendar", "bracelet") %>% 
  map(~ c(paste0(., ":social.info"), "social.info")) %>% 
  map(~ paste(., collapse = " + ")) %>% 
  c("bracelet - calendar",
    "ink - social.info", 
    "bracelet - calendar - calendar:social.info - social.info",
    "ink + ink:social.info", 
    "bracelet - calendar + bracelet:social.info - calendar:social.info") %>% 
  linear.tester(reg.output.sms.covar, .) %>% 
  kable(digits = 4)
```

## SMS Treatment And Distance to PoT

Here we estimate the below models

$$
\begin{align}
m(Z_j, M_{ij}, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} Z_{j}(z) \cdot \left\{\tau(z) + \lambda(z) \cdot D_j + \sum_{s \in \mathcal{M}\setminus \{none\}} M_{ij}(s) \cdot \left[ \gamma(z, s) + \rho(z, s) \cdot D_j \right] \right\} \\
&+ \sum_{s\in\mathcal{M}\setminus \{none\}}  M_{ij}(s) \left\{\psi(s) + \pi(s) \cdot D_j \right\}  + \delta \cdot D_j  \\
m_k(Z_j, M_{ij}, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} Z_{j}(z) \cdot \left\{\tau_k(z) + \lambda_k(z) \cdot D_j + \sum_{s \in \mathcal{M}\setminus \{none\}} M_{ij}(s) \cdot \left[ \gamma_k(z, s) + \rho_k(z, s) \cdot D_j \right] \right\} \\ 
&+ \sum_{s\in\mathcal{M}\setminus \{none\}}  M_{ij}(s) \left\{\psi_k(s) + \pi_k(s) \cdot D_j \right\}  + \delta_k \cdot D_j  \\
\end{align}
$$

$$
\begin{align}
E[Y_{ij}(z, s) - Y_{ij}(z', s')|D_j = d] &= \tau(z) - \tau(z') + \left\{\lambda(z) - \lambda(z')\right\} \cdot d + \left\{\rho(z,s) - \rho(z', s')\right\} \cdot d + \gamma(z, s) - \gamma(z', s') \\
&+ \psi(s) - \psi(s') + \left\{\pi(s) - \pi(s')\right\}\cdot d,
\end{align}
$$

```{r, echo=TRUE}
reg.output.sms.dist <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>% 
  anti_join(outlier.clusters, "cluster.id") %>% 
  mutate(sms.treatment = factor(sms.treatment, levels = c("sms.control", "reminder.only", "social.info"))) %>% 
  run.strat.reg(.treatment = c("assigned.treatment", "sms.treatment", "dist.pot.group")) 

reg.output.sms.dist %>% tidy %>% kable(digits = 4)
```

# Old Analysis

The take-up levels in the control arm (per stratum) are:

```{r, eval=FALSE}
neyman.results %>% 
  unnest(strata.data) %>% 
  filter(treatment.group == "control") %>% 
  arrange(county, dist.pot.group, treatment.group) %>% 
  transmute(county, dist.pot.group, baseline.takeup = stratum.assign.mean.dewormed)
```

```{r, eval=FALSE}
neyman.results %>% 
  unnest(treatment.data) %>% 
  distinct(treatment.group, treatment.mean.dewormed)
```



```{r, eval=FALSE}
neyman.results.sms.only %>% 
  unest(treatment.data) %>% 
  distinct(treatment.group, .keep_all = TRUE) %>% 
  ggplot() +
    geom_col(aes(treatment.group, treatment.mean.dewormed), alpha = 0.5, color = "black") +
    scale_x_discrete("Treatment") +
    scale_y_continuous("Proportion Dewormed", breaks = seq(0, 0.6, 0.05))

neyman.results.sms.only %>% 
  unest(treatment.data) %>% 
  distinct(treatment.group, sms.treatment, .keep_all = TRUE) %>% 
  ggplot(.) +
  geom_col(aes(treatment.group, treatment.mean.dewormed, fill = sms.treatment), alpha = 0.5, color = "black", position = "dodge") +
  scale_x_discrete("Treatment") +
  scale_y_continuous("Proportion Dewormed", breaks = seq(0, 0.6, 0.05)) +
  scale_fill_discrete("Distance to PoT")
```


```{r, include=FALSE, eval=FALSE}
neyman.results.sms <- census.data %>%
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>%
  anti_join(outlier.clusters, "cluster.id") %>% 
  transmute(stratum = paste(county, dist.pot.group, sep = "."),
            county, dist.pot.group, cluster.id, assigned.treatment, sms.treatment, dewormed.any) %>%
  # block.bootstrap(1000, "cluster.id") %>%
  do(calc.strata.stats(., .treatment = c("assigned.treatment", "sms.treatment"), .interact.ate.with = "dist.pot.group")) #%>%
  # ungroup %>%
  # select(-baseline) %>%
  # group_by(assigned.treatment, dist.pot.group) %>%
  # summarize_at(vars(starts_with("ate"), treat.grp.dewormed), funs(mean(., na.rm = TRUE), sd(., na.rm = TRUE))) %>%
  # mutate(ci.lower.dewormed = treat.grp.dewormed_mean - 1.64 * treat.grp.dewormed_sd,
  #        ci.upper.dewormed = treat.grp.dewormed_mean + 1.64 * treat.grp.dewormed_sd,
  #        ci.lower.ate = ate_mean - 1.64 * ate_sd,
  #        ci.upper.ate = ate_mean + 1.64 * ate_sd,
  #        ci.lower.ate.calendar = ate.calendar_mean - 1.64 * ate.calendar_sd,
  #        ci.upper.ate.calendar = ate.calendar_mean + 1.64 * ate.calendar_sd)
```

```{r, eval=FALSE}
census.data %>%
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>%
  transmute(stratum = paste(county, dist.pot.group, sep = "."),
            county, dist.pot.group, cluster.id, assigned.treatment, sms.treatment, dewormed.any) %>%
  calc.strata.stats(., .treatment = c("assigned.treatment", "sms.treatment"))
```

## Non SMS treated individuals 

Phone and non-phone owners

### Compared to _control_

```{r, echo=FALSE}
neyman.results %>%
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "control") %>% 
  ggplot(aes(treatment.group, ate)) + #, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_point() +  #, color = "black") +
  geom_line(aes(group = 1)) + #aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate, ymax = ci.upper.ate), width = 0.05) +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) #+
  # facet_wrap(~ dist.pot.group, scales = "free_y")
```

```{r, echo=FALSE}
neyman.results.dist %>%
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "control") %>% 
  ggplot(aes(treatment.group, ate, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_line(aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate, ymax = ci.upper.ate), width = 0.05, position = "dodge") +
  geom_point(color = "black") +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) +
  facet_wrap(~ dist.pot.group, scales = "free_y")
```

### Compared to _calendar_ group

```{r, echo=FALSE}
neyman.results %>%
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "calendar") %>% 
  ggplot(aes(treatment.group, ate_mean)) + #, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_point() +  #, color = "black") +
  geom_line(aes(group = 1)) + #aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate, ymax = ci.upper.ate), width = 0.05) +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) #+
  # facet_wrap(~ dist.pot.group, scales = "free_y")
```

```{r}
neyman.results.dist %>%
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "calendar") %>% 
  ggplot(aes(treatment.group, ate, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_line(aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate, ymax = ci.upper.ate), width = 0.05, position = "dodge") +
  geom_point(color = "black") +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) +
  facet_wrap(~ dist.pot.group, scales = "free_y")
```


## All phone owners

### Compared to control

```{r, echo=FALSE, eval=FALSE}
neyman.results.all %>%
  filter(assigned.treatment != "control") %>% 
  ggplot(aes(assigned.treatment, ate_mean, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_point() +  #, color = "black") +
  geom_line(aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate, ymax = ci.upper.ate), width = 0.05) +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) +
  facet_wrap(~ dist.pot.group, scales = "free_y")

```

### Compared to _calendar_ group

```{r, eval=FALSE}
neyman.results.all %>%
  filter(assigned.treatment != "calendar") %>% 
  ggplot(aes(assigned.treatment, atecalendar_mean, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_point() +  #, color = "black") +
  geom_line(aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate.calendar, ymax = ci.upper.ate.calendar), width = 0.05) +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) +
  facet_wrap(~ dist.pot.group, scales = "free_y")
```


