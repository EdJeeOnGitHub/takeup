---
title: "TakeUp Analysis Notebook"
author:
- Anne Karing^[University of California Berkeley]
- Karim Naguib^[Evidence Action]
output:
  html_notebook:
    fig_align: "center"
    fig_caption: yes
    fig_height: 5
    fig_width: 8
    number_sections: yes
    theme: flatly
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
header-includes:
   - \usepackage{bbm}
date: "`r format(Sys.time(), '%B %d, %Y')`"
---

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


```{r setup, include=FALSE}
library(plyr)
library(dplyr)
library(multidplyr)
library(tibble)
library(tidyr)
library(lubridate)
library(purrr)
library(forcats)
library(readr)
library(haven)
library(lmtest)
library(car)
library(broom)
library(ggplot2)
library(viridis)
library(ggrepel)
library(ggmap)
library(stringr)
library(knitr)

source("../util.R")
source("takeup_rct_assign_clusters.R")
source("analysis_util.R")

knitr::read_chunk("analysis_util.R", labels = "analysis-util")

config <- yaml::yaml.load_file("../local_config.yaml")

doParallel::registerDoParallel(cores = config$cores)

wgs.84 <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
kenya.proj4 <- "+proj=utm +zone=36 +south +ellps=clrk80 +units=m +no_defs"

do.neyman.analysis <- TRUE

options(dplyr.show_progress = FALSE, digits = 4)
```

# Data

```{r load-data, include=FALSE}
# This data was prepared in takeup_field_notebook.Rmd
census.data <- read_rds("data/takeup_census.rds")
baseline.data <- read_rds("data/takeup_baseline_data.rds") 
takeup.data <- read_rds("data/takeup.rds")
all.endline.data <- read_rds("data/all_endline.rds")
reconsent.data <- read_rds("data/reconsent.rds")
sms.content.data <- read_rds("data/takeup_sms_treatment.rds")
cluster.strat.data <- read_rds("data/takeup_processed_cluster_strat.rds")  
```

These are the _monitored_: baseline and endline survey respondents, as well as a sample of people from whom we will receive reconsent without surveying.

```{r, results='asis'}
census.data %>% 
  filter(!is.na(wave), # Actually in the study (not in one of the dropped clusters)
         monitored) %>% {
    count(., endline.type) %>% kable %>% print
    
    filter(., is.na(endline.type)) %>% count(baseline.sample.wave)
  } %>% 
  kable
```

~~Below is the name matching code. We are using this function to identify individuals in a census who received treatment in their cluster's point-of-treatment and were not recorded by enumerators during their take-up monitoring. This is necessary to estimate take-up for non-phone owners, who were not included in the monitoring list provided to enumerators, in four of the six experiment strata (wave 1).~~ (Moved to external script).

We consider two individuals (in the take-up and census data) to be matched if the sum of edit (Levenshtein) distances of the first and last names is less than or equal to 1.

Below we are linking the consent, census (including take-up status), and endline data to generate the analysis data set. At this stage, we are including everyone in the census--the entire cluster populations. For our analysis, we will filter on consent. (Code moved to separate script).

```{r data-preparation, warning=FALSE}
analysis.data <- prepare.analysis.data(census.data, takeup.data, all.endline.data, reconsent.data, cluster.strat.data)

old.baseline.data <- baseline.data
baseline.data %<>% prepare.baseline.data
```

Below we want to identify outlier clusters. 

```{r outliers, echo=FALSE}
cluster.takeup.data <- prepare.cluster.takeup.data(analysis.data)
```

```{r, echo=FALSE, fig.width=12, fig.height=10}
cluster.takeup.data %>% 
  ggplot(aes(stratum, takeup.prop)) +
  geom_boxplot() + #aes(color = assigned.treatment)) + 
  geom_text_repel(aes(label = cluster.id), data = . %>% filter(outlier)) +
  xlab("Strata") +
  scale_y_continuous("Cluster Proportion Proportion", breaks = seq(0, 0.8, 0.05)) +
  # scale_color_discrete("Treatment") +
  facet_grid(sms.treatment ~ assigned.treatment) +
  theme(legend.position = "bottom", axis.text.x = element_blank(), axis.text.y = element_blank())
```

The outlier clusters are:
```{r, echo=FALSE}
outlier.clusters <- cluster.takeup.data %>% filter(outlier) #c(249, 141, 343)

outlier.clusters %>% 
  select(cluster.id, sms.treatment) %>% 
  kable
```

# Knowledge and Beliefs

## Knowledge

```{r}
baseline.data %>% 
  transmute(who_worms) %>% 
  unnest %>% 
  ggplot(aes(who_worms)) +
  geom_bar() +
  coord_flip() +
  labs(title = "Who's at risk of worm?", x = "")
```

```{r}
baseline.data %>% 
  transmute(effect_worms) %>% 
  unnest %>% 
  ggplot(aes(effect_worms)) +
  geom_bar() +
  coord_flip() +
  labs(title = "What are the effects of worms?", x = "")
```

```{r}
baseline.data %>% 
  select(spread_worms) %>% 
  ggplot(aes(spread_worms)) +
  geom_bar() +
  coord_flip() +
  labs(title = "Can a worms infected person spread worms to others?", x = "")
```

```{r}
baseline.data %>% 
  transmute(how_spread) %>% 
  unnest %>% 
  ggplot(aes(how_spread)) +
  geom_bar() +
  coord_flip() +
  labs(title = "How are worms spread?", x = "")
```

```{r}
baseline.data %>% 
  transmute(stop_worms) %>% 
  unnest %>% 
  ggplot(aes(stop_worms)) +
  geom_bar() +
  coord_flip() +
  labs(title = "How to stop worms?", x = "")
```

```{r}
baseline.data %>% 
  transmute(when_treat) %>% 
  unnest %>% 
  ggplot(aes(when_treat)) +
  geom_bar() +
  coord_flip() +
  labs(title = "When should people deworm?", x = "")
```


## Externalities

```{r}
baseline.data %>% 
  select(worms_affect) %>% 
  ggplot(aes(worms_affect)) +
  geom_bar() +
  coord_flip() +
  labs(title = "If infected, can you affect others' health?", x = "")
```


```{r}
baseline.data %>% 
  select(neighbours_worms_affect) %>% 
  ggplot(aes(neighbours_worms_affect)) +
  geom_bar() +
  coord_flip() +
  labs(title = "Can you spread worms to others?", x = "")
```

```{r}
baseline.data %>% 
  select(few_deworm) %>% 
  ggplot(aes(few_deworm)) +
  geom_bar() +
  coord_flip() +
  labs(title = "Deworm if less than half of others deworm?", x = "")
```

```{r}
baseline.data %>% 
  select(many_deworm) %>% 
  ggplot(aes(many_deworm)) +
  geom_bar() +
  coord_flip() +
  labs(title = "Deworm if more than half of others deworm?", x = "")
```


```{r}
baseline.data %>% 
  select(more_less) %>% 
  ggplot(aes(more_less)) +
  geom_bar() +
  coord_flip() +
  labs(title = "Would you be more likely to deworm if few/many others get dewormed?", x = "")
```
## Social Image

I'm dropping information about the question group: _A-D_.

```{r}
baseline.data %>% 
  select(matches("^(praise|stigma)_[^_]+$")) %>% 
  gather(key = key, value = response) %>% 
  separate(key, c("praise.stigma", "topic"), "_") %>% 
  separate(topic, c("topic", "question.group"), -2) %>% 
  filter(!is.na(response)) %>% 
  ggplot(aes(response)) +
  geom_bar() +
  coord_flip() +
  facet_grid(topic ~ praise.stigma) +
  labs(title = "Praise and Stigma", y = "")
```

```{r, fig.width=10}
baseline.data %>% 
  select(matches("^(praise|stigma)_[^_]+_scale")) %>% 
  gather(key = key, value = response) %>% 
  separate(key, c("praise.stigma", "topic"), "_", extra = "merge") %>% 
  separate(topic, c("topic", "question.group"), "_scale") %>% 
  filter(!is.na(response)) %>% 
  ggplot(aes(response)) +
  geom_freqpoly(aes(y = ..density.., color = topic), binwidth = 1) +
  scale_x_continuous("Scale", breaks = 1:10) +
  scale_color_discrete("") +
  # facet_grid(topic ~ praise.stigma) +
  facet_wrap(~ praise.stigma) +
  labs(title = "Praise and Stigma Scale", y = "Density") +
  theme(legend.position = "bottom")
```

## Experience with Deworming

```{r, fig.width=10, fig.height=5}
baseline.data %>% 
  select(treated, family_treated) %>% 
  gather(key = who.treated) %>% 
  mutate(who.treated = if_else(who.treated == "treated", "self", "family")) %>% 
  ggplot(aes(value)) +
  geom_bar() +
  coord_flip() +
  facet_wrap(~ who.treated) +
  labs(title = "Ever been dewormed before?", x = "")
```
```{r}
baseline.data %>% 
  select(family_treated, who_treated) %>% 
  filter(family_treated == "yes") %>% 
  ggplot(aes(who_treated)) +
  geom_bar() +
  coord_flip() +
  labs(title = "Who in family got dewormed?", x = "")
```

```{r}
baseline.data %>% 
  select(treated, treated_when) %>% 
  filter(treated == "yes") %>% 
  ggplot(aes(treated_when)) +
  geom_bar() +
  coord_flip() +
  labs(title = "When did you last get dewormed?", x = "")
```

```{r, fig.width=10, fig.height=5}
baseline.data %>% 
  select(treated, family_treated, treated_where, where_family_treated) %>% 
  gather(key = who.treated, value = value, -c(treated, family_treated)) %>% 
  mutate(who.treated = if_else(who.treated == "treated_where", "self", "family")) %>% 
  filter((who.treated == "self" & treated == "yes") | (who.treated == "family" & family_treated == "yes")) %>% 
  ggplot(aes(value)) +
  geom_bar() +
  coord_flip() +
  facet_wrap(~ who.treated) +
  labs(title = "Where last get dewormed?", x = "")
```

## Beliefs

```{r}
baseline.data %>% 
  select(dworm_rate, ink_dworm_rate) %>% 
  gather(key = incentive) %>% 
  mutate(incentive = if_else(incentive == "dworm_rate", "none", "ink")) %>% 
  ggplot(aes(value)) +
  geom_freqpoly(aes(y = ..density.., color = incentive), binwidth = 1) +
  scale_x_continuous("Rate", breaks = 1:10) +
  scale_y_continuous("Density") +
  scale_color_discrete("") +
  theme(legend.position = "bottom") +
  labs(title = "How many out of 10 will come for deworming?")
```

```{r}
baseline.data %>% 
  select(dworm_proportion) %>% 
  ggplot(aes(dworm_proportion)) +
  geom_bar() + 
  labs(title = "How many will come for deworming?", x = "")
```

```{r}
baseline.data %>% 
  select(ink_more_less) %>% 
  ggplot(aes(ink_more_less)) +
  geom_bar() +
  coord_flip() +
  labs(title = "More/less will come with ink?", x = "")
```

# Reduced Form Analysis

Below is the main regression specification, where $m(\cdot)$ and $m_1(\cdot)\dots m_{K-1}(\cdot)$ define the causal effects to estimate. $l(\cdot)$ and $l_1(\cdot)\dots l_{K-1}(\cdot)$ define the regression intercepts.

$$
\begin{equation}
Y_{ij} = \left(m(Z_j, B_j;\theta) + l(B_j;\theta^c) + X_{ij} \cdot \beta \right) \cdot \frac{B_{j}(K)}{N(K)/N} + \sum_{k=1}^{K-1} \left(m_k(Z_j, B_j;\theta_k) + l_k(B_j;\theta^c_k) + X_{ij} \cdot \beta_k \right) \cdot \left( B_{j}(k) - B_{j}(K)\cdot\frac{N(k)}{N(K)} \right) + \varepsilon_{ij} 
\end{equation}
$$

* $i$ indexes individuals, $j$ clusters
* $Z_{j}(z) = \mathbf{1}\{Z_j = z\}$ is an indicator for whether cluster $j$ was assigned treatment $z$.
* $B_{j}(k) = \mathbf{1}\{B_j = k\}$ is an indicator for whether cluster $j$ is in stratum $k$.
* $X_{ij}$ is a vector of covariates
* $N(k)$ is the size of stratum $k$.
* $N$ is the total number of observations

To clarify what this stratified regression is doing, we are estimating
$$
\tau(z) = E[Y_{ij}(z) - Y_{ij}(control)] = \sum_{k = 1}^{K} \frac{N(k)}{N} E[Y_{ij}(z) - Y_{ij}(control)|B_j = k]
$$

## Basic Treatment Effect

Here we estimate the below models

$$
\begin{align}
m(Z_j, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} \tau(z) \cdot Z_{j}(z)  \\
m_k(Z_j, B_j; \theta_k) &= \sum_{z\in \mathcal{Z}\setminus\{control\}} \tau_k(z) \cdot Z_{j}(z) \\
l(B_j; \theta^c) &= \alpha \\
l_k(B_j; \theta^c_k) &= \alpha_k
\end{align}
$$
where $E[Y_{ij}(z) - Y_{ij}(control)] = \tau(z)$ and $E[Y_{ij}(control)] = \alpha$.

### Regression Without Controls

Without controls (using cluster robust standard errors). ~~Also including block bootstrapped standard errors and p-values.~~

```{r, warning=FALSE}
reg.output.sms.ctrl <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control", !baseline.sample) %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment, .strat.by = c("county", "dist.pot.group"), .cluster = "cluster.id")
    
reg.output.sms.ctrl.calendar <- analysis.data %>%
  filter(monitored, monitor.consent, sms.treatment == "sms.control", !baseline.sample) %>%
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>%
  mutate( assigned.treatment = relevel(assigned.treatment, ref = "calendar")) %>%
  run.strat.reg(dewormed.any ~ assigned.treatment, .strat.by = c("county", "dist.pot.group"), .cluster = "cluster.id")

kable(tidy(reg.output.sms.ctrl), digits = 4)
```

With _calendar_ as the omitted category, to estimate $E[Y_{ij}(bracelet) - Y_{ij}(calendar)] = \tau(bracelet) - \tau(calendar)$:

```{r}
reg.output.sms.ctrl.calendar %>% 
  tidy %>% 
  filter(term %in% c("(intercept)", "bracelet")) %>% 
  kable(digits = 4)
```

```{r, fig.width=10}
prep.sms.ctrl.plot.data(reg.output.sms.ctrl) %>% {
  plot.sms.ctrl.takeup(.) +
    labs(subtitle = "Without control")
}
```

```{r}
neyman.results <- analysis.data %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  analyze.neyman.blk.bs(0) %>% 
  # analyze.neyman.blk.bs(2000) %>% 
  mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet")))  
```

```{r}
# neyman.results %>% 
#   unnest(treatment.data) %>%
#   filter(rhs.treatment.group == "control" | (treatment.group == "bracelet" & rhs.treatment.group == "calendar")) %>% 
#   select(treatment.group, rhs.treatment.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
#   kable(digits = 4)
```

Stratum-level deworming probability

```{r}
neyman.results %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, treatment.group, stratum.assign.mean.dewormed) %>% 
  spread(treatment.group, stratum.assign.mean.dewormed) %>% 
  kable(digits = 4)
```

```{r}
neyman.results %>% 
  unnest(treatment.data) %>% 
  distinct(treatment.group, .keep_all = TRUE) %>% 
  ggplot() +
    geom_col(aes(treatment.group, treatment.mean.dewormed), alpha = 0.5, color = "black") +
    scale_x_discrete("Treatment") +
    scale_y_continuous("Proportion Dewormed", breaks = seq(0, 0.6, 0.05))
```

```{r}
neyman.results %>% 
  unnest(strata.data) %>% 
  ggplot(aes(factor(treatment.group))) +
  geom_col(aes(y = stratum.assign.mean.dewormed), color = "black", alpha = 0.5) +
  scale_x_discrete("") +
  scale_y_continuous("Take-up Proportion") +
  facet_grid(county ~ dist.pot.group)
```

Strata sizes:

```{r}
neyman.results %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, treatment.group, stratum.assign.size) %>% 
  spread(treatment.group, stratum.assign.size) %>% 
  kable()
```

### Regression With Controls

These are the regressors we are controlling for:
```{r covariates}
reg.covar 
```

```{r}
reg.output.sms.ctrl.covar <- analysis.data %>%  
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control", !baseline.sample) %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment, .strat.by = c("county", "dist.pot.group"), .cluster = "cluster.id", .covariates = reg.covar)

reg.output.sms.ctrl.calendar.covar <- analysis.data %>%  
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control", !baseline.sample) %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate( assigned.treatment = relevel(assigned.treatment, ref = "calendar")) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment, .strat.by = c("county", "dist.pot.group"), .cluster = "cluster.id", .covariates = reg.covar)

kable(tidy(reg.output.sms.ctrl.covar), digits = 4)
```

```{r, echo=FALSE}
reg.output.sms.ctrl.calendar.covar %>% 
  tidy %>% 
  filter(term %in% c("(intercept)", "bracelet")) %>% 
  kable(digits = 4)
```

```{r, fig.width=10}
prep.sms.ctrl.plot.data(reg.output.sms.ctrl.covar) %>% {
  plot.sms.ctrl.takeup(.) +
    labs(subtitle = "With control")
}
```

## Phone Ownership

### Regression Without Controls

```{r, echo=FALSE}
reg.output.nonphone <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control", !baseline.sample) %>% #, sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment * sms.ctrl.subpop, .strat.by = c("county", "dist.pot.group"), .cluster = "cluster.id")

kable(tidy(reg.output.nonphone), digits = 4)
```

Testing the joint hypothesis of difference in impact between phone and non-phone owners:
```{r}
linear.tester(reg.output.nonphone, c("ink:phone.owner", "calendar:phone.owner", "bracelet:phone.owner"), joint = TRUE) %>% 
  tidy %>% 
  kable(digits = 4)
```

```{r, fig.width=12}
prep.sms.ctrl.plot.data(reg.output.nonphone, .interact.with = "phone.owner") %>% 
  mutate(grp = factor(grp, levels = c("ref.grp", "compare.grp"), labels = c("Non Phone Owners", "Phone Owners"))) %>% {
  plot.sms.ctrl.takeup(., .facet.formula = grp ~ ref.treatment) +
    labs(subtitle = "Without controls") 
}
```

### Regression With Controls

```{r}
reg.output.nonphone.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control", !baseline.sample) %>% #, sms.ctrl.subpop == "non.phone.owner") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment * sms.ctrl.subpop, .strat.by = c("county", "dist.pot.group"), .cluster = "cluster.id", .covariates = setdiff(reg.covar, "sms.ctrl.subpop"))

kable(tidy(reg.output.nonphone.covar), digits = 4)
```

Testing the joint hypothesis of difference in impact between phone and non-phone owners:
```{r}
linear.tester(reg.output.nonphone.covar, c("ink:phone.owner", "calendar:phone.owner", "bracelet:phone.owner"), joint = TRUE) %>% 
  tidy %>% 
  kable(digits = 4)
```

```{r, fig.width=12}
prep.sms.ctrl.plot.data(reg.output.nonphone.covar, .interact.with = "phone.owner") %>% 
  mutate(grp = factor(grp, levels = c("ref.grp", "compare.grp"), labels = c("Non Phone Owners", "Phone Owners"))) %>% {
  plot.sms.ctrl.takeup(., .facet.formula = grp ~ ref.treatment) +
    labs(subtitle = "With controls") 
}
```

```{r}
# neyman.results.no.phone <- analysis.data %>% 
#   filter(monitored, monitor.consent, sms.treatment == "sms.control", sms.ctrl.subpop == "non.phone.owner") %>% 
#   anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
#   analyze.neyman.blk.bs(0) %>% 
#   mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet")))  
```

```{r}
# neyman.results.no.phone %>% 
#   unnest(treatment.data) %>%
#   filter(rhs.treatment.group == "control") %>% 
#   select(treatment.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
#   kable(digits = 4)
```

## Treatment Effect Heterogeneity by Distance to PoT

Here we estimate the below models

$$
\begin{align}
m(Z_j, D_j, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} Z_{j}(z) \cdot \left\{\tau(z) + \lambda(z) \cdot D_j \right\} + \delta \cdot D_j  \\
m_k(Z_j, D_j, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}}Z_{j}(z)  \cdot \left\{\tau_k(z) + \lambda_k(z) \cdot  D_j \right\} + \delta_k \cdot D_j 
\end{align}
$$

where $D_j$ is an indicator for whether cluster $j$ is in the _far_ group. The average treatment estimated here is
$$
E[Y_{ij}(z) - Y_{ij}(control) | D_j = d] = \tau(z) + \lambda(z)\cdot d 
$$

### Regression Without Controls

```{r}
reg.output.sms.ctrl.dist <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control", !baseline.sample) %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment * dist.pot.group, .strat.by = "county", .cluster = "cluster.id")

kable(tidy(reg.output.sms.ctrl.dist), digits = 4)
```

The below test the null hypotheses of no effect of incentives in the _far_ strata, $E[\tau(z) - \tau(control)| D_j = 1]$. 
```{r}
c("ink", "calendar", "bracelet") %>% 
  map(~ paste0(., c("", ":far"))) %>%
  map(~ paste(., collapse = " + ")) %>% 
  linear.tester(reg.output.sms.ctrl.dist, .) %>% 
  kable(digits = 4)
```

The below test the null hypotheses of no interaction between distance and incentives, $E[\tau(z)|D_j = 1] - E[\tau(z)| D_j = 0]$. Since distance was exogenous assigned to clusters this can also be stated as $E[\tilde{\tau}(z, 1) - \tilde{\tau}(z, 0)]$. 
```{r}
c("ink", "calendar", "bracelet") %>% 
  map(~ c(paste0(., ":far"), "far")) %>%
  map(~ paste(., collapse = " + ")) %>% 
  linear.tester(reg.output.sms.ctrl.dist, .) %>% 
  kable(digits = 4)
```

```{r, fig.width=12}
prep.sms.ctrl.plot.data(reg.output.sms.ctrl.dist, .interact.with = "far") %>% 
  mutate(grp = factor(grp, levels = c("ref.grp", "compare.grp"), labels = c("Close", "Far"))) %>% {
  plot.sms.ctrl.takeup(., .facet.formula = grp ~ ref.treatment) +
    labs(subtitle = "Without controls") 
}
```

<!-- Below is the corresponding estimation using Neyman's approach: -->

```{r}
neyman.results.dist <- analysis.data %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  analyze.neyman.blk.bs(0, .interact.with = "dist.pot.group") %>% 
  mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet"))) 
```


Stratum-level deworming probability:

```{r}
neyman.results.dist %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, treatment.group, stratum.assign.mean.dewormed) %>% 
  unite(incentive_dist, treatment.group, dist.pot.group) %>% 
  spread(incentive_dist, stratum.assign.mean.dewormed) %>% 
  kable(digits = 4)
```

```{r}
neyman.results.dist %>% 
  unnest(treatment.data) %>% 
  distinct(treatment.group, dist.pot.group, .keep_all = TRUE) %>% 
  ggplot(.) +
  geom_col(aes(treatment.group, treatment.mean.dewormed, fill = dist.pot.group), alpha = 0.5, color = "black", position = "dodge") +
  scale_x_discrete("Treatment") +
  scale_y_continuous("Proportion Dewormed", breaks = seq(0, 0.6, 0.05)) +
  scale_fill_discrete("Distance to PoT")
```

Strata sizes:

```{r}
neyman.results %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, treatment.group, stratum.assign.size) %>% 
  unite(incentive_dist, treatment.group, dist.pot.group) %>% 
  spread(incentive_dist, stratum.assign.size) %>% 
  kable()
```

### Regression With Controls

```{r}
reg.output.sms.ctrl.dist.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control", !baseline.sample) %>% 
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment * dist.pot.group, .strat.by = "county", .cluster = "cluster.id", .covariates = reg.covar)

kable(tidy(reg.output.sms.ctrl.dist.covar), digits = 4)
```

```{r, fig.width=12}
prep.sms.ctrl.plot.data(reg.output.sms.ctrl.dist.covar, .interact.with = "far") %>% 
  mutate(grp = factor(grp, levels = c("ref.grp", "compare.grp"), labels = c("Close", "Far"))) %>% {
  plot.sms.ctrl.takeup(., .facet.formula = grp ~ ref.treatment) +
    labs(subtitle = "With controls") 
}
```

## SMS Treatment

Here we estimate the below models

$$
\begin{align}
m(Z_j, M_{ij}, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}}Z_{j}(z) \cdot \left\{\tau(z) + \sum_{s \in \mathcal{M}\setminus \{none\}} \gamma(z, s) \cdot M_{ij}(s) \right\} + \sum_{s\in\mathcal{M}\setminus \{none\}} \psi(s) \cdot M_{ij}(s)  \\
m_k(Z_j, M_{ij}, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} Z_{j}(z) \cdot \left\{\tau_k(z) + \sum_{s \in \mathcal{M}\setminus \{none\}} \gamma_k(z, s)\cdot M_{ij}(s) \right\} + \sum_{s\in\mathcal{M}\setminus \{none\}} \psi_k(s) \cdot M_{ij}(s)  
\end{align}
$$
where $M_{ij}(s)$ is an indicator of whether individual $i$ received SMS treatment $s$.

The average treatment estimated here is
$$
E[Y_{ij}(z, s) - Y_{ij}(z', s')] = \tau(z) - \tau(z') + \gamma(z, s) - \gamma(z', s') + \psi(s) - \psi(s'),
$$
where 

* $\tau(control) = \psi(none) = 0$ 
* $z = control \lor s = none \implies \gamma(z, s) = 0$

The following table simplifies thinking about the analysis outlined in the pre-analysis plan:

|                             | Control  | Ink | Calendar | Bracelet |
|-----------------------------|:--------:|:---:|:--------:|:--------:|
| No SMS                      | 1        | 4   | 6        | 8        |
| Reminder SMS                | 2        | --- | ---      | ---      |
| Reminder  + Peer Info SMS   | 3        | 5   | 7        | 9        |

:Cluster-level Treatment Arms\label{tab:cluster-level-treatment}

### Regression Without Controls

```{r}
reg.output.sms.treat <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner", !baseline.sample) %>% 
  anti_join(outlier.clusters, "cluster.id") %>% 
  mutate(sms.treatment = factor(sms.treatment, levels = c("sms.control", "reminder.only", "social.info"))) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment * sms.treatment, .strat.by = c("county", "dist.pot.group"), .cluster = "cluster.id")

reg.output.sms.treat %>% tidy %>% kable(digits = 4)
```

Some linear hypotheses testing:
```{r}
c("ink", "calendar", "bracelet") %>% 
                  map(~ c(paste0(., ":social.info"), "social.info")) %>% 
                  map(~ paste(., collapse = " + ")) %>% 
                  c("bracelet - calendar",
                    "ink - social.info", 
                    "bracelet - calendar - calendar:social.info - social.info",
                    "ink + ink:social.info", 
                    "bracelet - calendar + bracelet:social.info - calendar:social.info") %>% 
  linear.tester(reg.output.sms.treat, .) %>% 
  kable(digits = 4)
```

```{r}
neyman.results.sms <- analysis.data %>% 
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>% 
  anti_join(outlier.clusters, "cluster.id") %>% 
  analyze.neyman.blk.bs(0, .treatment = c("assigned.treatment", "sms.treatment")) %>% 
  separate(treatment.group, c("assigned.treatment", "sms.treatment"), sep = "_") %>% 
  mutate(assigned.treatment = factor(assigned.treatment, levels = c("control", "ink", "calendar", "bracelet")))  
```

```{r}
# neyman.results.sms %>% 
#   unnest(treatment.data) %>% 
#   filter(str_detect(rhs.treatment.group, paste0("^", assigned.treatment)) | 
#            (assigned.treatment == "ink" & str_detect(rhs.treatment.group, "^control")) |
#            (assigned.treatment == "bracelet" & str_detect(rhs.treatment.group, "^calendar"))) %>% 
#          # sms.treatment != "sms.control") %>% 
#   select(assigned.treatment, sms.treatment, rhs.treatment.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
#   kable
```

```{r, fig.height=6}
prep.sms.treat.plot.data(reg.output.sms.treat) %>% { 
  plot.sms.treat.takeup(.) +
    labs(subtitle = "Without Controls") 
}
```


```{r, echo=FALSE, fig.align="center"}
# neyman.results.sms %>% 
#   unnest(strata.data) %>% 
#   select(assigned.treatment, sms.treatment, county, dist.pot.group, treatment.mean.dewormed) %>% 
#   distinct(assigned.treatment, sms.treatment, .keep_all = TRUE) %>% 
#   mutate(sms.treatment = factor(sms.treatment, 
#                                 levels = c("sms.control", "reminder.only", "social.info"),
#                                 labels = c("None", "Reminder Only", "Social Information")),
#          assigned.treatment = factor(str_to_title(assigned.treatment))) %>% 
#   ggplot(aes(sms.treatment, treatment.mean.dewormed)) +
#   geom_point(aes(color = assigned.treatment, group = assigned.treatment)) +
#   geom_line(aes(color = assigned.treatment, group = assigned.treatment, linetype = "Including Reminder-Only"), 
#             data = . %>% filter(assigned.treatment == "Control")) +
#   geom_line(aes(color = assigned.treatment, group = assigned.treatment, linetype = "Excluding Reminder-Only"), 
#             data = . %>% filter(sms.treatment != "Reminder Only")) +
#   scale_x_discrete("Text Messaging Treatment") +
#   scale_y_continuous("Take-up Proportion", breaks = seq(0, 0.7, 0.025)) +
#   scale_color_discrete("Incentive Treatment") +
#   scale_linetype_manual("", values = c("solid", "dashed"))
```

Stratum-level deworming probability:

```{r}
neyman.results.sms %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, assigned.treatment, sms.treatment, stratum.assign.mean.dewormed) %>% 
  unite(incentive_sms, assigned.treatment, sms.treatment) %>% 
  spread(incentive_sms, stratum.assign.mean.dewormed) %>% 
  kable(digits = 4)
```

Strata sizes:

```{r}
neyman.results %>% 
  unnest(strata.data) %>% 
  select(county, dist.pot.group, treatment.group, stratum.assign.size) %>% 
  spread(treatment.group, stratum.assign.size) %>% 
  kable()
```

### Regression With Controls

```{r, echo=TRUE}
reg.output.sms.treat.covar <- analysis.data %>%  
  mutate_at(vars(school, floor, ethnicity), funs(factor(ifelse(. >= 97, NA, .)))) %>% 
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner", !baseline.sample) %>% 
  anti_join(outlier.clusters, "cluster.id") %>% 
  mutate(sms.treatment = factor(sms.treatment, levels = c("sms.control", "reminder.only", "social.info"))) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment * sms.treatment, .strat.by = c("county", "dist.pot.group"), .cluster = "cluster.id", .covariates = setdiff(reg.covar, "sms.ctrl.subpop"))

reg.output.sms.treat.covar %>% tidy %>% kable(digits = 4)
```

Some linear hypotheses testing:
```{r}
c("ink", "calendar", "bracelet") %>% 
  map(~ c(paste0(., ":social.info"), "social.info")) %>% 
  map(~ paste(., collapse = " + ")) %>% 
  c("bracelet - calendar",
    "ink - social.info", 
    "bracelet - calendar - calendar:social.info - social.info",
    "ink + ink:social.info", 
    "bracelet - calendar + bracelet:social.info - calendar:social.info",
    "calendar:social.info - ink:social.info",
    "bracelet:social.info - calendar:social.info") %>% 
  linear.tester(reg.output.sms.treat.covar, .) %>% 
  kable(digits = 4)
```

```{r, fig.height=6}
prep.sms.treat.plot.data(reg.output.sms.treat.covar) %>% {
  plot.sms.treat.takeup(.) +
    labs(subtitle = "With Controls") 
} 
```

## Over Time

```{r, echo=TRUE}
after.msg.days <- seq(3, 11, 2)

time.takeup.data <- analysis.data %>%  
  filter(monitored, monitor.consent, !baseline.sample) %>% 
  anti_join(outlier.clusters, "cluster.id") %>% 
  group_by(assigned.treatment, sms.treatment) %>% 
  mutate(n.total = n()) %>% 
  group_by(dewormed.day.any, add = TRUE) %>% 
  summarize(takeup.prop = sum(dewormed.any) / first(n.total)) %>% 
  ungroup %>% 
  arrange(assigned.treatment, dewormed.day.any) %>% 
  group_by(assigned.treatment, sms.treatment) %>% 
  mutate(cumul.takeup.prop = cumsum(takeup.prop)) %>% 
  ungroup 
```

```{r, fig.width=10}
time.takeup.data %>% 
  filter(sms.treatment == "sms.control") %>% {
    plot.takeup.dynamics(.) +
      labs(y = "Take-up Proportion", title = "Daily Take-up Proportions", subtitle = "No SMS treatment group")
  }
```


```{r, echo=TRUE, fig.width=14}
time.takeup.data %>% { 
  plot.takeup.dynamics(., .aes = aes(dewormed.day.any, takeup.prop, color = assigned.treatment, linetype = sms.treatment)) +
    scale_linetype_manual("", values = c("dotted", "solid", "dashed")) +
    labs(y = "Take-up Proportion", title = "Daily Take-up Proportions", subtitle = "Split by SMS treatment assignment") +
    facet_wrap(~ assigned.treatment, scales = "free_y")
}
```

```{r, fig.width=10, echo=TRUE}
social.info.data <- sms.content.data %>% 
  filter(!is.na(social.info)) %>% 
  left_join(select(census.data, cluster.id, assigned.treatment, sms.treatment, KEY.individ), "KEY.individ") %>% 
  filter(!is.na(cluster.id)) %>% 
  group_by(deworming.day, assigned.treatment) %>% 
  summarize(cumul = mean(social.info)/10) %>% 
  ungroup %>% 
  rename(dewormed.day = deworming.day) 

social.info.data %>% {
  plot.takeup.dynamics(., .aes = aes(dewormed.day, cumul, color = assigned.treatment, shape = "social.info")) +
    labs(y = "Reported Take-up", title = "Social Information Reported to Subjects", subtitle = "Split by incentive treatment") +
    scale_shape_manual(values = 1, guide = "none")
}
```

```{r, fig.width=14, echo=TRUE}
time.takeup.data %>% 
  transmute(dewormed.day = dewormed.day.any, cumul = cumul.takeup.prop, assigned.treatment, sms.treatment) %>% 
  bind_rows(takeup = ., social.info = social.info.data, .id = "cumul.type") %>% 
  mutate(cumul.type.sms = if_else(!is.na(sms.treatment), paste(cumul.type, sms.treatment, sep = "-"), cumul.type)) %>% {
    plot.takeup.dynamics(., .aes = aes(dewormed.day, cumul, color = assigned.treatment, linetype = cumul.type.sms, shape = cumul.type)) +
      scale_linetype_manual("", labels = c("Reported Take-up", "Reminders Only", "No SMS", "Social Info SMS"), values = c("dotdash", "dotted", "solid", "dashed")) +
      scale_shape_manual("", labels = c("Reported Take-up", "Take-up"), values = c(1, 16)) +
      labs(y = "", title = "Comparing Reported and Observed Take-up", subtitle = "Split by SMS treatment group") +
      facet_wrap(~ assigned.treatment)
}
```

## SMS Treatment And Distance to PoT

Here we estimate the below models

$$
\begin{align}
m(Z_j, M_{ij}, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} Z_{j}(z) \cdot \left\{\tau(z) + \lambda(z) \cdot D_j + \sum_{s \in \mathcal{M}\setminus \{none\}} M_{ij}(s) \cdot \left[ \gamma(z, s) + \rho(z, s) \cdot D_j \right] \right\} \\
&+ \sum_{s\in\mathcal{M}\setminus \{none\}}  M_{ij}(s) \left\{\psi(s) + \pi(s) \cdot D_j \right\}  + \delta \cdot D_j  \\
m_k(Z_j, M_{ij}, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} Z_{j}(z) \cdot \left\{\tau_k(z) + \lambda_k(z) \cdot D_j + \sum_{s \in \mathcal{M}\setminus \{none\}} M_{ij}(s) \cdot \left[ \gamma_k(z, s) + \rho_k(z, s) \cdot D_j \right] \right\} \\ 
&+ \sum_{s\in\mathcal{M}\setminus \{none\}}  M_{ij}(s) \left\{\psi_k(s) + \pi_k(s) \cdot D_j \right\}  + \delta_k \cdot D_j  \\
\end{align}
$$

$$
\begin{align}
E[Y_{ij}(z, s) - Y_{ij}(z', s')|D_j = d] &= \tau(z) - \tau(z') + \left\{\lambda(z) - \lambda(z')\right\} \cdot d + \left\{\rho(z,s) - \rho(z', s')\right\} \cdot d + \gamma(z, s) - \gamma(z', s') \\
&+ \psi(s) - \psi(s') + \left\{\pi(s) - \pi(s')\right\}\cdot d,
\end{align}
$$

### Regression Without Controls

```{r}
reg.output.sms.treat.dist <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner", !baseline.sample) %>% 
  anti_join(outlier.clusters, "cluster.id") %>% 
  mutate(sms.treatment = factor(sms.treatment, levels = c("sms.control", "reminder.only", "social.info")),
         dist.pot.group = relevel(dist.pot.group, ref = "far")) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment * sms.treatment * dist.pot.group, .strat.by = "county", .cluster = "cluster.id")

reg.output.sms.treat.dist %>% tidy %>% kable(digits = 4)
```

```{r}
prep.sms.treat.dist.plot.data <- function(.reg.output) {
  interact.with <- "close"
  
  incentive.treatment.terms <- c("control", "ink", "calendar", "bracelet")
  sms.treatment.interact.terms <- sprintf("%s:social.info", incentive.treatment.terms[-1])
  
  sms.ctrl.linear.restrict <- c("(intercept)", sprintf("(intercept) + %s", incentive.treatment.terms[-1])) 
  social.info.add.effect.restrict <- c("social.info", sprintf("social.info + %s:social.info", incentive.treatment.terms[-1]))
  reminder.only.add.effect.restrict <- c("reminder.only - social.info")
   
  col.inference <- c(social.info.add.effect.restrict, reminder.only.add.effect.restrict) %>% 
    c(map(., str_split, "\\s+", simplify = TRUE) %>% 
        map(~ c(.x, "+", str_replace(.x, "([^-+]+)", sprintf("\\1:%s", interact.with)))) %>% 
        map(paste, collapse = " ") %>% 
        map_if(~ !str_detect(.x, "-"), ~ paste(.x, sprintf("+ %s", interact.with))) %>% 
        unlist) %>% 
    c(sms.ctrl.linear.restrict %>% 
        c(str_replace(., "\\(intercept\\)", interact.with)), .) %>% 
    linear.tester(.reg.output, .) %>% 
    mutate(dist = rep(rep(c("Far", "Close"), 2), c(4, 4, 5, 5))) %>% 
    group_by(dist) %>% 
    mutate(incentive.treatment = incentive.treatment.terms %>% 
             factor(c(rep(., 2), "control"), levels = ., labels = str_to_title(.)),
           sms.treatment = c(rep(c("sms.control", "social.info"), each = 4), "reminder.only") %>% 
             factor(levels = c("sms.control", "social.info", "reminder.only"), 
                    labels = c("None", "Social Information", "Reminders Only")),
           bar.size = estimate + if_else(sms.treatment == "None", 0, c(rep(estimate[1:4], 2), first(estimate) + estimate[5]))) %>% 
    ungroup %>% 
    mutate(ci.lb = bar.size - std.error * 1.64,
           ci.ub = bar.size + std.error * 1.64) 
}
```

```{r, fig.width=12}
prep.sms.treat.dist.plot.data(reg.output.sms.treat.dist) %>% {
  plot.sms.treat.takeup(.) +
    facet_wrap(~ dist) +
    labs(subtitle = "Split by distance to PoT, without controls")
}
```

### Regression With Controls

```{r}
reg.output.sms.treat.dist.covar <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner", !baseline.sample) %>% 
  anti_join(outlier.clusters, "cluster.id") %>% 
  mutate(sms.treatment = factor(sms.treatment, levels = c("sms.control", "reminder.only", "social.info")),
         dist.pot.group = relevel(dist.pot.group, ref = "far")) %>% 
  run.strat.reg(dewormed.any ~ assigned.treatment * sms.treatment * dist.pot.group, .strat.by = "county", .cluster = "cluster.id", .covariates = setdiff(reg.covar, "sms.ctrl.subpop"))

reg.output.sms.treat.dist.covar %>% tidy %>% kable(digits = 4)
```

```{r, fig.width=12}
prep.sms.treat.dist.plot.data(reg.output.sms.treat.dist.covar) %>% {
  plot.sms.treat.takeup(.) +
    facet_wrap(~ dist) +
    labs(subtitle = "Split by distance to PoT, with controls")
}
```

## Impact of Surveying

Test if there is a difference in impact in response to surveying. We do this by comparing take-up rates for those receiving a baseline sample and those not. 

```{r, echo=2}
reg.output.sms.ctrl.survey.effect <- analysis.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  anti_join(outlier.clusters, c("cluster.id", "sms.treatment")) %>% 
  mutate(baseline.sample = factor(if_else(baseline.sample, "baseline", "not.baseline")) %>% 
           relevel(ref = "not.baseline"),
         sms.ctrl.subpop = relevel(factor(sms.ctrl.subpop), ref = "phone.owner")) %>% 
  run.strat.reg(dewormed.any ~ baseline.sample * assigned.treatment, 
                .strat.by = c("county", "dist.pot.group"), 
                .cluster = "cluster.id",
                .covariates = setdiff(reg.covar, "sms.ctrl.subpop"))
```

```{r}
reg.output.sms.ctrl.survey.effect %>% 
  tidy %>% 
  kable(digits = 4)
```

```{r}
linear.tester(reg.output.sms.ctrl.survey.effect,
              paste0("baseline + baseline:", c("ink", "calendar", "bracelet"))) %>% 
  kable 
```
```{r}
linear.tester(reg.output.sms.ctrl.survey.effect,
              c("baseline", paste0("baseline + baseline:", c("ink", "calendar", "bracelet"))), joint = TRUE) %>% 
  tidy %>% 
  kable(digits = 4) 
```

<!-- *The below requires looking at the take-up rates for individuals not providing consent to use their data*. -->

```{r}
# reg.output.sms.ctrl.survey.effect.no.consent <- analysis.data %>%  
#   filter(baseline.sample | (monitored & monitor.consent & sms.treatment == "sms.control")) %>% 
#   anti_join(outlier.clusters, c("sms.treatment", "cluster.id")) %>% 
#   mutate(baseline.sample = factor(if_else(baseline.sample, "baseline", "not.baseline")) %>% relevel(ref = "not.baseline")) %>% 
#   run.strat.reg(dewormed.any ~ assigned.treatment * baseline.sample * sms.ctrl.subpop, .strat.by = c("county", "dist.pot.group"), .cluster = "cluster.id")
# 
# reg.output.sms.ctrl.survey.effect.no.consent %>% 
#   tidy %>% 
#   kable(digits = 4)
```

```{r}
# linear.tester(reg.output.sms.ctrl.survey.effect.no.consent, 
#               paste0(c("", "baseline + ink:", "baseline + calendar:", "baseline + bracelet:"), "baseline"), 
#               joint = TRUE) %>% 
#   tidy %>% 
#   kable
```

