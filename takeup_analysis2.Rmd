---
title: "TakeUp Analysis Notebook"
output:
  html_notebook:
    code_folding: hide
    fig_caption: yes
    fig_width: 8
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: no
header-includes:
   - \usepackage{bbm}
date: "`r format(Sys.time(), '%B %d, %Y')`"
---

```{r setup, include=FALSE}
library(plyr)
library(dplyr)
library(multidplyr)
library(tibble)
library(tidyr)
library(lubridate)
library(purrr)
library(readr)
library(haven)
library(lmtest)
library(car)
library(broom)
library(ggplot2)
library(viridis)
library(ggrepel)
library(ggmap)
library(stringr)
library(knitr)

source("../util.R")
source("takeup_rct_assign_clusters.R")

knitr::opts_chunk$set(cache = TRUE, echo = FALSE, fig.width = 8, fig.height = 5)

config <- yaml::yaml.load_file("../local_config.yaml")

doParallel::registerDoParallel(cores = config$cores)

wgs.84 <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
kenya.proj4 <- "+proj=utm +zone=36 +south +ellps=clrk80 +units=m +no_defs"

options(#contrasts=c("contr.Treatment", getOption("contrasts")[2]), 
        dplyr.show_progress = FALSE)
#         digits = 4) 
```

```{r load-data}
load("data/takeup_census.RData")
load("data/takeup_at_pot.RData")
load("data/takeup_matched_population.RData")
```

```{r regression-code, include=FALSE}
calc.strat.interaction.terms <- function(.data, 
                                         .treatment = "assigned.treatment", 
                                         .strat.by = setdiff(c("county", "dist.pot.group"), .treatment), 
                                         interact.formula = as.formula(sprintf("~ %s", paste(.treatment, collapse = "*")))) {
  strata.info <- .data %>% 
    group_by_(.dots = .strat.by) %>% 
    summarize(stratum.size = n()) %>% 
    ungroup %>% 
    mutate(last.stratum = row_number() == n(),
           last.stratum.size = last(stratum.size),
           total.size = sum(stratum.size))
  
  strata.info$stratum <- strata.info[, .strat.by] %>% 
    do.call(function(...) paste(..., sep = "."), .)
  
  .data %<>% 
    left_join(strata.info, .strat.by)
  
  interact.formula %<>% 
    update.formula(~ . * stratum - .)
  
  .data %>% { 
    bind_cols(select(., KEY.individ, last.stratum.size, total.size, stratum), 
              as_tibble(model.matrix(interact.formula, .)) %>% select(dplyr::matches("^stratum.+:"))) 
  } %>% 
    gather(interact.param, interact.coef, -c(KEY.individ, last.stratum.size, total.size, stratum)) %>% 
    group_by(interact.param) %>% 
    filter(any(interact.coef > 0)) %>% 
    ungroup %>% 
    separate(interact.param, c("interact.stratum", "interact.assign"), 
             sep = sprintf("(?<=stratum(%s)):", paste(unique(.$stratum), collapse = "|"))) %>% 
    mutate_at(vars(interact.stratum, interact.assign), 
              funs(str_replace_all(., c(":" = "_", stratum = "", setNames(rep("", length(.treatment)), .treatment))))) %>% 
    left_join(select(strata.info, stratum, stratum.size, last.stratum), c("interact.stratum" = "stratum")) %>% 
    mutate(interact.coef = interact.coef * if_else(last.stratum, 1/stratum.size, 1),
           interact.term.key = paste(interact.assign, interact.stratum, sep = "_")) %>% 
    group_by(KEY.individ, interact.assign) %>% 
    do({
      last.stratum.coef <- filter(., last.stratum) %$% interact.coef 
      
      mutate(., 
           interact.coef = interact.coef - ifelse(last.stratum, 0, last.stratum.coef * stratum.size))
    }) %>% 
    ungroup %>% 
    mutate(interact.coef = interact.coef * ifelse(last.stratum, total.size, 1)) %>% 
    select(KEY.individ, matches("^interact\\.(term|coef)"), stratum) %>% 
    spread(interact.term.key, interact.coef) %>% 
    left_join(strata.info, "stratum")
}

run.strat.reg <- function(.data, 
                          lhs.var = "dewormed.any",
                          indicator.regex = "_(Busia|Siaya|Kakamega)",
                          .covariates = NULL,
                          .linear.hypo = list()) {
  indicator.formula.str <- paste(sprintf("%s", grep(indicator.regex, names(.data), value = TRUE)), collapse = " + ")
  
  reg.formula <- as.formula(sprintf("%s ~ stratum - 1 + %s %s", 
                                    lhs.var,
                                    indicator.formula.str,
                                    if (is.null(.covariates)) "" else paste(c("", .covariates), collapse = " + ")))
  
  last.stratum <- .data %>% filter(last.stratum) %$% stratum %>% unique
  
  reg.res <- .data %>% 
    lm(reg.formula, data = .) 
  
  robust.vcov <- vcov.clx(reg.res, .data$cluster.id)
  
  reg.summary <- reg.res %>% 
    coeftest(vcov. = robust.vcov) %>% 
    tidy %>% 
    filter(str_detect(term, sprintf("_%s$", last.stratum))) %>% 
    mutate(term = str_replace_all(term, setNames(c(" ", ""), c("_", first(last.stratum))))) 
  
  test.linear.hypo <- function(linear.hypo) {
    paste(linear.hypo, last.stratum, sep = "_") %>% {
      est <- coef(reg.res)[.] %>% sum
      
      paste(., collapse = " + ") %>% 
        lht(reg.res, ., vcov. = robust.vcov) %>% 
        tidy %>% 
        mutate(linear.hypo = paste(linear.hypo, collapse = " + "),
               estimate = est)
    }
  }
  
  linear.tests <- map_df(.linear.hypo, test.linear.hypo) %>% 
    filter(!is.na(statistic))
  
  lst(reg.summary = reg.summary, reg.res = reg.res, vcov = robust.vcov, linear.tests = linear.tests)
}
```

```{r neyman-code, include=FALSE}
nest_exclude <- function(data, key_col, exclude_nest_cols = character()) {
  dplyr::select_vars(colnames(data), everything()) %>% 
    unname %>% 
    dplyr::setdiff(exclude_nest_cols) %>% 
    nest_(data, key_col = key_col, nest_cols = .)
}

calc.strata.stats <- function(.data, 
                              .treatment = c("assigned.treatment"), 
                              .strat.by = c("county", "dist.pot.group"), # This is what we stratified the experiment by
                              .interact.with = NULL) {
  calc.stratum.ate <- function(.stratum.data) {
    make.cross.assign.tibble <- function(.col) {
      matrix(.col, 
             nrow = length(.col), 
             ncol = length(.col), 
             dimnames = list(.stratum.data$treatment.group)) %>% 
        t %>% as_tibble %>% 
        mutate(lhs.treatment.group = .stratum.data$treatment.group) %>% 
        gather(rhs.treatment.group, val, -lhs.treatment.group) 
    }
   
    .stratum.data %>% {
      generated.cross.tbl <- select(., 
                                    stratum.assign.mean.dewormed, 
                                    stratum.assign.size, 
                                    stratum.assign.sample.var.dewormed) %>% 
        map2(paste0("stratum.", c("ate", "size", "sample.var")), 
             ~ make.cross.assign.tibble(.x) %>% 
               set_names(str_replace(names(.), fixed("val"), fixed(.y)))) %>% 
        reduce(function(.left, .right) left_join(.left, .right, c("lhs.treatment.group", "rhs.treatment.group")))
        
      left_join(., generated.cross.tbl, c("treatment.group" = "lhs.treatment.group")) 
    } %>% 
      filter(treatment.group != rhs.treatment.group) %>% 
      mutate(stratum.ate = stratum.assign.mean.dewormed - stratum.ate,
             stratum.size = stratum.size + stratum.assign.size,
             stratum.sample.var = stratum.sample.var + stratum.assign.sample.var.dewormed)
  }
 
  calc.strata.ate <- . %>% 
    group_by_(.dots = c(.strat.by, .treatment)) %>% 
    summarize(stratum.assign.size = n(),
              stratum.assign.mean.dewormed = mean(dewormed.any),
              stratum.assign.sample.var.dewormed = var(dewormed.any)/stratum.assign.size) %>%  
    ungroup %>% 
    mutate(total.size = sum(stratum.assign.size),
           treatment.group = do.call(function(...) paste(..., sep = "_"), select_(., .dots = .treatment))) %>% 
    group_by_(.dots = .strat.by) %>% 
    do(calc.stratum.ate(.)) %>% 
    group_by_(.dots = c("treatment.group", .interact.with)) %>% 
    do(mutate(., treatment.mean.dewormed = weighted.mean(.$stratum.assign.mean.dewormed, .$stratum.assign.size))) %>% 
    ungroup
  
  
  strata.data <- .data %>% 
    calc.strata.ate
  
  strata.data %>% {
    left_join(distinct_(., .dots = c(.strat.by, "treatment.group", .interact.with), .keep_all = TRUE) %>% 
                select(-c(assigned.treatment, rhs.treatment.group, stratum.ate, stratum.size, stratum.sample.var)) %>%
                nest_exclude("strata.data", c("treatment.group", .interact.with)),
              group_by_(., .dots = c("treatment.group", "rhs.treatment.group", .interact.with)) %>%
                summarize(ate = weighted.mean(stratum.ate, stratum.size),
                          sample.var = sum(stratum.sample.var * ((stratum.size/total.size)^2)),
                          treatment.mean.dewormed = first(treatment.mean.dewormed)) %>% 
                ungroup %>% 
                nest_exclude("treatment.data", c("treatment.group", .interact.with)),
              c("treatment.group", .interact.with))
  }
}

calc.pvalue <- . %>% 
  abs %>% 
  pnorm(lower.tail = FALSE) %>% 
  multiply_by(2)

analyze.neyman.blk.bs <- function(.data, .reps = 1000, .interact.with = NULL, ...) {
  .data %<>% 
    left_join(select(cluster.strat.data, wave, county, cluster.id, dist.pot.group), 
              c("wave", "county", "cluster.id")) %>%  
    select(county, dist.pot.group, cluster.id, assigned.treatment, sms.treatment, dewormed.any) %>% {
     original.stats <- calc.strata.stats(., .interact.with = .interact.with, ...)
     
     if (.reps > 0) {
       bs.analysis <- block.bootstrap(., .reps, "cluster.id") %>%
         do(calc.strata.stats(., .interact.with = .interact.with, ...)) %>% 
         ungroup %>% 
         select_(.dots = c("replicate", "treatment.group", .interact.with, "treatment.data")) %>% 
         unnest(treatment.data) %>% 
         group_by_(.dots = c("treatment.group", "rhs.treatment.group", .interact.with)) %>%
         summarize_at(vars(ate, treatment.mean.dewormed), funs(mean(., na.rm = TRUE), sd(., na.rm = TRUE))) %>%
         mutate(ci.lower.treatment.mean.dewormed = treatment.mean.dewormed_mean - 1.64 * treatment.mean.dewormed_sd,
                ci.upper.treatment.mean.dewormed = treatment.mean.dewormed_mean + 1.64 * treatment.mean.dewormed_sd,
                ci.lower.ate = ate_mean - 1.64 * ate_sd,
                ci.upper.ate = ate_mean + 1.64 * ate_sd,
                treatment.mean.dewormed_tstat = treatment.mean.dewormed_mean/treatment.mean.dewormed_sd,
                ate_tstat = ate_mean/ate_sd,
                ate_pvalue = calc.pvalue(ate_tstat))
       
       original.stats %<>% 
         unnest(treatment.data) %>% 
         left_join(bs.analysis, c("treatment.group", "rhs.treatment.group", .interact.with)) %>% 
         nest_exclude("treatment.data", c("treatment.group", .interact.with)) %>% 
         left_join(original.stats %>% select(-treatment.data), ., c("treatment.group", .interact.with))
     } 
     
     return(original.stats)
   }
}
```

Below is the main regression specification, where $m(\cdot)$ and $m_1(\cdot)\dots m_{K-1}(\cdot)$ define the causal effects to estimate.

$$
\begin{equation}
Y_{ij} = m(Z_j, B_j;\theta) \cdot \frac{B_{j}(K)}{N(K)/N} + \sum_{k = 1}^K \alpha_k \cdot B_{j}(k) + \sum_{k=1}^{K-1} m_k(Z_j, B_j;\theta_k)  \cdot \left( B_{j}(k) - B_{j}(K)\cdot\frac{N(k)}{N(K)} \right) + \mathbf{X} \cdot \beta  + \varepsilon_{ij} 
\end{equation}
$$

* $i$ indexes individuals, $j$ clusters
* $Z_{j}(z) = \mathbf{1}\{Z_j = z\}$ is an indicator for whether cluster $j$ was assigned treatment $z$.
* $B_{j}(k) = \mathbf{1}\{B_j = k\}$ is an indicator for whether cluster $j$ is in stratum $k$.
* $N(k)$ is the size of startum $k$.
* $N$ is the total number of observations

# Basic Treatment Effect

Here we estimate the below models

$$
\begin{align}
m(Z_j, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}} \tau(z) \cdot Z_{j}(z)  \\
m_k(Z_j, B_j; \theta_k) &= \sum_{z\in \mathcal{Z}\setminus\{control\}} \tau_k(z) \cdot Z_{j}(z)  
\end{align}
$$
where $E[Y_{ij}(z) - Y_{ij}(control)] = \tau(z)$.

```{r, echo=TRUE}
reg.output <- census.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  left_join(select(cluster.strat.data, wave, county, cluster.id, dist.pot.group), c("wave", "county", "cluster.id")) %>%  
  left_join(calc.strat.interaction.terms(.), "KEY.individ") %>% 
  run.strat.reg 

kable(reg.output$reg.summary)
```

Below is the corresponding estimates using Neyman's approach:

```{r, echo=TRUE}
neyman.results <- census.data %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  analyze.neyman.blk.bs(1000) %>% 
  mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet")))  
```

```{r}
neyman.results %>% 
  unnest(treatment.data) %>%
  filter(rhs.treatment.group == "control") %>% 
  select(treatment.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
  kable
```

# Treatment Effect Heterogeneity by Distance to PoT

Here we estimate the below models

$$
\begin{align}
m(Z_j, D_j, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}}\left\{\tau(z) \cdot Z_{j}(z) + \gamma(z) \cdot Z_j(z)\cdot D_j \right\} + \delta \cdot D_j  \\
m_k(Z_j, D_j, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}}\left\{\tau_k(z) \cdot Z_{j}(z) + \gamma_k(z) \cdot Z_j(z)\cdot D_j \right\} + \delta_k \cdot D_j 
\end{align}
$$

where $D_j$ is an indicator for whether cluster $j$ is in the _far_ group. The average treatment estimated here is
$$
E[Y_{ij}(z) - Y_{ij}(control) | D_j = d] = \tau(z) + \gamma(z)\cdot d 
$$

```{r, echo=TRUE}
reg.output <- census.data %>%  
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  left_join(select(cluster.strat.data, wave, county, cluster.id, dist.pot.group), c("wave", "county", "cluster.id")) %>%  
  left_join(calc.strat.interaction.terms(., .treatment = c("assigned.treatment", "dist.pot.group")), "KEY.individ") %>% 
  run.strat.reg(.linear.hypo = c("ink", "calendar", "bracelet") %>% map(~ paste0(., c("", "_far"))))

kable(reg.output$reg.summary)

reg.output$linear.tests %>% 
  select(linear.hypo, estimate, statistic, p.value) %>% 
  kable
```

Below is the corresponding estimation using Neyman's approach:

```{r, echo=TRUE}
neyman.results.dist <- census.data %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>% 
  analyze.neyman.blk.bs(1000, .interact.with = "dist.pot.group") %>% 
  mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet"))) 
```

```{r}
neyman.results.dist %>% 
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "control") %>% 
  select(treatment.group, dist.pot.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
  kable
```

# SMS Treatment

Here we estimate the below models

$$
\begin{align}
m(Z_j, M_{ij}, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}}\left\{\tau(z) \cdot Z_{j}(z) + \sum_{s \in \mathcal{M}\setminus \{none\}} \gamma(z, s) \cdot Z_j(z)\cdot M_{ij}(s) \right\} + \sum_{s\in\mathcal{M}\setminus \{none\}} \delta(s) \cdot M_{ij}(s)  \\
m_k(Z_j, M_{ij}, B_j; \theta) &= \sum_{z \in \mathcal{Z}\setminus \{control\}}\left\{\tau_k(z) \cdot Z_{j}(z) + \sum_{s \in \mathcal{M}\setminus \{none\}} \gamma_k(z, s) \cdot Z_j(z)\cdot M_{ij}(s) \right\} + \sum_{s\in\mathcal{M}\setminus \{none\}} \delta_k(s) \cdot M_{ij}(s)  
\end{align}
$$
where $M_{ij}(s)$ is an indicator of whether individual $i$ received SMS treatment $s$.

The average treatment estimated here is
$$
E[Y_{ij}(z, s) - Y_{ij}(z', s')] = \tau(z) - \tau(z') + \gamma(z, s) - \gamma(z', s') + \delta(s) - \delta(s'),
$$
where 

* $\tau(control) = \delta(none) = 0$ 
* $z = control \lor s = none \implies \gamma(z, s) = 0$

```{r, echo=TRUE}
reg.output <- census.data %>%  
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>% 
  mutate(sms.treatment = factor(sms.treatment, levels = c("sms.control", "reminder.only", "social.info"))) %>% 
  left_join(select(cluster.strat.data, wave, county, cluster.id, dist.pot.group), c("wave", "county", "cluster.id")) %>%  
  left_join(calc.strat.interaction.terms(., .treatment = c("assigned.treatment", "sms.treatment")), "KEY.individ") %>% 
  run.strat.reg(.linear.hypo = c("ink", "calendar", "bracelet") %>% map(~ c(paste0(., "_social.info"), "social.info")))

reg.output$reg.summary %>% kable
```

Corresponding Neyman's approach:

```{r, echo=TRUE}
neyman.results.sms <- census.data %>% 
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>% 
  analyze.neyman.blk.bs(1000, .treatment = c("assigned.treatment", "sms.treatment")) %>% 
  separate(treatment.group, c("assigned.treatment", "sms.treatment"), sep = "_") %>% 
  mutate(assigned.treatment = factor(assigned.treatment, levels = c("control", "ink", "calendar", "bracelet")))  
```

```{r}
neyman.results.sms %>% 
  unnest(treatment.data) %>% 
  filter(str_detect(rhs.treatment.group, paste0("^", assigned.treatment)),
         sms.treatment != "sms.control") %>% 
  select(assigned.treatment, sms.treatment, rhs.treatment.group, ate, ate_sd, ate_tstat, ate_pvalue) %>% 
  kable
```

<!-- ## Distance and SMS Treatment -->

<!-- ```{r, echo=TRUE} -->
<!-- census.data %>%   -->
<!--   filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>%  -->
<!--   mutate(sms.treatment = factor(sms.treatment, levels = c("sms.control", "reminder.only", "social.info"))) %>%  -->
<!--   left_join(select(cluster.strat.data, wave, county, cluster.id, dist.pot.group), c("wave", "county", "cluster.id")) %>%   -->
<!--   left_join(calc.strat.interaction.terms(., .treatment = c("assigned.treatment", "sms.treatment", "dist.pot.group")), "KEY.individ") %>%  -->
<!--   run.strat.reg -->
<!-- ``` -->

# Neyman Approach


```{r, include=FALSE}

# neyman.results.sms.treatment.only <- census.data %>% 
#   filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>% 
#   analyze.neyman.blk.bs(1000, .treatment = "sms.treatment")  

# neyman.results.sms.only <- census.data %>% 
#   filter(monitored, monitor.consent, sms.treatment != "sms.control") %>% #, sms.ctrl.subpop == "phone.owner") %>% 
#   analyze.neyman.blk.bs(10, .interact.with = "sms.treatment") %>%  #.treatment = c("assigned.treatment", "sms.treatment")) %>% 
#   mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet"))) 

# neyman.results.sms.only.dist <- census.data %>% 
#   filter(monitored, monitor.consent, sms.treatment != "sms.control") %>% #, sms.ctrl.subpop == "phone.owner") %>% 
#   analyze.neyman.blk.bs(10, .interact.with = "dist.pot.group") %>% 
#   mutate(treatment.group = factor(treatment.group, levels = c("control", "ink", "calendar", "bracelet"))) 
```

```{r}
col.to.show <- c("dist.pot.group", "assigned.treatment", "sms.treatment", "treatment.group", "rhs.treatment.group", "ate", "ate_sd", "ate_tstat", "ate_pvalue")

neyman.results %>% unnest(treatment.data) %>% select_(.dots = intersect(names(.), col.to.show))
neyman.results.dist %>% unnest(treatment.data) %>% select_(.dots = intersect(names(.), col.to.show))
```

```{r}
neyman.results.sms %>% 
  unnest(treatment.data) %>% 
  select_(.dots = intersect(names(.), col.to.show)) %>% 
  separate(rhs.treatment.group, c("rhs.assigned.treatment", "rhs.sms.treatment"), sep = "_") %>% {
    filter(., assigned.treatment == rhs.assigned.treatment, sms.treatment == "sms.control") %>% 
      select(-rhs.assigned.treatment) %>% 
      print
    
    filter(., assigned.treatment == "control", rhs.assigned.treatment == "ink") %>% 
      select(-ends_with("assigned.treatment")) %>% 
      print
    
    filter(., assigned.treatment == "calendar", rhs.assigned.treatment == "bracelet") %>% 
      select(-ends_with("assigned.treatment")) %>% 
      print
  }
```

```{r}
neyman.results %>% 
  unnest(strata.data) %>% 
  select(-total.size) %>% 
  arrange(county, dist.pot.group, treatment.group)


# 
# neyman.results.dist %>% 
#   unnest(strata.data) %>% 
#   select(-total.size) %>% 
#   arrange(county, dist.pot.group, treatment.group)
```

The take-up levels in the control arm (per stratum) are:

```{r}
neyman.results %>% 
  unnest(strata.data) %>% 
  filter(treatment.group == "control") %>% 
  arrange(county, dist.pot.group, treatment.group) %>% 
  transmute(county, dist.pot.group, baseline.takeup = stratum.assign.mean.dewormed)
```

```{r}
neyman.results %>% 
  unnest(treatment.data) %>% 
  distinct(treatment.group, treatment.mean.dewormed)
```


```{r}
neyman.results %>% 
  unnest(treatment.data) %>% 
  distinct(treatment.group, .keep_all = TRUE) %>% 
  ggplot() +
    geom_col(aes(treatment.group, treatment.mean.dewormed), alpha = 0.5, color = "black") +
    scale_x_discrete("Treatment") +
    scale_y_continuous("Proportion Dewormed", breaks = seq(0, 0.6, 0.05))

neyman.results.dist %>% 
  unnest(treatment.data) %>% 
  distinct(treatment.group, dist.pot.group, .keep_all = TRUE) %>% 
  ggplot(.) +
  geom_col(aes(treatment.group, treatment.mean.dewormed, fill = dist.pot.group), alpha = 0.5, color = "black", position = "dodge") +
  scale_x_discrete("Treatment") +
  scale_y_continuous("Proportion Dewormed", breaks = seq(0, 0.6, 0.05)) +
  scale_fill_discrete("Distance to PoT")
```

```{r, eval=FALSE}
neyman.results.sms.only %>% 
  unest(treatment.data) %>% 
  distinct(treatment.group, .keep_all = TRUE) %>% 
  ggplot() +
    geom_col(aes(treatment.group, treatment.mean.dewormed), alpha = 0.5, color = "black") +
    scale_x_discrete("Treatment") +
    scale_y_continuous("Proportion Dewormed", breaks = seq(0, 0.6, 0.05))

neyman.results.sms.only %>% 
  unest(treatment.data) %>% 
  distinct(treatment.group, sms.treatment, .keep_all = TRUE) %>% 
  ggplot(.) +
  geom_col(aes(treatment.group, treatment.mean.dewormed, fill = sms.treatment), alpha = 0.5, color = "black", position = "dodge") +
  scale_x_discrete("Treatment") +
  scale_y_continuous("Proportion Dewormed", breaks = seq(0, 0.6, 0.05)) +
  scale_fill_discrete("Distance to PoT")
```

```{r}
census.data %>% 
  filter(monitored, monitor.consent, sms.treatment == "sms.control") %>%
  left_join(select(cluster.strat.data, wave, county, cluster.id, dist.pot.group), c("wave", "county", "cluster.id")) %>%  
  select(county, dist.pot.group, cluster.id, assigned.treatment, sms.treatment, dewormed.any) %>% 
  group_by(assigned.treatment, dist.pot.group, cluster.id) %>% 
  summarize(takeup.prop = mean(dewormed.any)) %>% 
  ggplot(aes(assigned.treatment, takeup.prop)) +
  # geom_violin()
  geom_boxplot(aes(color = dist.pot.group)) + 
  scale_y_continuous("Cluster Proportion Proportion", breaks = seq(0, 0.8, 0.05)) +
  scale_x_discrete("Treatment") +
  scale_color_discrete("Distance to PoT")
```

```{r, include=FALSE, eval=FALSE}
neyman.results.sms <- census.data %>%
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>%
  left_join(select(cluster.strat.data, wave, county, cluster.id, dist.pot.group), c("wave", "county", "cluster.id")) %>%
  transmute(stratum = paste(county, dist.pot.group, sep = "."),
            county, dist.pot.group, cluster.id, assigned.treatment, sms.treatment, dewormed.any) %>%
  # block.bootstrap(1000, "cluster.id") %>%
  do(calc.strata.stats(., .treatment = c("assigned.treatment", "sms.treatment"), .interact.ate.with = "dist.pot.group")) #%>%
  # ungroup %>%
  # select(-baseline) %>%
  # group_by(assigned.treatment, dist.pot.group) %>%
  # summarize_at(vars(starts_with("ate"), treat.grp.dewormed), funs(mean(., na.rm = TRUE), sd(., na.rm = TRUE))) %>%
  # mutate(ci.lower.dewormed = treat.grp.dewormed_mean - 1.64 * treat.grp.dewormed_sd,
  #        ci.upper.dewormed = treat.grp.dewormed_mean + 1.64 * treat.grp.dewormed_sd,
  #        ci.lower.ate = ate_mean - 1.64 * ate_sd,
  #        ci.upper.ate = ate_mean + 1.64 * ate_sd,
  #        ci.lower.ate.calendar = ate.calendar_mean - 1.64 * ate.calendar_sd,
  #        ci.upper.ate.calendar = ate.calendar_mean + 1.64 * ate.calendar_sd)
```

```{r, eval=FALSE}
census.data %>%
  filter(monitored, monitor.consent, sms.treatment != "sms.control" | sms.ctrl.subpop == "phone.owner") %>%
  left_join(select(cluster.strat.data, wave, county, cluster.id, dist.pot.group), c("wave", "county", "cluster.id")) %>%
  transmute(stratum = paste(county, dist.pot.group, sep = "."),
            county, dist.pot.group, cluster.id, assigned.treatment, sms.treatment, dewormed.any) %>%
  calc.strata.stats(., .treatment = c("assigned.treatment", "sms.treatment"))
```

## Non SMS treated individuals 

Phone and non-phone owners

### Compared to _control_

```{r, echo=FALSE}
neyman.results %>%
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "control") %>% 
  ggplot(aes(treatment.group, ate)) + #, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_point() +  #, color = "black") +
  geom_line(aes(group = 1)) + #aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate, ymax = ci.upper.ate), width = 0.05) +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) #+
  # facet_wrap(~ dist.pot.group, scales = "free_y")
```

```{r, echo=FALSE}
neyman.results.dist %>%
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "control") %>% 
  ggplot(aes(treatment.group, ate, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_line(aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate, ymax = ci.upper.ate), width = 0.05, position = "dodge") +
  geom_point(color = "black") +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) +
  facet_wrap(~ dist.pot.group, scales = "free_y")
```

### Compared to _calendar_ group

```{r, echo=FALSE}
neyman.results %>%
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "calendar") %>% 
  ggplot(aes(treatment.group, ate_mean)) + #, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_point() +  #, color = "black") +
  geom_line(aes(group = 1)) + #aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate, ymax = ci.upper.ate), width = 0.05) +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) #+
  # facet_wrap(~ dist.pot.group, scales = "free_y")
```

```{r}
neyman.results.dist %>%
  unnest(treatment.data) %>% 
  filter(rhs.treatment.group == "calendar") %>% 
  ggplot(aes(treatment.group, ate, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_line(aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate, ymax = ci.upper.ate), width = 0.05, position = "dodge") +
  geom_point(color = "black") +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) +
  facet_wrap(~ dist.pot.group, scales = "free_y")
```


## All phone owners

### Compared to control

```{r, echo=FALSE, eval=FALSE}
neyman.results.all %>%
  filter(assigned.treatment != "control") %>% 
  ggplot(aes(assigned.treatment, ate_mean, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_point() +  #, color = "black") +
  geom_line(aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate, ymax = ci.upper.ate), width = 0.05) +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) +
  facet_wrap(~ dist.pot.group, scales = "free_y")

```

### Compared to _calendar_ group

```{r, eval=FALSE}
neyman.results.all %>%
  filter(assigned.treatment != "calendar") %>% 
  ggplot(aes(assigned.treatment, atecalendar_mean, col = dist.pot.group)) +
  geom_hline(yintercept = 0) +
  geom_point() +  #, color = "black") +
  geom_line(aes(group = dist.pot.group)) +
  geom_errorbar(aes(ymin = ci.lower.ate.calendar, ymax = ci.upper.ate.calendar), width = 0.05) +
  scale_y_continuous("Average Treatment Effect", breaks = seq(-0.1, 0.3, 0.01)) +
  facet_wrap(~ dist.pot.group, scales = "free_y")
```


