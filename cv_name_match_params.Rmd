---
title: "Name Matching Parameters Selection Using Cross Validation"
output:
  html_notebook:
    fig_align: "center"
    fig_caption: yes
    fig_height: 5
    fig_width: 8
    number_sections: yes
    theme: flatly
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
header-includes:
   - \usepackage{bbm}
---

```{r setup}
library(magrittr)
library(stringr)
library(modelr)
library(broom)
library(plyr)
library(tidyverse)
library(ggrepel)
library(car)

library(econometr)

source("analysis_util.R")

config <- yaml::yaml.load_file(file.path("..", "local_config.yaml"))

doParallel::registerDoParallel(cores = config$cores)
```
 
```{r load-data}
load(file.path("data", "analysis.RData"))
takeup.data <- read_rds(file.path("data", "takeup.rds"))
```

What we want to do is:

1. Estimate a take-up model using only the monitored individuals
2. Using a "training" subset of the unmonitored individuals:
    a) Using the monitored take-up model predict the take-up proportion in their cell (based on treatment, strata, covariates, etc.) 
    b) Name match this training subset to estimate the proportion of take-up
    c) Calculate the MSE between the monitored and unmonitored fitted take-up
3. For name matching:
    a) Hold the max string matching distance fixed (e.g. at 3)
    b) Vary over different values of the insertion, deletion, and substitution costs (e.g. ranging from 0 to 4 with some discrete increment)
4. Pick matching parameters that minimize the MSE
5. Use optimal matching parameters to estimate the take-up of the remaining unmonitored individuals

Identify the outlier clusters for the monitored individuals:

```{r outliers}
true.mon.outliers <- analysis.data %>% 
  filter(true.monitored) %>% 
  prepare.cluster.takeup.data(consented.only = FALSE) %>% 
  filter(outlier)
```

Fit a model for monitored take-up. 

```{r monitored-takeup-model}
reg.mon.dist.covar <- analysis.data %>%  
  filter(true.monitored, sms.treatment.2 == "sms.control") %>% 
  anti_join(true.mon.outliers, c("cluster.id", "sms.treatment.2" = "sms.treatment")) %>% 
  mutate(phone.owner = if_else(have_phone == "Yes", "yes", "no")) %>% 
  run_strat_reg(dewormed ~ assigned.treatment * phone.owner, # * phone.owner, 
              .strat.by = c("county", "dist.pot.group"), .cluster = "cluster.id", .covariates = "hh.baseline.sample") 
  # lm(dewormed.any ~ assigned.treatment * sms.treatment.2 * dist.pot.group * phone.owner * hh.baseline.sample * county, data = .)
  # glm(dewormed ~ (assigned.treatment * dist.pot.group + hh.baseline.sample) * county, data = ., family = binomial("logit"))
```

```{r, eval=FALSE}
analysis.data %>%  
  filter(true.monitored, sms.treatment.2 == "sms.control") %>% 
  anti_join(true.mon.outliers, c("cluster.id", "sms.treatment.2" = "sms.treatment")) %>% 
  mutate(phone.owner = if_else(have_phone == "Yes", "phone", "no.phone")) %>% 
  run_strat_reg(dewormed ~ assigned.treatment * dist.pot.group, # * phone.owner, 
              .strat.by = c("county"), .cluster = "cluster.id", .covariates = "hh.baseline.sample") %>% 
  prep.sms.ctrl.plot.data(.interact.with = "far") %>% 
  # mutate(grp = factor(grp, levels = c("ref.grp", "compare.grp"), labels = c("Non Phone", "Phone"))) %>% 
  plot.sms.ctrl.takeup(., .facet.formula = grp ~ ref.treatment) +
  labs(subtitle = "Without controls") 
```


Put together a quick matching algorithm:

```{r}
quick.name.match <- function(census.cluster.data, 
                             takeup.cluster.data,
                             cost.params,
                             max.cost = 3) {
  dist.mat <- adist(census.cluster.data$name1st, takeup.cluster.data$name1st, ignore.case = TRUE, costs = cost.params) +
    adist(census.cluster.data$last_name, takeup.cluster.data$last_name, ignore.case = TRUE, costs = cost.params)
  
  census.cluster.data %>% 
    mutate(KEY.individ, 
           cv.min.name.match.dist = aaply(dist.mat, 1, . %>% min(na.rm = TRUE)) %>% na_if(Inf),
              # cv.which.min.name.match.dist = ifelse(!is.na(min.name.match.dist),
              #                                    aaply(dist.mat, 1, . %>%
              #                                            which.min %>%
              #                                            magrittr::extract(takeup.cluster.data$KEY.survey.individ, .)),
              #                                    NA),
           cv.dewormed.matched = !is.na(cv.min.name.match.dist) & cv.min.name.match.dist <= max.cost) 
}
```


```{r}
cost.param.eval <- analysis.data %>% 
  filter(!monitored) %>% 
  # group_by(cluster.id) %>% 
  # sample_n(5) %>% 
  # ungroup %>% 
  mutate(phone.owner = if_else(have_phone == "Yes", "yes", "no")) %>% 
  add_predictions(reg.mon.dist.covar, "dewormed.pred") %>% 
  (function(training.data) {
    seq(0, 4, 1) %>% 
      expand.grid(ins = ., del = ., sub = .) %>% 
      adply(1, function(cost.params) {
        training.data %>% 
          group_by(cluster.id) %>% 
          do(quick.name.match(., semi_join(takeup.data, ., "cluster.id"), cost.params = cost.params)) %>% 
          ungroup %>% 
          summarize(mse = mean((dewormed.pred - cv.dewormed.matched)^2))
      }, .parallel = TRUE)
  })
```




