---
title: "Structural Distance Model Results"
output:
  pdf_document:
    number_sections: yes
  html_notebook:
    fig_caption: yes
header-includes:
  - \usepackage[table,dvipsnames]{xcolor}
  - \usepackage{pxfonts}
  - \usepackage{bbm}
  - \usepackage{amsmath,amsfonts,amssymb}
  - \usepackage{mathtools}
  - \usepackage{subfig}
  - \usepackage{tikz}
  - \usepackage{booktabs}
  - \usepackage{multirow}
  - \usepackage{float}
  - \usepackage{pdflscape}
  - \newcommand{\blandscape}{\begin{landscape}}
  - \newcommand{\elandscape}{\end{landscape}}
---

```{r setup, include=FALSE}
library(magrittr)
library(tidyverse)
library(rstan)
library(loo)
library(bayesplot)
library(latex2exp)
library(ggdag)
library(nleqslv)
library(parallel)
library(pbmcapply)
library(ggstance)
library(latex2exp)
library(withr)

options(mc.cores = 12)
rstan_options(auto_write = TRUE)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, cache=TRUE)

ggplot2::theme_set(theme_minimal())
```

```{r util-scripts, cache=FALSE}
source("analysis_util.R")
source(file.path("multilvlr", "multilvlr_util.R"))
source("dist_structural_util.R")
```

```{r load-reduced-form-results, cache=FALSE, eval=FALSE}
reduced_form_env <- new.env()
load(file.path("stan_analysis_data", "takeup_model_4_always_predict_processed.RData"), envir = reduced_form_env)
```


```{r load-data}
load(file.path("stan_analysis_data", "dist_fit13.RData"))
load(file.path("stan_analysis_data", "dist_kfold14.RData"))
```

\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,petri,calc}

# Model

Define the following variables:

* $Z \in \{\textrm{control, ink, calendar, bracelet}\}$, village assigned incentive/signal treatment.
* $D \in \mathbb{R}^+$, village assigned distance to point of treatment.

<!-- \widetilde{Y}_{zd} &= \beta_z - \delta_1 \times d - \delta_2 \times d^2 + \mu_z \cdot \Delta^*_{zd} + \overbrace{u_B + u_R + u_Y + v}^{u} \\ -->

Our model of take-up is
\begin{align*}
\widetilde{Y}_{zd} &= \beta_z - \delta_d + \mu_z \cdot \Delta^*_{zd} + \overbrace{u_B + u_R + u_Y + v}^{u} \\
\nonumber \\
Y_{zd} &= \mathbbm{1}(\widetilde{Y}_{zd} > 0), 
\end{align*}
where $\widetilde{Y}_{zd}$ is the latent utility in response to assigned incentive treatment $z$ and distance to deworming treatment $d$, and $Y_{zd}$ is a binary indicator of deworming take-up. 

\[\Delta^*_{zd} = \Delta(V^*_{zd}) = E[V > V^*_{zd}] - E[V < V^*_{zd}]\] 
is the reputational utility of signaling, where the variable $V \sim N(0, 1)$ is the latent prosocial type and $V^*_{zd}$ is the cutoff prosocial level, in response to $z$ and $d$, such that
<!-- \[ V^*_{zd} = - \beta_z + \delta_1 \times d + \delta_2 \times d^2 - \mu_z \cdot \Delta(V^*_{zd}). \] -->
\[ V^*_{zd} = - \beta_z + \delta_d - \mu_z \cdot \Delta(V^*_{zd}). \]
$\mu_z > 0$ is a coefficient combining the observability of the signal $z$ and the social value placed on deworming.

To faciliate our discussion of counterfactuals, we use a graphical model to the causal relationship between the different structural components of the take-up decision making process. This model is defined as $\mathcal{M} = \langle \mathcal{U,W,F} \rangle$, where:

1. $\mathcal{U} = \{U_B, U_R, U_Y, V\}$, are the background variables. $U_B, U_R,$ and $U_Y$ are background variables affecting $B, R,$ and $Y$, respectively, while $V$ is the prosocial type described above. To put no restrictions on the joint distribution of these variables, will refer to them jointly as the variable $U$.
  
2. $\mathcal{W} = \{Z, D, \bar{B}, B, R, Y\}$, are the observed and unobserved endogenous variable determined by other variables in the model, $\mathcal{U} \cup \mathcal{W}$.

    i) $Z$ and $D$ as above.
    ii) $\bar{B}$ is the latent consumption utility of incentives, excluding any individual level background, while $B = \bar{B} + U_B$.
    iii) $R$ is the latent reputational utility.
    iv) $Y$ is a binary variable indicating take-up.
    
3. $\mathcal{F} = \{f_{\bar{B}}, f_B, f_R, f_Y\}$, are the set of functions such that, for each $W_i \in \mathcal{W}$, it is determined from its parent variables $PA_i\subseteq \mathcal{W}\setminus W_i$ and the latent background variable $R_i$. 

The directed acyclic graph for this model is show in Figure \ref{fig:dag}. 

\begin{figure}
\centering
\begin{tikzpicture}
  [ 
    node distance=2cm,
    line width=1.25,
    every label/.append style={font=\Large},
    observed/.style={circle,fill=black,inner sep=0pt,minimum size=3mm},
    latent/.style={circle,draw=black,inner sep=0pt,minimum size=3mm},
    latent-edge/.style={->,dashed},
    place/.style={circle,draw=blue!50,fill=blue!20,thick,
    inner sep=0pt,minimum size=6mm},
    transition/.style={rectangle,draw=black!50,fill=black!20,thick,
    inner sep=0pt,minimum size=4mm}
  ]

\node[observed] (Y) [label=above:$Y$] {};
\node[latent] (R) [label=120:$R$,left=of Y] {}
  edge[->] (Y);
\node[latent] (B) [label=below:$B$,below=of R] {}
  edge[->] (Y);
\node[latent] (Bbar) [label=below:$\bar{B}$,left=of B] {}
  edge[->] (R)
  edge[->] (B);
\node[observed] (D) [label=above:$D$,left=of Bbar] {}
  edge[->] (Bbar);
\node[observed] (Z) [label=above:$Z$,above=of D] {}
  edge[->] (R)
  edge[->] (Bbar);
\node[latent] (U) [label=60:$U$,right=of Y] {}
  edge[latent-edge,bend right=60] (R)
  edge[latent-edge] (Y)
  edge[latent-edge,bend left=30] (B);
\end{tikzpicture}
\caption{Causal diagram of how private (consumption) utility and signaling (reputational) utility affect take-up. Filled points represent observable variables while hollow points represent latent variables. Dashed arrows represent the effect of background variables.}
\label{fig:dag}
\end{figure}

The functions in $\mathcal{F}$ are defined as

  <!-- \bar{b} &= f_{\bar{B}}(z, d) = \beta_z + \delta_1 \times d + \delta_2 \times d^2 \\ -->

\begin{align*}
  \bar{b} &= f_{\bar{B}}(z, d) = \beta_z - \delta_d \\
  b &= f_{B}(\bar{b}, u_B) = \bar{b} + u_B \\
  r &= f_{R}(z, \bar{b}, u_R) = \mu_z \cdot \Delta^*_{z,\bar{b}} + u_R \\
  y &= f_Y(b, r, u_Y) = \mathbbm{1}(b + r + u_Y + v > 0)
\end{align*}

We will consider a number of models:

* Reduced form models, in which we eliminate the reputational component of the model: we restrict $\mu_z = 0$. We consider the following reduced form models: 

    i) **Discrete cost model**, we use a discrete specification for cost, such that \[\delta_d = \delta\times\mathbbm{1}(d>D^*),\] where $D^*$ is the cutoff distance splitting our experiment into randomly assigned _close_ and _far_ clusters. 
    ii) **Semiparameteric cost model**, in which we use splines to model the continuous cost function, $\delta_d = c(d)$.
    
* Structural models, in which the only restriction we place on $\mu_z$ is $\mu_\textrm{ink},\mu_\textrm{calendar},\mu_\textrm{bracelet} \geq \mu_\textrm{control} \geq 0$. We consider the following structural models:

    i) **Quadratic cost model**, where \[\delta_d = \delta_1 \times d + \delta_2 \times d^2,\] with the restriction that $\delta_1,\delta_2 \geq 0$.
    ii) **Semiparameteric cost model**, in which we use splines to model the continuous cost function, $\delta_d = c(d)$.
    iii) **Quadratic cost with salience model**, where cost is quadratic as above, and in addition, we add a salience term to capture any effects due to the signals' observability that is not reputational: \[\delta_{zd} = \delta_1 \times d + \delta_2 \times d^2 + \gamma\cdot \mu_z\times d,\] with $\delta_1,\delta_2,\gamma \geq 0$.

```{r, eval=FALSE}
dagitty::dagitty("dag {
                    Z -> R <- B
                    Z -> B -> Y <- V
                    R -> Y
                    D -> B
                    
                    Z[exposure]
                    D[exposure]
                    R[latent]
                    B[latent]
                    Y[outcome]
                  }") %>% 
  tidy_dagitty() %>%
  ggdag() +
  theme_dag_blank() +
  NULL
```

<!-- ## Statistical Parametres -->

<!-- We model parameters as -->

<!-- \begin{align} -->
<!--   \beta_j &\sim \mathtt{Normal(\beta, \sigma_\beta)} \\ -->
<!--   \beta_z &\sim \mathtt{Normal(0, 1)}, z \in \{\textrm{control, ink, calendar}\} \\ -->
<!--   \beta_\textrm{bracelet} &\sim \beta_\textrm{calendar} - \mathtt{HalfNormal(0, 1)} \\ -->
<!--   \tau_\beta &\sim \mathtt{HalfNormal}(0, 1) \\ -->
<!--   \\ -->
<!--   \boldsymbol{\delta} &\sim \mathtt{MultiNormal}(\mathbf{0}, \mathsf{diag}(1)) \\ -->
<!--   \\ -->
<!--   \mu_z &\sim \mathtt{HalfNormal}(0, 1) -->
<!-- \end{align} -->

# Analysis

```{r params}
quant_probs <- c(0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95)

total_error_sd <- map(dist_fit, extract_obs_fit_level, stan_data = stan_data, par = "total_error_sd", iter_level = "none")

cluster_dist_cost <- map(dist_fit, extract_obs_fit_level, par = "cluster_dist_cost", stan_data = stan_data, iter_level = "cluster", quant_probs = quant_probs) 
# linear_dist_cost <- map(dist_fit, extract_obs_fit_level, par = "linear_dist_cost", stan_data = stan_data, iter_level = "treatment", quant_probs = quant_probs) 

net_benefit <- map(dist_fit, extract_obs_fit_level, par = "structural_cluster_benefit_cost", stan_data = stan_data, iter_level = "cluster", quant_probs = quant_probs) 

v_cutoff <- map(dist_fit, extract_obs_fit_level, par = "structural_cluster_obs_v", stan_data = stan_data, iter_level = "cluster", quant_probs = quant_probs) 

takeup_prob <- map(dist_fit, extract_obs_fit_level, par = "structural_cluster_takeup_prob", stan_data = stan_data, iter_level = "cluster", mix = TRUE, quant_probs = quant_probs) 

structural_beta <- map(dist_fit, extract_obs_fit_level, par = "beta", stan_data = stan_data, iter_level = "treatment", mix = FALSE, quant_probs = quant_probs) 
dist_beta_v <- map(dist_fit, extract_obs_fit_level, par = "dist_beta_v", stan_data = stan_data, iter_level = "treatment", mix = FALSE, quant_probs = quant_probs) 

mu_rep <- dist_fit %>% 
  map(extract_obs_fit_level, par = "mu_rep", stan_data = stan_data, iter_level = "treatment", mix = FALSE, quant_probs = quant_probs) %>% 
  map_if(~ !is_null(.), mutate, compare_to = "control") %>% 
  map_if(~ !is_null(.), ~ left_join(., select(., assigned_treatment, iter_data), by = c("compare_to" = "assigned_treatment"), suffix = c("", "_compare"))) %>% 
  map_if(~ !is_null(.),
      mutate, 
      iter_data = map2(iter_data, iter_data_compare, left_join, by = "iter_id", suffix = c("", "_compare")) %>% 
        map(mutate, 
            iter_est_vs_compare = iter_est - iter_est_compare,
            iter_est_vs_compare_ratio = iter_est / iter_est_compare,
            per = if_else(rank(iter_est) %in% c((n() + 1) %/% 2, ((n() + 1) %/% 2) + ((n() + 1) %% 2)), 0.5, NA_real_)
        ) %>% 
        map2(quantiles_est, ~ mutate(.x, 
                                     per_group = unlist(.y) %>%
                                       set_names(str_extract(names(.), "0\\.\\d+")) %>% { 
                                         cut(iter_est, breaks = c(0, ., Inf), labels = c("0.0", names(.))) } %>% 
                                       as.numeric())),
      mean_est_vs_compare = map_dbl(iter_data, ~ mean(.$iter_est_vs_compare)),
      mean_est_vs_compare_ratio = map_dbl(iter_data, ~ mean(.$iter_est_vs_compare_ratio)),
      quantiles_est_vs_compare = map(iter_data, quantilize_est, iter_est_vs_compare, quant_probs = quant_probs), 
      quantiles_est_vs_compare_ratio = map(iter_data, quantilize_est, iter_est_vs_compare_ratio, quant_probs = quant_probs)
  )

reduced_mu_rep <- map_if(mu_rep, ~ !is_null(.), mutate, iter_data = map(iter_data, arrange, iter_est) %>% map(filter, (row_number() %% 100) == 0))

observed_takeup <- monitored_nosms_data %>% 
  group_by(cluster_id, assigned_treatment = assigned.treatment, assigned_dist = cluster.dist.to.pot) %>% 
  summarize(prop_takeup = mean(dewormed), 
            se = sqrt(prop_takeup * (1 - prop_takeup) / n()),
            prop_takeup_ub = prop_takeup + se,
            prop_takeup_lb = prop_takeup - se) %>% 
  ungroup()

structural_param <- pmap(lst(cluster_dist_cost, net_benefit, v_cutoff, takeup_prob, mu_rep),
                         function(cluster_dist_cost, net_benefit, v_cutoff, takeup_prob, mu_rep) {
                           inner_join(net_benefit, v_cutoff, by = c("obs_index", "assigned_treatment", "assigned_dist", "assigned_dist_standard"), suffix = c("", "_v_cutoff")) %>% 
                             inner_join(cluster_dist_cost, 
                                        by = c("obs_index", "assigned_treatment", "assigned_dist", "assigned_dist_standard"), 
                                        suffix = c("", "_cluster_dist_cost")) %>% { 
                               if (!is_null(mu_rep)) {
                                 inner_join(., takeup_prob, by = c("obs_index", "assigned_treatment", "assigned_dist", "assigned_dist_standard"), suffix = c("", "_takeup_prob")) %>% 
                                   left_join(., mu_rep, by = c("assigned_treatment"), suffix = c("_net_benefit", "_mu_rep")) 
                               } else {
                                 inner_join(., 
                                            takeup_prob, 
                                            by = c("obs_index", "assigned_treatment", "assigned_dist", "assigned_dist_standard"), 
                                            suffix = c("_net_benefit", "_takeup_prob")) 
                               }
                             } %>% 
                              mutate(
                                iter_data = map2(iter_data_net_benefit, iter_data_v_cutoff, inner_join, by = "iter_id", suffix = c("", "_v_cutoff")) %>% {
                                  if (!is_null(mu_rep)) {
                                    map2(., iter_data_takeup_prob, inner_join, by = "iter_id", suffix = c("", "_takeup_prob")) %>% 
                                      map2(iter_data_mu_rep, left_join, by = "iter_id", suffix = c("_net_benefit", "_mu_rep")) 
                                  } else {
                                    map2(., iter_data_takeup_prob, inner_join, by = "iter_id", suffix = c("_net_benefit", "_takeup_prob"))  
                                  }
                                } %>%  
                                  map(mutate, 
                                      iter_est_rep = - iter_est_v_cutoff - iter_est_net_benefit)
                              ) %>% 
                              left_join(select(observed_takeup, -c(assigned_treatment, assigned_dist)), by = c("obs_index" = "cluster_id")
                              )
                         })
```

```{r cf, eval=FALSE}
cluster_cf_benefit_cost <- map(dist_fit, extract_obs_cf, par = "cluster_cf_benefit_cost", stan_data = stan_data, iter_level = "cluster", quant_probs = quant_probs, thin = 2)  

# cluster_cf_benefit_cost %>% map(summarize_at, vars(starts_with("ess")), min) 

cluster_cf_benefit_cost %<>%
  map(select, -starts_with("ess"), -one_of("rhat")) %>% 
  map(nest, iter_data = c(treatment_index, obs_num_takeup, matches("^assigned_(treatment|dist_group)$"), iter_data)) %>% 
  map(mutate, iter_data = map(iter_data, unnest, iter_data)) %>% 
  lst(benefit_cost = ., mu_rep, total_error_sd) %>%
  pmap(function(benefit_cost, mu_rep, total_error_sd) {
    if (!is_null(mu_rep)) {
      mutate(benefit_cost, 
             iter_data = pbmclapply(mc.cores = 12,
                                    iter_data, 
                                    left_join, 
                                    unnest(mu_rep, iter_data) %>% 
                                      select(mu_assigned_treatment = assigned_treatment, iter_id, iter_est) %>%  
                                      inner_join(total_error_sd, by = c("iter_id"), suffix = c("_mu", "_error_sd")),
                                    by = c("iter_id")))
    } else {
      mutate(benefit_cost, 
             iter_data = pbmclapply(mc.cores = 12,
                                    iter_data, 
                                    inner_join, 
                                    total_error_sd, 
                                    by = c("iter_id"), 
                                    suffix = c("", "_error_sd")) %>% 
               map(mutate, mu_assigned_treatment = NA_character_, iter_est_mu = 0))
    } 
  }) %>% 
  map(
    mutate,
    iter_data = pbmclapply(mc.cores = 12,
                           iter_data,
                           function(curr_iter_data) {
                             mutate(
                               curr_iter_data,
                               no_rep_prob = pnorm(iter_est, sd = iter_est_error_sd),
                               v_cutoff = map2_dbl(iter_est, iter_est_mu, ~ nleqslv(x = - ..1, fn = generate_v_cutoff_fixedpoint(..1, ..2)) %>% pluck("x")),
                               delta_rep = rep_normal(v_cutoff), 
                               prob = pnorm(- v_cutoff, sd = iter_est_error_sd)
                             )
                           }) %>% 
      lst(iter_data = ., cluster_size) %>%
      pmap(~ mutate(..1, iter_num_takeup = if_else(!is.na(obs_num_takeup), obs_num_takeup, rbinom(n(), ..2, prob))))
  ) %>% 
  map(mutate, iter_data = map(iter_data, group_by_at, vars(treatment_index, matches("^assigned_(treatment|dist_group)$"), obs_num_takeup)) %>% 
        map(group_nest,  .key = "iter_data")) %>% 
  map(unnest, iter_data) %>% 
  map(left_join, stan_data$analysis_data %>% distinct(cluster_id, dist.pot.group), by = "cluster_id") %>% 
  map_if(~ "assigned_dist_group" %in% names(.), 
         ~ filter(., dist.pot.group == assigned_dist_group) %>% select(-assigned_dist_group)) 

est_takeup_level <- cluster_cf_benefit_cost %>% 
  pbmclapply(
    mc.cores = 3,
    as_mapper(
      ~ select(., cluster_id, assigned_treatment, assigned_dist, dist.pot.group, cluster_size, iter_data) %>% 
        mutate(iter_data = map(iter_data, select, iter_id, mu_assigned_treatment, prob, iter_num_takeup)) %>% 
        unnest(cols = iter_data) %>% 
        group_by_at(vars(iter_id, mu_assigned_treatment, assigned_treatment)) %>% 
        group_nest(.key = "cluster_data") %>%
        mutate(
          iter_prop_takeup = map_dbl(cluster_data, ~ sum(.$iter_num_takeup) / sum(.$cluster_size)),
          cluster_data = map(cluster_data, group_nest, dist.pot.group, .key = "dist_group_cluster_data") %>%
            map(mutate, iter_prop_takeup = map_dbl(dist_group_cluster_data, ~ sum(.$iter_num_takeup) / sum(.$cluster_size))) %>% 
            map(select, -dist_group_cluster_data)
        ) %>% 
        nest(iter_data = c(iter_id, iter_prop_takeup, cluster_data)) %>%
        mutate(
          dist_group_data = map(iter_data, select, iter_id, cluster_data) %>% 
            map(unnest, cluster_data) %>% 
            map(nest, iter_data = c(iter_id, iter_prop_takeup)) %>% 
            map(mutate, 
                mean_est = map_dbl(iter_data, ~ mean(.$iter_prop_takeup)),
                takeup_quantiles = map(iter_data, quantilize_est, iter_prop_takeup, wide = TRUE, quant_probs = quant_probs)) %>% 
            map(unnest, takeup_quantiles),
          iter_data = map(iter_data, select, -cluster_data),
          mean_est = map_dbl(iter_data, ~ mean(.$iter_prop_takeup)),
          takeup_quantiles = map(iter_data, quantilize_est, iter_prop_takeup, wide = TRUE, quant_probs = quant_probs)
        ) %>% 
        unnest(takeup_quantiles)
    )
  )

est_takeup_te <- cluster_cf_benefit_cost %>% 
  pbmclapply(mc.cores = 3,
    as_mapper(
      ~ select(., cluster_id, assigned_treatment, assigned_dist, dist.pot.group, cluster_size, iter_data) %>% 
        mutate(
          iter_data = map(iter_data, select, iter_id, mu_assigned_treatment, prob, iter_num_takeup),
        ) %>% 
        unnest(cols = iter_data) %>% 
        mutate(
          compare_to = "control", # if_else(fct_match(mu_assigned_treatment, "bracelet") | fct_match(assigned_treatment, c("bracelet", "ink", "control", "calendar")), "control", NA_character_) %>% as_factor(),
          mu_compare_to = if_else(is.na(mu_assigned_treatment), NA_character_, "control"),
        ) %>% 
        group_by_at(vars(iter_id, assigned_treatment, mu_assigned_treatment, compare_to, mu_compare_to, )) %>% 
        group_nest(.key = "cluster_data") %>%
        mutate(
          iter_prop_takeup = map_dbl(cluster_data, ~ sum(.$iter_num_takeup) / sum(.$cluster_size)),
          cluster_data = map(cluster_data, group_nest, dist.pot.group, .key = "dist_group_cluster_data") %>%
            map(mutate, iter_prop_takeup = map_dbl(dist_group_cluster_data, ~ sum(.$iter_num_takeup) / sum(.$cluster_size))) %>% 
            map(select, -dist_group_cluster_data)
        ) %>% 
        inner_join(select(., iter_id, assigned_treatment, mu_assigned_treatment, iter_prop_takeup, cluster_data), 
                   by = c("iter_id", "compare_to" = "assigned_treatment", "mu_compare_to" = "mu_assigned_treatment"), suffix = c("_left", "_right")) %>% 
        mutate(
          iter_takeup_te = iter_prop_takeup_left - iter_prop_takeup_right,
          cluster_te_data = map2(cluster_data_left, cluster_data_right, inner_join, by = "dist.pot.group", suffix = c("_left", "_right")) %>% 
            map(mutate, iter_takeup_te = iter_prop_takeup_left - iter_prop_takeup_right)
        ) %>%
        select(-cluster_data_left, -cluster_data_right) %>% 
        group_by(assigned_treatment, mu_assigned_treatment, compare_to, mu_compare_to) %>% 
        group_nest(.key = "iter_data") %>% 
        mutate(
          dist_group_data = map(iter_data, select, iter_id, cluster_te_data) %>% 
            map(unnest, cluster_te_data) %>% 
            map(nest, iter_data = c(iter_id, starts_with("iter_prop_takeup"), iter_takeup_te)) %>% 
            map(mutate, 
                mean_est = map_dbl(iter_data, ~ mean(.$iter_takeup_te)),
                takeup_te_quantiles = map(iter_data, quantilize_est, iter_takeup_te, wide = TRUE, quant_probs = quant_probs)) %>% 
            map(unnest, takeup_te_quantiles),
          iter_data = map(iter_data, select, -cluster_te_data),
          mean_est = map_dbl(iter_data, ~ mean(.$iter_takeup_te)),
          takeup_te_quantiles = map(iter_data, quantilize_est, iter_takeup_te, wide = TRUE, quant_probs = quant_probs)
        ) %>% 
        unnest(takeup_te_quantiles)
    )
  )

est_bbar_vs_takeup <- cluster_cf_benefit_cost %>% 
  map(filter, !is.na(obs_num_takeup)) %>% 
  map(mutate, iter_data = map2(iter_data, assigned_treatment, 
                               ~ if (is.factor(.x$mu_assigned_treatment)) filter(.x, fct_match(mu_assigned_treatment, c("control", as.character(.y)))) else .x))

save(cluster_cf_benefit_cost, est_takeup_level, est_takeup_te, file = file.path("temp-data", "cluster_cf_benefit_cost.RData"))
```

```{r}
load(file.path("temp-data", "cluster_cf_benefit_cost.RData"))
```


```{r}
plot_pos <- position_dodgev(height = 0.75)

model_colors <- RColorBrewer::brewer.pal(length(dist_fit) + 1, "Dark2") %>% 
  set_names(c(names(dist_fit), "OLD_REDUCED_FORM"))

model_names <- c(
  "REDUCED_FORM_NO_RESTRICT" = "Reduced Form Discrete Cost", #\nWith No Incentive Restrictions",
  "STRUCTURAL_SEMIPARAM_NO_REP" = "Reduced Form Semiparametric Cost",
  "STRUCTURAL_QUADRATIC" = "Structural Quadratic Cost",
  "STRUCTURAL_SEMIPARAM" = "Structural Semiparametric Cost",
  "STRUCTURAL_QUADRATIC_SALIENCE" = "Structural Quadratic Cost\nWith Salience",
  # "REDUCED_FORM" = "Discrete Cost",
  "OLD_REDUCED_FORM" = "Old Discrete Cost"
)
```

```{r, fig.width=8, fig.height=5, fig.cap="Take-up levels in response to an incentive treatment intervention."}
est_takeup_level %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  filter(is.na(mu_assigned_treatment) | assigned_treatment == mu_assigned_treatment) %>%
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
    labs(
      title = "Take-up levels in response to an incentive treatment intervention",
      subtitle = TeX("E\\[Y_{z}\\]"),
      x = "Take-up Probability",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  coord_cartesian(xlim = c(0, 0.6)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8, fig.height=4.25,fig.cap="Take-up levels in response to a signaling intervention, holding the private consumption utility at the control level."}
est_takeup_level %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  filter(fct_match(assigned_treatment, "control"), !is.na(mu_assigned_treatment)) %>%
  ggplot(aes(x = per_0.5, y = mu_assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete(TeX("Assigned Signaling Treatment (z')"), labels = str_to_title) +
    labs(
      title = "Take-up levels in response to a signaling intervention,\nholding the private consumption utility at the control level",
      subtitle = TeX("E\\[Y_{z=control,\\bar{B}_{z'}}\\]"),
      x = "Take-up Probability",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  coord_cartesian(xlim = c(0, 0.6)) + 
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r,fig.width=8,fig.height=10,eval=FALSE}
reduced_form_results <- with(
  reduced_form_env,
  summ_level_mean %>%
    filter(is.na(subgroup_by)) %>% 
    select(assigned_treatment = cluster_treatment, dist.pot.group = dist_pot_treatment, est_percentiles) %>% 
    mutate(
      mu_assigned_treatment = assigned_treatment,
      est_percentiles = map(est_percentiles, pivot_wider, names_from = per, values_from = est, names_prefix = "per_")
    ) %>% 
    unnest(est_percentiles)
)

est_takeup_level[c("REDUCED_FORM", "REDUCED_FORM_NO_RESTRICT")] %>%
  bind_rows(.id = "model") %>% 
  select(-starts_with("per_"), -mean_est, -iter_data) %>% 
  unnest(dist_group_data) %>% 
  filter(is.na(mu_assigned_treatment) | assigned_treatment == mu_assigned_treatment) %>%
  bind_rows(reduced_form_results %>% mutate(model = "OLD_REDUCED_FORM")) %>%
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model), position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
    labs(
      title = "Take-up Levels, split by assignd distance to treatment",
      subtitle = TeX("E\\[Y_{z} | D \\in{}D^*\\]"),
      x = "Take-up Probability",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  coord_cartesian(xlim = c(0, 0.6)) +
  facet_wrap(vars(dist.pot.group), ncol = 1, labeller = as_labeller(. %>% str_to_title() %>% str_c("D^* = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```


```{r, fig.width=8,fig.height=10, fig.cap="Take-up levels in response to an incentive treatment intervention, split by assigned distance group."}
est_takeup_level %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  select(-starts_with("per_"), -mean_est, -iter_data) %>% 
  unnest(dist_group_data) %>% 
  filter(is.na(mu_assigned_treatment) | assigned_treatment == mu_assigned_treatment) %>%
  # bind_rows(reduced_form_results %>% mutate(model = "Reduced Form")) %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model), position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
    labs(
      title = "Take-up levels in response to an incentive treatment intervention,\nsplit by assigned distance group",
      subtitle = TeX("E\\[Y_{z} | D \\in{}D^*\\]"),
      x = "Take-up Probability",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  coord_cartesian(xlim = c(0, 0.6)) +
  facet_wrap(vars(dist.pot.group), ncol = 1, labeller = as_labeller(. %>% str_to_title() %>% str_c("D^* = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8,fig.height=7, fig.cap="Take-up levels in response to a signaling intervention, holding the private consumption utility at the control level, and split by assigned distance group."}
est_takeup_level %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  filter(fct_match(assigned_treatment, "control"), !is.na(mu_assigned_treatment)) %>%
  select(-starts_with("per_"), -mean_est, -iter_data) %>% 
  unnest(dist_group_data) %>% 
  filter(fct_match(assigned_treatment, "control")) %>%
  ggplot(aes(x = per_0.5, y = mu_assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete(TeX("Assigned Signaling Treatment (z')"), labels = str_to_title) +
    labs(
      title = "Take-up levels in response to a signaling intervention,\nholding the private consumption utility at the control level,\nand split by assigned distance group",
      subtitle = TeX("E\\[Y_{z=control,\\bar{B}_{z'}} | D \\in{}D^*\\]"),
      x = "Take-up Probability",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  coord_cartesian(xlim = c(0, 0.6)) +
  facet_wrap(vars(dist.pot.group), ncol = 1, labeller = as_labeller(. %>% str_to_title() %>% str_c("D^* = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8, fig.height=4.5, fig.cap="Average treatment effect on take-up, compared to control."}
est_takeup_te %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  filter(
    is.na(mu_assigned_treatment) | assigned_treatment == mu_assigned_treatment,
    (!is.na(mu_compare_to) & (assigned_treatment != compare_to |  assigned_treatment != mu_compare_to)) |
       (is.na(mu_compare_to) & assigned_treatment != compare_to)  
  ) %>%
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
    labs(
      title = "Average treatment effect on take-up, compared to control",
      subtitle = TeX("E\\[Y_{z}\\] - E\\[Y_{control}\\]"),
      x = "Average Treatment Effect",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8, fig.height=4, fig.cap="Average treatment effect of signaling holding consumption utility at the control level, compared to control."}
est_takeup_te %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  filter(
    fct_match(assigned_treatment, "control"),
    !is.na(mu_assigned_treatment),
    assigned_treatment != mu_assigned_treatment,
  ) %>%
  ggplot(aes(x = per_0.5, y = mu_assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete("Assigned\nSignaling Treatment (z')", labels = str_to_title) +
    labs(
      title = "Average treatment effect of signaling holding consumption utility at the control level,\ncompared to control",
      subtitle = TeX("E\\[Y_{z=control,\\bar{B}_{z'}}\\] - E\\[Y_{control}\\]"),
      x = "Average Treatment Effect",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8,fig.height=6,eval=FALSE}
reduced_form_te_results <- with(
  reduced_form_env,
  summ_te_mean %>% 
    filter(
      is.na(subgroup_by),
      cluster_treatment_right == "control",
      dist_pot_treatment_left == dist_pot_treatment_right,
    ) %>% 
    select(assigned_treatment = cluster_treatment_left, dist.pot.group = dist_pot_treatment_left, est_percentiles) %>% 
    mutate(
      mu_assigned_treatment = assigned_treatment,
      est_percentiles = map(est_percentiles, pivot_wider, names_from = per, values_from = est, names_prefix = "per_")
    ) %>% 
    unnest(est_percentiles)
)

est_takeup_te[c("REDUCED_FORM", "REDUCED_FORM_NO_RESTRICT")] %>%
  bind_rows(.id = "model") %>% 
  select(-starts_with("per_"), -mean_est, -iter_data) %>% 
  unnest(dist_group_data) %>% 
  filter(
    is.na(mu_assigned_treatment) | assigned_treatment == mu_assigned_treatment,
    (!is.na(mu_compare_to) & (assigned_treatment != compare_to |  assigned_treatment != mu_compare_to)) |
       (is.na(mu_compare_to) & assigned_treatment != compare_to)  
  ) %>%
  bind_rows(mutate(reduced_form_te_results, model = "OLD_REDUCED_FORM")) %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
    labs(
      title = TeX("E\\[Y_{z} | D \\in{}D^*\\] - E\\[Y_{control} | D \\in{}D^*\\]"),
      x = "Average Treatment Effect",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  facet_wrap(vars(dist.pot.group), ncol = 1, labeller = as_labeller(. %>% str_to_title() %>% str_c("D^* = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8,fig.height=9, fig.cap="Average treatment effect in response to an incentive treatment intervention, split by assigned distance group."}
est_takeup_te %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  select(-starts_with("per_"), -mean_est, -iter_data) %>% 
  unnest(dist_group_data) %>% 
  filter(
    is.na(mu_assigned_treatment) | assigned_treatment == mu_assigned_treatment,
    (!is.na(mu_compare_to) & (assigned_treatment != compare_to |  assigned_treatment != mu_compare_to)) |
       (is.na(mu_compare_to) & assigned_treatment != compare_to)  
  ) %>%
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
    labs(
      title = "Average treatment effect in response to an incentive treatment intervention,\nsplit by assigned distance group", 
      subtitle = TeX("E\\[Y_{z} | D \\in{}D^*\\] - E\\[Y_{control} | D \\in{}D^*\\]"),
      x = "Average Treatment Effect",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  facet_wrap(vars(dist.pot.group), ncol = 1, labeller = as_labeller(. %>% str_to_title() %>% str_c("D^* = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8, fig.height=7, fig.cap="Average treatment effect of signaling holding consumption utility at the control level, compared to control, and split by assigned distance group."}
est_takeup_te %>% 
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  select(-starts_with("per_"), -mean_est, -iter_data) %>% 
  unnest(dist_group_data) %>% 
  filter(
    fct_match(assigned_treatment, "control"),
    !is.na(mu_assigned_treatment),
    assigned_treatment != mu_assigned_treatment,
  ) %>%
  ggplot(aes(x = per_0.5, y = mu_assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete("Assigned Signaling Treatment (z')", labels = str_to_title) +
    labs(
      title = "Average treatment effect of signaling holding consumption utility at the control level,\ncompared to control, and split by assigned distance group",
      subtitle = TeX("E\\[Y_{z=control,\\bar{B}_{z'}} | D \\in{}D^*\\] - E\\[Y_{control} | D \\in{}D^*\\]"),
      x = "Average Treatment Effect",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  facet_wrap(vars(dist.pot.group), ncol = 1, labeller = as_labeller(. %>% str_to_title() %>% str_c("D^* = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=10, eval=FALSE}
est_bbar_vs_takeup %>% 
  unnest(iter_data) %>% 
  # ggplot(aes(iter_est, prob)) +
  ggplot(aes(iter_est, v_cutoff)) +
  geom_point(aes(color = iter_est_mu), alpha = 0.05) +
  scale_color_viridis_c() + 
  facet_grid(row = vars(mu_assigned_treatment), cols = vars(assigned_treatment)) +
  NULL
```

## Model Parameters

```{r, fig.height=5, fig.width=8, fig.cap="Reputational coefficient levels."}
mu_rep %>%
  compact %>% 
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  mutate(assigned_treatment = fct_relabel(assigned_treatment, str_to_title)) %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos,
                           data = . %>%  unnest(quantiles_est)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos,
                           data = . %>%  unnest(quantiles_est)) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos,
                             data = . %>%  unnest(quantiles_est)) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  labs(y = "Assigned Treatment (z)",
       x = TeX("Reputational Returns Coefficient ($\\mu_z$)"),
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.",
       title = "Reputational Returns Cofficients") +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.height=4, fig.width=8, fig.cap="Comparing reputational returns coefficient to control."}
mu_rep %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  filter(!fct_match(assigned_treatment, "control")) %>% 
  mutate(assigned_treatment = fct_relabel(assigned_treatment, str_to_title)) %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos,
                           data = . %>%  unnest(quantiles_est)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos,
                           data = . %>%  unnest(quantiles_est)) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos,
                             data = . %>%  unnest(quantiles_est)) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  labs(y = "Assigned Treatment (z)",
       x = TeX("Reputational Returns Coefficient Compared to Control ($\\mu_z - \\mu_{control}$)"),
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.",
       title = "Reputational Returns Cofficients") +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=12, fig.height=6, eval=FALSE}
structural_param %>%
  bind_rows(.id = "model_type") %>% 
  mutate(assigned_treatment = fct_relabel(assigned_treatment, str_to_title)) %>%
  ggplot(aes(assigned_dist)) +
  # geom_line(aes(y = mean_est_super_net_benefit), color = "darkgrey") +
  # geom_ribbon(aes(ymin = per_0.25, ymax = per_0.75), alpha = 0.25,
  #                 data = . %>% unnest(quantiles_est_super_net_benefit)) +
  geom_pointrange(aes(y = per_0.5, ymin = per_0.1, ymax = per_0.9), size = 0.5, fatten = 0.5, alpha = 0.75,
                  data = . %>% unnest(quantiles_est_net_benefit)) +
  facet_grid(rows = vars(model_type), cols = vars(assigned_treatment)) +
  theme_minimal() +
  labs(
    x = "Assigned Distance",
    y = TeX("Direct Benefit"),
    title = "Direct Benefits",
    caption = "Points: median cluster direct benefit at assigned distance
               Vertical line: cluster direct benefit 50% credible interval
               Line plot: mean cluster direct benefit net cluster effects
               Grey ribbon: cluster direct benefit net cluster effects 50% credible interval"
  ) +
  NULL
```

```{r, fig.width=12, fig.height=6, fig.cap="Distance cost."}
structural_param %>%
  magrittr::extract(setdiff(names(model_names), c("REDUCED_FORM_NO_RESTRICT", "STRUCTURAL_SEMIPARAM_NO_REP"))) %>% 
  bind_rows(.id = "model") %>% 
  mutate(
    model = factor(model, levels = names(model_names)),
    assigned_treatment = fct_relabel(assigned_treatment, str_to_title)
  ) %>%
  ggplot(aes(assigned_dist)) +
  geom_line(aes(y = mean_est_cluster_dist_cost, group = assigned_treatment, color = assigned_treatment)) +
  geom_point(aes(y = mean_est_cluster_dist_cost, group = assigned_treatment, color = assigned_treatment)) +
  facet_wrap(vars(model), nrow = 1, labeller = as_labeller(model_names)) +
  scale_color_brewer("Assigned Treatment", palette = "Set2") +
  theme_minimal() +
  labs(
    x = "Assigned Distance",
    y = TeX("Cost"),
    title = "Cost"
    # caption = "Points: median cluster direct benefit at assigned distance
    #            Vertical line: cluster direct benefit 50% credible interval
    #            Line plot: mean cluster direct benefit net cluster effects
    #            Grey ribbon: cluster direct benefit net cluster effects 50% credible interval"
  ) +
  NULL
```

```{r, fig.width=12, fig.cap="Reputational cutoff as a function of consumption benefit.", eval=FALSE}
structural_param %>% 
  magrittr::extract(setdiff(names(model_names), c("REDUCED_FORM_NO_RESTRICT", "STRUCTURAL_SEMIPARAM_NO_REP"))) %>%
  bind_rows(.id = "model") %>% 
  unnest(iter_data) %>% 
  mutate(
    model = factor(model, levels = names(model_names)),
    assigned_treatment = fct_relabel(assigned_treatment, str_to_title)
  ) %>%
  ggplot(aes(iter_est_net_benefit, iter_est_v_cutoff)) +
  geom_point(aes(color = iter_est_mu_rep), alpha = 0.05) +
  geom_abline(intercept = 0, slope = -1, linetype = "dotted") +
  scale_color_viridis_c(TeX("Reputational\nReturns Coefficient ($\\mu_z$)")) +
  facet_grid(rows = vars(model), cols = vars(assigned_treatment), labeller = labeller(.rows = model_names)) +
  coord_fixed() +
  labs(
    title = "Reputational cutoff as a function of consumption benefit",
    x = "Direct Benefit",
    y = TeX("Prosocial Type Cutoff ($V^*$)")
  ) +
  theme(legend.position = "bottom", strip.text.y = element_text(angle = 0)) +
  NULL
```

```{r, fig.width=10, fig.height=8, fig.cap="Reputational returns as a function of reputational cutoff.", eval=FALSE}
structural_param %>% 
  bind_rows(.id = "model_type") %>% 
  unnest(iter_data) %>% 
  mutate(assigned_treatment = fct_relabel(assigned_treatment, str_to_title)) %>%
  ggplot(aes(iter_est_v_cutoff, iter_est_rep)) +
  geom_point(aes(color = iter_est_mu_rep), alpha = 0.05) +
  facet_grid(rows = vars(model_type), cols = vars(assigned_treatment), labeller = labeller(.rows = model_names)) +
  scale_color_viridis_c(TeX("Reputational\nReturns Coefficient ($\\mu_z$)")) +
  labs(
    title = "Reputational returns as a function of reputational cutoff",
    x = TeX("Prosocial Type Cutoff ($V^*$)"),
    y = "Reputational Returns (R)"
  ) +
  theme(legend.position = "bottom", strip.text.y = element_text(angle = 0)) +
  NULL
```

```{r, fig.width=16, fig.height=10, eval=FALSE}
structural_param %>% 
  bind_rows(.id = "model_type") %>% 
  mutate(assigned_treatment = fct_relabel(assigned_treatment, str_to_title)) %>%
  ggplot(aes(assigned_dist)) +
  geom_crossbar(aes(y = prop_takeup, ymin = prop_takeup_lb, ymax = prop_takeup_ub, color = "Observed"), size = 0.5, width = 60) +
  geom_pointrange(aes(y = per_0.5, ymin = per_0.25, ymax = per_0.75, color = "Estimated"), size = 0.5, fatten = 0.75, data = . %>% unnest(quantiles_est_takeup_prob)) +
  facet_wrap(vars(assigned_treatment), ncol = 2) +
  # facet_grid(rows = vars(model_type), cols = vars(assigned_treatment)) +
  scale_color_manual("", values = c(Observed = "darkred", Estimated = "black")) +
  labs(
    x = "Assigned Distance",
    y = ""
  ) +
  theme_minimal() +
  NULL
```

<!-- ## Simulation Results -->

```{r, eval=FALSE}
sim_benefit_cost <- map(dist_fit, extract_sim_level, par = "sim_benefit_cost", stan_data = stan_data, quant_probs = quant_probs) 
  
cf_prob_z_b_zd <- sim_benefit_cost %>%
  map(select, assigned_treatment, cf_iter_data = iter_data, starts_with("assigned_dist")) %>% 
  map(filter, assigned_treatment %in% c("control", "bracelet")) %>% 
  lst(benefit_cost = ., mu_rep, total_error_sd) %>% 
  pmap(function(benefit_cost, mu_rep, total_error_sd) {
         mutate(benefit_cost, 
                cf_iter_data = pbmclapply(mc.cores = 12,
                                          cf_iter_data, 
                                          left_join, 
                                          unnest(mu_rep, iter_data) %>% 
                                            filter(assigned_treatment %in% c("control", "bracelet")) %>% 
                                            select(mu_assigned_treatment = assigned_treatment, iter_id, iter_est) %>%  
                                            inner_join(total_error_sd, by = "iter_id", suffix = c("_mu", "_error_sd")),
                                          by = "iter_id"))
       }) %>% 
  # map_at(
  #   "STRUCTURAL_SALIENCE",
  map(
    mutate,
    cf_iter_data = pbmclapply(mc.cores = 12,
                              cf_iter_data, 
                              mutate,
                              no_rep_prob = pnorm(iter_est, sd = iter_est_error_sd),
                              v_cutoff = map2_dbl(iter_est, iter_est_mu, ~ nleqslv(x = - ..1, fn = generate_v_cutoff_fixedpoint(..1, ..2)) %>% pluck("x")),
                              delta_rep = rep_normal(v_cutoff), 
                              prob = pnorm(- v_cutoff, sd = iter_est_error_sd))) %>% 
  map(
  # map_at(
  #   "STRUCTURAL_SALIENCE",
    mutate,
    cf_iter_data = pbmclapply(mc.cores = 12, cf_iter_data, group_nest, mu_assigned_treatment, .key = "cf_iter_data")) %>% 
  # map_at(
  #   "STRUCTURAL_SALIENCE", 
  map(
    unnest, cf_iter_data) %>% 
  # map_at(
  #   "STRUCTURAL_SALIENCE",
  map(
    mutate,
    cf_quantiles = pbmclapply(mc.cores = 12, cf_iter_data, quantilize_est, prob, quant_probs),
    cf_no_rep_quantiles = pbmclapply(mc.cores = 12, cf_iter_data, quantilize_est, no_rep_prob, quant_probs),
    cf_mean = map_dbl(cf_iter_data, ~ mean(.$prob)),
    cf_no_rep_mean = map_dbl(cf_iter_data, ~ mean(.$no_rep_prob)),
    cf_delta_rep_mean = map_dbl(cf_iter_data, ~ mean(.$delta_rep)))

save(cf_prob_z_b_zd, file = file.path("stan_analysis_data", "cf.RData"))
```

```{r, fig.width=10, eval=FALSE}
cf_prob_z_b_zd$STRUCTURAL_SALIENCE %>% 
  mutate(cf_no_rep_mean = map_dbl(cf_iter_data, ~ mean(.$no_rep_prob))) %>% 
  mutate_at(vars(cf_quantiles), 
            ~ map(., mutate, per = str_c("per_", per)) %>% 
              map(spread, per, est)) %>% 
  ggplot(aes(assigned_dist, cf_mean)) +
  geom_line(aes(group = mu_assigned_treatment, color = mu_assigned_treatment, linetype = "with rep")) +
  geom_line(aes(y = cf_no_rep_mean, group = mu_assigned_treatment, color = mu_assigned_treatment, linetype = "no rep")) +
  # geom_ribbon(aes(ymin = per_0.25, ymax = per_0.75, fill = mu_assigned_treatment), alpha = 0.25,
  #                 data = . %>% unnest(cf_quantiles)) +
  facet_wrap(vars(assigned_treatment))
```

```{r, fig.width=10, eval=FALSE}
cf_prob_z_b_zd$STRUCTURAL_SALIENCE %>% 
  filter(assigned_treatment == mu_assigned_treatment) %>% 
  mutate_at(vars(cf_quantiles), 
            ~ map(., mutate, per = str_c("per_", per)) %>% 
              map(spread, per, est)) %>% 
  ggplot(aes(assigned_dist, cf_mean)) +
  geom_line(aes(group = mu_assigned_treatment, color = mu_assigned_treatment)) +
  geom_ribbon(aes(ymin = per_0.25, ymax = per_0.75, fill = mu_assigned_treatment), alpha = 0.25,
                  data = . %>% unnest(cf_quantiles)) 
```

```{r, eval=FALSE}
cf_prob_z_b_zd$STRUCTURAL_SALIENCE %>% 
  filter(assigned_treatment == mu_assigned_treatment) %>% 
  mutate(cf_iter_data = map(cf_iter_data, sample_frac, 0.1)) %>% 
  unnest(cf_iter_data) %>% 
  ggplot(aes(v_cutoff, delta_rep)) +
  geom_point(aes(color = assigned_dist), position = "jitter", alpha = 0.05) +
  scale_color_viridis_c() +
  facet_wrap(vars(assigned_treatment)) +
  NULL
```

```{r, eval=FALSE}
cf_prob_z_b_zd$STRUCTURAL_SALIENCE %>% 
  filter(assigned_treatment == mu_assigned_treatment) %>% 
  mutate(cf_iter_data = map(cf_iter_data, sample_frac, 0.1)) %>% 
  unnest(cf_iter_data) %>% 
  ggplot(aes(v_cutoff, iter_est_mu * delta_rep)) +
  geom_point(aes(color = assigned_dist), alpha = 0.05) +
  scale_color_viridis_c() +
  facet_wrap(vars(assigned_treatment)) +
  NULL
```

```{r, eval=FALSE}
cf_prob_z_b_zd$STRUCTURAL_SALIENCE %>% 
  filter(assigned_treatment == mu_assigned_treatment) %>% 
  mutate(cf_iter_data = map(cf_iter_data, sample_frac, 0.1)) %>% 
  unnest(cf_iter_data) %>% 
  ggplot(aes(v_cutoff, iter_est_mu * delta_rep)) +
  geom_point(aes(color = iter_est_mu), alpha = 0.05) +
  geom_rug(aes(v_cutoff), inherit.aes = FALSE,
           alpha = 0.05,
           sides = "b") +
  scale_color_viridis_c() +
  labs(x = TeX("$v^*(z,b)$"), y = TeX("$R(z,b) = \\mu_z\\Delta(v^*(z,b))$")) +
  facet_wrap(vars(assigned_treatment)) +
  NULL
```

```{r, eval=FALSE}
cf_prob_z_b_zd$STRUCTURAL_SALIENCE %>% 
  filter(assigned_treatment == mu_assigned_treatment) %>% 
  mutate(cf_iter_data = map(cf_iter_data, sample_frac, 0.1)) %>% 
  unnest(cf_iter_data) %>% 
  ggplot(aes(v_cutoff, iter_est)) +
  geom_point(aes(color = assigned_dist), alpha = 0.1) +
  scale_color_viridis_c() +
  facet_wrap(vars(assigned_treatment)) +
  NULL
```

```{r, eval=FALSE}
cf_prob_z_b_zd$STRUCTURAL_SALIENCE %>% 
  filter(assigned_treatment == mu_assigned_treatment) %>% 
  mutate(cf_iter_data = map(cf_iter_data, sample_frac, 0.1)) %>% 
  unnest(cf_iter_data) %>% 
  ggplot(aes(assigned_dist, v_cutoff)) +
  geom_point(aes(color = assigned_dist), alpha = 0.1) +
  scale_color_viridis_c() +
  facet_wrap(vars(assigned_treatment)) +
  NULL
```

```{r, eval=FALSE}
cf_prob_z_b_zd$STRUCTURAL_SALIENCE %>% 
  select(assigned_treatment, mu_assigned_treatment, cf_iter_data, starts_with("assigned_dist")) %>% 
  filter(assigned_treatment == mu_assigned_treatment) %>% 
  pivot_wider(names_from = c(assigned_treatment, mu_assigned_treatment), values_from = cf_iter_data) %>% 
  mutate(cf_diff = map2(bracelet_bracelet, control_control, inner_join, by = "iter_id", suffix = c("_bracelet", "_control")) %>% 
           map(transmute, iter_id, diff_prob = prob_bracelet - prob_control),
         mean_diff = map_dbl(cf_diff, ~ mean(.$diff_prob)),
         diff_quantiles = map(cf_diff, quantilize_est, diff_prob, quant_probs) %>% 
            map(mutate, per = str_c("per_", per)) %>% 
            map(pivot_wider, names_from = per, values_from = est)) %>% 
  select(-bracelet_bracelet, -control_control) %>% 
  ggplot(aes(assigned_dist, mean_diff)) +
  geom_line() +
  geom_ribbon(aes(ymin = per_0.25, ymax = per_0.75), alpha = 0.25, data = . %>% unnest(diff_quantiles)) +
  geom_ribbon(aes(ymin = per_0.1, ymax = per_0.9), alpha = 0.25, data = . %>% unnest(diff_quantiles)) +
  geom_ribbon(aes(ymin = per_0.05, ymax = per_0.95), alpha = 0.25, data = . %>% unnest(diff_quantiles)) +
  geom_hline(yintercept = 0, linetype = "dotted")
```

# Model Checking

## Cross Validation

```{r, eval=FALSE}
load("stan_analysis_data/takeup_model_cv_cv.RData")
```

```{r, eval=FALSE}
dist_kfold[[1]]$value %>% {
  mutate(kfold_compare(x = .),
         stacking_weight = map(., pluck, "pointwise") %>% 
           do.call(rbind, .) %>% 
           t() %>% 
           stacking_weights())
}

```

```{r, eval=FALSE}
dist_kfold$STRUCTURAL_SALIENCE$value %>%
  kfold() %>% 
  lst(reduced = takeup_kfold, struct = .) %>% 
  kfold_compare(x = .)
```

```{r}
dist_kfold %>% 
  magrittr::extract(names(model_names)) %>%
  compact() %>% { 
    comparison <- kfold_compare(x = .) 
    stacking_weight <- map(., pluck, "pointwise") %>% 
      do.call(rbind, .) %>% 
      t() %>% 
      stacking_weights()
    
    comparison %>%  
      mutate(model = str_replace_all(model, set_names(model_names, map_chr(names(model_names), ~ str_c("^", ., "$")))) %>% 
               str_replace("\n", " "),
             stacking_weight)
  }
```

```{r, eval=FALSE}
dist_kfold %>% 
  magrittr::extract(names(model_names)) %>%
  map(pluck, "pointwise") %>% 
  do.call(rbind, .) %>% 
  t() %>% 
  stacking_weights()
```


```{r}
```

<!-- # Diagnostics -->

```{r, eval=FALSE}
dist_fit %>% iwalk(~ { cat(rep("-", 40), str_interp("\n${.y}:\n")); check_hmc_diagnostics(.x) })
```

<!-- ## Divergent Transitions -->

```{r,eval=FALSE}
color_scheme_set("darkgray")

fit_post <- map(dist_fit, as.array) %>% 
  map(~ magrittr::extract(., (seq(nrow(.)) %% 2) == 0 ,,)) # Need to think out the iterations to fit in memory
fit_np <- map(dist_fit, nuts_params)
```

```{r, fig.width=10, eval=FALSE}
mcmc_parcoord(
  fit_post$STRUCTURAL_SALIENCE, np = fit_np$STRUCTURAL_SALIENCE, 
  pars = c("beta_control", "beta_ink_effect", "beta_calendar_effect", "beta_bracelet_effect", 
           "beta_salience", "dist_beta_salience", "dist_quadratic_beta_salience",
           "v_mu"), 
  regex_pars = c("^beta\\[", "^mu_rep\\[",
                 "^dist_beta_v\\[", "^dist_quadratic_beta_v\\["),
  np_style = parcoord_style_np(div_color = "red", div_size = 0.3, div_alpha = 0.5),
  alpha = 0.1
)
```

```{r, fig.width=12, eval=FALSE}
mcmc_parcoord(
  fit_post[[1]], np = fit_np[[1]], 
  regex_pars = c("mu_cluster_effects_raw\\[2", "mu_cluster_effects_sd", "^mu_rep\\[", "cluster_mu_rep\\[2,[1-2]", "beta", "dist_beta_v"),
  np_style = parcoord_style_np(div_color = "red", div_size = 0.1, div_alpha = 0.125),
  alpha = 0.5
)
```

```{r, fig.width=10, eval=FALSE}
mcmc_pairs(
  fit_post[[1]], np = fit_np[[1]], 
 pars = c("mu_cluster_effects_raw[2,2]", "mu_cluster_effects_sd[2]"),
 regex_pars = c("^mu_rep\\[[1-2]", "cluster_mu_rep\\[2,[1-2]"))
```

```{r, fig.width=10, eval=FALSE}
mcmc_pairs(
  fit_post[[1]], np = fit_np[[1]], 
  pars = c("dist_beta_county_raw[2,1]", "dist_beta_county_sd[1]", "mu_cluster_effects_raw[2,2]", "mu_cluster_effects_sd[2]"),
  regex_pars = c("^mu_rep_raw")
)
```

```{r, eval=FALSE}
mcmc_pairs(fit_post[[1]], np = fit_np[[1]], pars = c("beta_control", "beta_ink_effect", "beta_calendar_effect", "beta_bracelet_effect"))
mcmc_pairs(fit_post$STRUCTURAL_SALIENCE, np = fit_np$STRUCTURAL_SALIENCE, regex_pars = c("^beta\\["))
```

```{r, eval=FALSE}
mcmc_pairs(fit_post$STRUCTURAL_SALIENCE, np = fit_np$STRUCTURAL_SALIENCE, 
           pars = c("structural_beta_cluster[1,1]", "structural_beta_cluster_sd[1]",
                    "structural_beta_cluster[2,2]", "structural_beta_cluster_sd[2]"))
```

```{r, eval=FALSE}
mcmc_pairs(fit_post$STRUCTURAL_SALIENCE, np = fit_np$STRUCTURAL_SALIENCE, 
           pars = c("structural_beta_county[1,1]", "structural_beta_county_sd[1]",
                    "structural_beta_county[2,2]", "structural_beta_county_sd[2]"))
```

# Comparison with Reduced Form Model

```{r, eval=FALSE}
load("stan_analysis_data/takeup_model_4_always_predict_processed.RData")
```

```{r, eval=FALSE}
summ_level_mean %>% 
  unnest(est_percentiles) %>% 
  filter(per == 0.5, fct_match(cluster_treatment, c("control", "bracelet")), is.na(subgroup_for)) %>% 
  select(cluster_treatment, dist_pot_treatment, per, est)

summ_te_mean %>% 
  unnest(est_percentiles) %>% 
  filter(per == 0.5, fct_match(cluster_treatment_left, "bracelet"), fct_match(cluster_treatment_right, "control"), is.na(subgroup_for)) %>% 
  select(starts_with("cluster_treatment"), starts_with("dist_pot_treatment"), est)
```

```{r, eval=FALSE}
summ_level_mean %>% 
  unnest(est_percentiles) %>% 
  filter(per == 0.5, fct_match(cluster_treatment, c("control", "bracelet")), subgroup_for == "level", fct_match(subgroup_by, "cluster")) %>% 
  select(cluster_id = subgroup_id, cluster_treatment, dist_pot_treatment, per, est)
```

\newpage
\blandscape

```{r, fig.width=16, fig.height=10, fig.cap="Comparing the fit of all the models."}
structural_param %>% 
  magrittr::extract(names(model_names)) %>%
  bind_rows(.id = "model") %>% 
  left_join(distinct(nosms_data, cluster_id, old_cluster_id = cluster.id), by = c("obs_index" = "cluster_id")) %>% 
  ggplot(aes(assigned_dist)) +
  geom_crossbar(aes(y = prop_takeup, ymin = prop_takeup_lb, ymax = prop_takeup_ub), color = "lightgrey", size = 0.5, width = 80,
                data = observed_takeup) +
  geom_pointrange(aes(y = per_0.5, ymin = per_0.25, ymax = per_0.75, color = model), size = 0.5, fatten = 0.75, position = position_dodge(width = 75), 
                  data = . %>% unnest(quantiles_est_takeup_prob)) +
  geom_vline(xintercept = 1250, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  facet_wrap(vars(assigned_treatment), ncol = 1, labeller = as_labeller(str_to_title)) +
  labs(
    x = "Assigned Distance",
    y = "",
    title = "Observed and fitted village level take-up"
  ) +
  NULL
```

```{r, fig.width=16, fig.height=10, fig.cap="Comparing the fit of the structural and reduced-form models.", eval=FALSE}
load("stan_analysis_data/takeup_model_4_always_predict.RData")

structural_param %>% 
  bind_rows(.id = "model_type") %>% 
  left_join(distinct(nosms_data, cluster_id, old_cluster_id = cluster.id), by = c("obs_index" = "cluster_id")) %>% 
  left_join(
   summ_level_mean %>% 
     filter(subgroup_for == "level", fct_match(subgroup_by, "cluster")) %>% 
     left_join(distinct(stan_data$prepared_analysis_data, 
                        cluster_id, 
                        obs_dist_pot_treatment = dist_pot_treatment, 
                        obs_assigned_treatment = assigned.treatment, 
                        old_cluster_id = cluster.id), 
               by = c("subgroup_id" = "cluster_id")) %>% 
     filter(obs_dist_pot_treatment == dist_pot_treatment, obs_assigned_treatment == cluster_treatment) %>% 
     select(old_cluster_id, cluster_treatment, dist_pot_treatment, est_percentiles),
   
   by = c("old_cluster_id"), #, "assigned_treatment" = "cluster_treatment") 
  ) %>% 
  mutate(
    assigned_treatment = fct_relabel(assigned_treatment, str_to_title),
    est_percentiles = map(est_percentiles, pivot_wider, names_from = per, values_from = est, names_prefix = "per_"),
    combined_percentiles = map2(quantiles_est_takeup_prob, est_percentiles, ~ bind_rows(struct = .x, reduced = .y, .id = "model"))
  ) %>% 
  filter(fct_match(assigned_treatment, c("Control", "Bracelet", "Ink"))) %>% 
  ggplot(aes(assigned_dist)) +
  # geom_crossbar(aes(y = prop_takeup, ymin = prop_takeup_lb, ymax = prop_takeup_ub, color = "Observed"), size = 0.5, width = 30, alpha = 0.125) +
  geom_crossbar(aes(y = prop_takeup, ymin = prop_takeup_lb, ymax = prop_takeup_ub), color = "lightgrey", size = 0.5, width = 30) +
  # geom_pointrange(aes(y = per_0.5, ymin = per_0.25, ymax = per_0.75, color = "Estimated"), size = 0.5, fatten = 0.75, data = . %>% unnest(quantiles_est_takeup_prob)) +
  geom_pointrange(aes(y = per_0.5, ymin = per_0.25, ymax = per_0.75, color = assigned_treatment), size = 0.5, fatten = 0.75, position = position_dodge(width = 10),
                  data = . %>% unnest(combined_percentiles)) +
  # geom_smooth(aes(y = per_0.5, color = assigned_treatment, linetype = assigned_treatment), method = lm, se = FALSE,
  #                 data = . %>% unnest(combined_percentiles)) +
  geom_vline(xintercept = 1250, linetype = "dotted") +
  # facet_wrap(vars(assigned_treatment), ncol = 1) +
  facet_wrap(vars(model), ncol = 1, labeller = as_labeller(c("reduced" = "Reduced Form Model", "struct" = "Structural Causal Model"))) +
  # facet_grid(rows = vars(model_type), cols = vars(assigned_treatment)) +
  # scale_color_manual("", values = c(Observed = "darkred", Estimated = "black")) +
  scale_color_discrete("Assigned Treatment") +
  labs(
    x = "Assigned Distance",
    y = "",
    title = "Observed and Fitted Village Level Take-up"
  ) +
  theme_minimal() +
  NULL
```

\elandscape
\newpage