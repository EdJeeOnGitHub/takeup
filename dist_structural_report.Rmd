---
title: "Structural Distance Model Results"
output:
  pdf_document:
    number_sections: yes
  html_notebook:
    fig_caption: yes
header-includes:
  - \usepackage[table,dvipsnames]{xcolor}
  - \usepackage{pxfonts}
  - \usepackage{bbm}
  - \usepackage{amsmath,amsfonts,amssymb}
  - \usepackage{mathtools}
  - \usepackage{subfig}
  - \usepackage{tikz}
  - \usepackage{booktabs}
  - \usepackage{multirow}
  - \usepackage{float}
  - \usepackage{pdflscape}
  - \newcommand{\blandscape}{\begin{landscape}}
  - \newcommand{\elandscape}{\end{landscape}}
---

```{r setup, include=FALSE}
library(magrittr)
library(tidyverse)
library(rstan)
library(loo)
library(bayesplot)
library(latex2exp)
library(ggdag)
library(nleqslv)
library(parallel)
library(pbmcapply)
library(ggstance)
library(ggridges)
library(latex2exp)
library(withr)

options(mc.cores = 12)
rstan_options(auto_write = TRUE)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, cache=TRUE)

ggplot2::theme_set(theme_minimal())
```

```{r util-scripts, cache=FALSE}
source("analysis_util.R")
source(file.path("multilvlr", "multilvlr_util.R"))
source("dist_structural_util.R")
```

```{r load-reduced-form-results, cache=FALSE, eval=FALSE}
reduced_form_env <- new.env()
load(file.path("stan_analysis_data", "takeup_model_4_always_predict_processed.RData"), envir = reduced_form_env)
```


```{r load-data}
# load(file.path("stan_analysis_data", "dist_fit21.RData"))
load(file.path("temp-data", "processed_dist_fit26.RData")) 
```

\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,petri,calc}

# Model

Define the following variables:

* $Z \in \{\textrm{control, ink, calendar, bracelet}\}$, village assigned incentive/signal treatment.
* $G \in \{\textrm{close, far}\}$, is the village assigned distance group to deworming treatment.
* $D \in \mathbb{R}^+$, is the actual village distance to deworming treatment.

<!-- \widetilde{Y}_{zd} &= \beta_z - \delta_1 \times d - \delta_2 \times d^2 + \mu_z \cdot \Delta^*_{zd} + \overbrace{u_B + u_R + u_Y + v}^{u} \\ -->

Our model of take-up is
\begin{align*}
\widetilde{Y}_{zd} &= \beta_z - c(d) + \mu_z \cdot \Delta^*_{zd} + \overbrace{u_B + u_R + u_Y + v}^{u} \\
\nonumber \\
Y_{zd} &= \mathbbm{1}(\widetilde{Y}_{zd} > 0), 
\end{align*}
where $\widetilde{Y}_{zd}$ is the latent utility in response to assigned incentive treatment $z$ and distance to deworming treatment $d$, $c(d)$ is the cost function in response to distance to deworming $d$,  and $Y_{zd}$ is a binary indicator of deworming take-up. 

\[\Delta^*_{zd} = \Delta(V^*_{zd}) = E[V | V > V^*_{zd}] - E[V | V < V^*_{zd}]\] 
is the reputational utility of signaling, where the variable $V \sim N(0, 1)$ is the latent prosocial type and $V^*_{zd}$ is the cutoff prosocial level, in response to $z$ and $d$, such that
<!-- \[ V^*_{zd} = - \beta_z + \delta_1 \times d + \delta_2 \times d^2 - \mu_z \cdot \Delta(V^*_{zd}). \] -->
\[ V^*_{zd} = - \beta_z + \delta_d - \mu_z \cdot \Delta(V^*_{zd}). \]
$\mu_z > 0$ is a coefficient combining the observability of the signal $z$ and the social value placed on deworming.

To faciliate our discussion of counterfactuals, we use a graphical model to the causal relationship between the different structural components of the take-up decision making process. This model is defined as $\mathcal{M} = \langle \mathcal{U,W,F} \rangle$, where:

1. $\mathcal{U} = \{U_D, U_B, U_R, U_Y, V\}$, are the background variables. $U_D, U_B, U_R,$ and $U_Y$ are background variables affecting $D$, $B, R,$ and $Y$, respectively, while $V$ is the prosocial type described above. We model $U_D$ as independent of the other background variables. We use $U^*$ to represent the combination of $\{U_B, U_R, U_Y, V\}$.
  
2. $\mathcal{W} = \{Z, G, D, \bar{B}, B, R, Y\}$, are the observed and unobserved endogenous variable determined by other variables in the model, $\mathcal{U} \cup \mathcal{W}$.

    i) $Z$, $G$ and $D$ as above.
    ii) $\bar{B}$ is the latent consumption utility of incentives, excluding any individual level background, while $B = \bar{B} + U_B$.
    iii) $R$ is the latent reputational utility.
    iv) $Y$ is a binary variable indicating take-up.
    
3. $\mathcal{F} = \{f_D, f_{\bar{B}}, f_B, f_R, f_Y\}$, are the set of functions such that, for each $W_i \in \mathcal{W}$, it is determined from its parent variables $PA_i\subseteq \mathcal{W}\setminus W_i$ and the latent background variable $R_i$. 

The directed acyclic graph for this model is show in Figure \ref{fig:dag}. 

\begin{figure}
\centering
\begin{tikzpicture}
  [ 
    node distance=2cm,
    line width=1.25,
    every label/.append style={font=\Large},
    observed/.style={circle,fill=black,inner sep=0pt,minimum size=3mm},
    latent/.style={circle,draw=black,inner sep=0pt,minimum size=3mm},
    latent-edge/.style={->,dashed},
    place/.style={circle,draw=blue!50,fill=blue!20,thick,
    inner sep=0pt,minimum size=6mm},
    transition/.style={rectangle,draw=black!50,fill=black!20,thick,
    inner sep=0pt,minimum size=4mm}
  ]

\node[observed] (Y) [label=above:$Y$] {};
\node[latent] (R) [label=120:$R$,left=of Y] {}
  edge[->] (Y);
\node[latent] (B) [label=below:$B$,below=of R] {}
  edge[->] (Y);
\node[latent] (Bbar) [label=below:$\bar{B}$,left=of B] {}
  edge[->] (R)
  edge[->] (B);
\node[observed] (D) [label=below:$D$,left=of Bbar] {}
  edge[->] (Bbar);
\node[observed] (G) [label=left:$G$,left=of D] {}
  edge[->] (D);
\node[latent] (U_D) [label=below:$U_D$,above=of G] {}
  edge[latent-edge] (D);
\node[observed] (Z) [label=above:$Z$,above=of D] {}
  edge[->] (R)
  edge[->] (Bbar);
\node[latent] (U) [label=60:$U^*$,right=of Y] {}
  edge[latent-edge,bend right=60] (R)
  edge[latent-edge] (Y)
  edge[latent-edge,bend left=30] (B);
\end{tikzpicture}
\caption{Causal diagram of how private (consumption) utility and signaling (reputational) utility affect take-up. Filled points represent observable variables while hollow points represent latent variables. Dashed arrows represent the effect of background variables.}
\label{fig:dag}
\end{figure}

The functions in $\mathcal{F}$ are defined as

  <!-- \bar{b} &= f_{\bar{B}}(z, d) = \beta_z + \delta_1 \times d + \delta_2 \times d^2 \\ -->

\begin{align*}
  d &= f_D(g, u_G) = \alpha_g + u_G \\ 
  \bar{b} &= f_{\bar{B}}(z, d) = \beta_z - c(d) \\
  b &= f_{B}(\bar{b}, u_B) = \bar{b} + u_B \\
  r &= f_{R}(z, \bar{b}, u_R) = \mu_z \cdot \Delta^*_{z,\bar{b}} + u_R \\
  y &= f_Y(b, r, u_Y) = \mathbbm{1}(b + r + u_Y + v > 0)
\end{align*}

We will consider a number of models:

* Reduced form models, in which we eliminate the reputational component of the model: we restrict $\mu_z = 0$. We consider the following reduced form models: 

    i) **Discrete cost model**, we use a discrete specification for cost, such that we only use the $G$ to represent distance. This means the cost function is \[ c(g) = \delta_g. \]
    ii) **Semiparameteric cost model**, in which we use splines to model the continuous cost function.
    
* Structural models, in which the only restriction we place on $\mu_z$ is $\mu_\textrm{ink},\mu_\textrm{calendar},\mu_\textrm{bracelet} \geq \mu_\textrm{control} \geq 0$. We consider the following structural models:

    i) **Quadratic cost model**, where \[c(d) = \delta_1 \times d + \delta_2 \times d^2,\] with the restriction that $\delta_1,\delta_2 \geq 0$.
    ii) **Semiparameteric cost model**, in which we use splines to model the continuous cost function.
    iii) **Quadratic cost with salience model**, where cost is quadratic as above, and in addition, we add a salience term to capture any effects due to the signals' observability that is not reputational: \[c(z,d) = \delta_1 \times d + \delta_2 \times d^2 + \gamma\cdot \mu_z\times d,\] with $\delta_1,\delta_2,\gamma \geq 0$.

```{r, eval=FALSE}
dagitty::dagitty("dag {
                    Z -> R <- B
                    Z -> B -> Y <- V
                    R -> Y
                    D -> B
                    
                    Z[exposure]
                    D[exposure]
                    R[latent]
                    B[latent]
                    Y[outcome]
                  }") %>% 
  tidy_dagitty() %>%
  ggdag() +
  theme_dag_blank() +
  NULL
```

<!-- ## Statistical Parametres -->

<!-- We model parameters as -->

<!-- \begin{align} -->
<!--   \beta_j &\sim \mathtt{Normal(\beta, \sigma_\beta)} \\ -->
<!--   \beta_z &\sim \mathtt{Normal(0, 1)}, z \in \{\textrm{control, ink, calendar}\} \\ -->
<!--   \beta_\textrm{bracelet} &\sim \beta_\textrm{calendar} - \mathtt{HalfNormal(0, 1)} \\ -->
<!--   \tau_\beta &\sim \mathtt{HalfNormal}(0, 1) \\ -->
<!--   \\ -->
<!--   \boldsymbol{\delta} &\sim \mathtt{MultiNormal}(\mathbf{0}, \mathsf{diag}(1)) \\ -->
<!--   \\ -->
<!--   \mu_z &\sim \mathtt{HalfNormal}(0, 1) -->
<!-- \end{align} -->

# Analysis

```{r}
plot_pos <- position_dodgev(height = 0.75)

model_colors <- RColorBrewer::brewer.pal(nrow(dist_fit_data), "Dark2") 
# model_colors <- RColorBrewer::brewer.pal(length(dist_fit), "Dark2") 
  # set_names(c(names(dist_fit), "OLD_REDUCED_FORM"))

# model_names <- c(
#   "REDUCED_FORM_NO_RESTRICT" = "Reduced Form Discrete Cost", #\nWith No Incentive Restrictions",
#   "REDUCED_FORM_SEMIPARAM" = "Reduced Form Semiparametric Cost",
#   
#   # "REDUCED_FORM_LINEAR" = "Reduced Form Linear",
#   
#   # "STRUCTURAL_QUADRATIC_NO_RESTRICT" = "Structural Quadratic Cost",
#   # "STRUCTURAL_SEMIPARAM_NO_RESTRICT" = "Structural Semiparametric Cost"
#   
#   # "STRUCTURAL_QUADRATIC" = "Structural Quadratic Cost",
#   # "STRUCTURAL_SEMIPARAM" = "Structural Semiparametric Cost"
#   
#   "STRUCTURAL_LINEAR" = "Structural Linear"
#   
#   # "STRUCTURAL_QUADRATIC_SALIENCE" = "Structural Quadratic Cost\nWith Salience"
#   # "STRUCTURAL_SEMIPARAM_NO_REP" = "Reduced Form Semiparametric Single Cost"
#   # "OLD_REDUCED_FORM" = "Old Discrete Cost"
# )
# 
# dist_fit <- dist_fit %>% magrittr::extract(intersect(names(model_names), names(.)))
```


```{r params, eval=FALSE}
quant_probs <- c(0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99)

total_error_sd <- map(dist_fit, extract_obs_fit_level, stan_data = stan_data, par = "total_error_sd", iter_level = "none")

cluster_dist_cost <- map(dist_fit, extract_obs_fit_level, par = "cluster_dist_cost", stan_data = stan_data, iter_level = "cluster", quant_probs = quant_probs) 

net_benefit <- map(dist_fit, extract_obs_fit_level, par = "structural_cluster_benefit_cost", stan_data = stan_data, iter_level = "cluster", quant_probs = quant_probs) 

v_cutoff <- map(dist_fit, extract_obs_fit_level, par = "structural_cluster_obs_v", stan_data = stan_data, iter_level = "cluster", quant_probs = quant_probs) 

takeup_prob <- map(dist_fit, extract_obs_fit_level, par = "structural_cluster_takeup_prob", stan_data = stan_data, iter_level = "cluster", mix = TRUE, quant_probs = quant_probs) 

structural_beta <- map(dist_fit, extract_obs_fit_level, par = "beta", stan_data = stan_data, iter_level = "treatment", mix = FALSE, quant_probs = quant_probs) 
dist_beta_v <- map(dist_fit, extract_obs_fit_level, par = "dist_beta_v", stan_data = stan_data, iter_level = "treatment", mix = FALSE, quant_probs = quant_probs) 

mu_rep <- dist_fit %>% 
  map(extract_obs_fit_level, par = "mu_rep", stan_data = stan_data, iter_level = "treatment", mix = FALSE, quant_probs = quant_probs) %>% 
  map_if(~ !is_null(.), mutate, compare_to = "control") %>% 
  map_if(~ !is_null(.), ~ left_join(., select(., assigned_treatment, iter_data), by = c("compare_to" = "assigned_treatment"), suffix = c("", "_compare"))) %>% 
  map_if(~ !is_null(.),
      mutate, 
      iter_data = map2(iter_data, iter_data_compare, left_join, by = "iter_id", suffix = c("", "_compare")) %>% 
        map(mutate, 
            iter_est_vs_compare = iter_est - iter_est_compare,
            iter_est_vs_compare_ratio = iter_est / iter_est_compare,
            per = if_else(rank(iter_est) %in% c((n() + 1) %/% 2, ((n() + 1) %/% 2) + ((n() + 1) %% 2)), 0.5, NA_real_)
        ) %>% 
        map2(quantiles_est, ~ mutate(.x, 
                                     per_group = unlist(.y) %>%
                                       set_names(str_extract(names(.), "0\\.\\d+")) %>% { 
                                         cut(iter_est, breaks = c(0, ., Inf), labels = c("0.0", names(.))) } %>% 
                                       as.numeric())),
      mean_est_vs_compare = map_dbl(iter_data, ~ mean(.$iter_est_vs_compare)),
      mean_est_vs_compare_ratio = map_dbl(iter_data, ~ mean(.$iter_est_vs_compare_ratio)),
      quantiles_est_vs_compare = map(iter_data, quantilize_est, iter_est_vs_compare, quant_probs = quant_probs), 
      quantiles_est_vs_compare_ratio = map(iter_data, quantilize_est, iter_est_vs_compare_ratio, quant_probs = quant_probs)
  )

reduced_mu_rep <- map_if(mu_rep, ~ !is_null(.), mutate, iter_data = map(iter_data, arrange, iter_est) %>% map(filter, (row_number() %% 100) == 0))

observed_takeup <- monitored_nosms_data %>% 
  group_by(cluster_id, assigned_treatment = assigned.treatment, assigned_dist = cluster.dist.to.pot) %>% 
  summarize(prop_takeup = mean(dewormed), 
            se = sqrt(prop_takeup * (1 - prop_takeup) / n()),
            prop_takeup_ub = prop_takeup + se,
            prop_takeup_lb = prop_takeup - se) %>% 
  ungroup()

structural_param <- pmap(lst(cluster_dist_cost, net_benefit, v_cutoff, takeup_prob, mu_rep),
                         function(cluster_dist_cost, net_benefit, v_cutoff, takeup_prob, mu_rep) {
                           inner_join(net_benefit, v_cutoff, by = c("obs_index", "assigned_treatment", "assigned_dist", "assigned_dist_standard"), suffix = c("", "_v_cutoff")) %>% 
                             inner_join(cluster_dist_cost, 
                                        by = c("obs_index", "assigned_treatment", "assigned_dist", "assigned_dist_standard"), 
                                        suffix = c("", "_cluster_dist_cost")) %>% { 
                               if (!is_null(mu_rep)) {
                                 inner_join(., takeup_prob, by = c("obs_index", "assigned_treatment", "assigned_dist", "assigned_dist_standard"), suffix = c("", "_takeup_prob")) %>% 
                                   left_join(., mu_rep, by = c("assigned_treatment"), suffix = c("_net_benefit", "_mu_rep")) 
                               } else {
                                 inner_join(., 
                                            takeup_prob, 
                                            by = c("obs_index", "assigned_treatment", "assigned_dist", "assigned_dist_standard"), 
                                            suffix = c("_net_benefit", "_takeup_prob")) 
                               }
                             } %>% 
                              mutate(
                                iter_data = map2(iter_data_net_benefit, iter_data_v_cutoff, inner_join, by = "iter_id", suffix = c("", "_v_cutoff")) %>% {
                                  if (!is_null(mu_rep)) {
                                    map2(., iter_data_takeup_prob, inner_join, by = "iter_id", suffix = c("", "_takeup_prob")) %>% 
                                      map2(iter_data_mu_rep, left_join, by = "iter_id", suffix = c("_net_benefit", "_mu_rep")) 
                                  } else {
                                    map2(., iter_data_takeup_prob, inner_join, by = "iter_id", suffix = c("_net_benefit", "_takeup_prob"))  
                                  }
                                } %>%  
                                  map(mutate, 
                                      iter_est_rep = - iter_est_v_cutoff - iter_est_net_benefit)
                              ) %>% 
                              left_join(select(observed_takeup, -c(assigned_treatment, assigned_dist)), by = c("obs_index" = "cluster_id")
                              )
                         })

group_dist_param <- dist_fit[[1]] %>% 
  as.data.frame(pars = c("group_dist_mean", "group_dist_sd", "group_dist_mix")) %>% 
  sample_n(1500) %>% 
  mutate(iter_id = seq(n())) %>% 
  pivot_longer(names_to = c(".value", "assigned_dist_group", "mix_index"), names_pattern = "([^\\[]+)\\[(\\d),(\\d)", cols = -iter_id) %>% 
  mutate(assigned_dist_group = factor(assigned_dist_group, levels = 1:2, labels = stan_data$cluster_treatment_map[, 2, drop = TRUE] %>% levels()))
```

```{r, fig.width=8, fig.cap="Fit and observed distance to deworming treatment, conditional on assigned distance group.", eval=FALSE}
dist_fit_data$fit[[1]] %>% 
  as.data.frame(pars = c("group_dist_mean", "group_dist_sd", "group_dist_mix")) %>% 
  sample_n(1500) %>% 
  mutate(iter_id = seq(n())) %>% 
  pivot_longer(names_to = c(".value", "assigned_dist_group", "mix_index"), names_pattern = "([^\\[]+)\\[(\\d),(\\d)", cols = -iter_id) %>% 
  mutate(assigned_dist_group = factor(assigned_dist_group, levels = 1:2, labels = stan_data$cluster_treatment_map[, 2, drop = TRUE] %>% levels())) %>% 
  group_by(assigned_dist_group, mix_index) %>%
  mutate(distrib_samples = map2(group_dist_mean, group_dist_sd,
                                ~ tibble(x = seq(-500, 3000, 10),
                                         density = dnorm(x, mean = ..1 * ..3, sd = ..2 * ..3)),
                                original_dist_sd = sd(stan_data$analysis_data$cluster.dist.to.pot))) %>%
  ungroup() %>% 
  select(iter_id:mix_index, group_dist_mix, distrib_samples) %>% 
  pivot_wider(id_cols = c(iter_id, assigned_dist_group), names_from = mix_index, values_from = c(group_dist_mix, distrib_samples)) %>% 
  mutate(distrib_samples = map2(distrib_samples_1, distrib_samples_2, inner_join, by = "x", suffix = c("_1", "_2")) %>% 
           map2(group_dist_mix_1, ~ mutate(.x, density = .y * density_1 + (1 - .y) * density_2))) %>% 
  select(-distrib_samples_1, -distrib_samples_2) %>% 
  unnest(distrib_samples) %>% 
  ggplot() +
  geom_line(aes(x, density, group = iter_id, color = "Posterior Samples"), alpha = 0.008) +
  geom_freqpoly(aes(x = cluster.dist.to.pot, y = stat(density), color = "Observed Sample Frequency"),
                 binwidth = 200,
                 data = stan_data$analysis_data %>% distinct(cluster_id, assigned_dist_group = dist.pot.group, cluster.dist.to.pot)) +
  scale_color_manual("", values = c("Posterior Samples" = "black", "Observed Sample Frequency" = "firebrick3")) +
  labs(
    title = "Fit and observed distance to deworming treatment, conditional on assigned distance group (g).",
    x = "Distance",
    y = "",
    caption = "The observed sample distance frequency plot was calculated using bins of width 200 meters.
               Posterior sample distributions are shown using 1,500 iterations."
  ) +
  coord_cartesian(xlim = c(0, 3000)) +
  theme(axis.text.y = element_blank()) +
  facet_wrap(vars(assigned_dist_group), ncol = 1, labeller = as_labeller(. %>% str_c("g = ", .))) +
  NULL
```


```{r cf, eval=FALSE}
cluster_cf_benefit_cost <- map2(dist_fit, c(1, 1, 4), ~ extract_obs_cf(.x, par = "cluster_cf_benefit_cost", stan_data = stan_data, iter_level = "cluster", quant_probs = quant_probs, thin = .y))  
cluster_cf_benefit_cost <- map2(dist_fit, 8, ~ extract_obs_cf(.x, par = "cluster_cf_benefit_cost", stan_data = stan_data, iter_level = "cluster", quant_probs = quant_probs, thin = .y))  

# cluster_cf_benefit_cost %>% map(summarize_at, vars(starts_with("ess")), min) 

cluster_cf_benefit_cost %<>%
# cluster_cf_benefit_cost %<>%
  map(select, -starts_with("ess"), -one_of("rhat")) %>% 
  map(nest, iter_data = c(treatment_index, obs_num_takeup, matches("^assigned_(treatment|dist_group)$"), iter_data)) %>% 
  map(mutate, iter_data = map(iter_data, unnest, iter_data)) %>% 
  lst(benefit_cost = ., mu_rep, total_error_sd) %>%
  pmap(function(benefit_cost, mu_rep, total_error_sd) {
    if (!is_null(mu_rep)) {
      mutate(benefit_cost, 
             iter_data = pbmclapply(mc.cores = 12,
                                    iter_data, 
                                    left_join, 
                                    unnest(mu_rep, iter_data) %>% 
                                      select(mu_assigned_treatment = assigned_treatment, iter_id, iter_est) %>%  
                                      inner_join(total_error_sd, by = c("iter_id"), suffix = c("_mu", "_error_sd")),
                                    by = c("iter_id")) %>% 
               map(mutate, obs_num_takeup = if_else(assigned_treatment == mu_assigned_treatment, obs_num_takeup, NA_integer_)))
    } else {
      mutate(benefit_cost, 
             iter_data = pbmclapply(mc.cores = 12,
                                    iter_data, 
                                    inner_join, 
                                    total_error_sd, 
                                    by = c("iter_id"), 
                                    suffix = c("", "_error_sd")) %>% 
               map(mutate, mu_assigned_treatment = NA_character_, iter_est_mu = 0))
    } 
  }) %>% 
  map(
    mutate,
    iter_data = pbmclapply(mc.cores = 12,
                           iter_data,
                           function(curr_iter_data) {
                             mutate(
                               curr_iter_data,
                               no_rep_prob = pnorm(iter_est, sd = iter_est_error_sd),
                               v_cutoff = map2_dbl(iter_est, iter_est_mu, ~ nleqslv(x = - ..1, fn = generate_v_cutoff_fixedpoint(..1, ..2)) %>% pluck("x")),
                               delta_rep = rep_normal(v_cutoff), 
                               prob = pnorm(- v_cutoff, sd = iter_est_error_sd)
                             )
                           }) %>% 
      lst(iter_data = ., cluster_size) %>%
      pmap(~ mutate(..1, iter_num_takeup = if_else(!is.na(obs_num_takeup), obs_num_takeup, rbinom(n(), ..2, prob))))
  ) %>% 
  map(mutate, iter_data = map(iter_data, group_by_at, vars(treatment_index, matches("^(mu_)?assigned_(treatment|dist_group)$"), obs_num_takeup)) %>% 
        map(group_nest,  .key = "iter_data")) %>% 
  map(unnest, iter_data)  

est_takeup_level <- cluster_cf_benefit_cost %>% 
  map(
    function(.data) {
      .data %>%
        select(
          cluster_id, 
          assigned_treatment, assigned_dist_group, mu_assigned_treatment, 
          assigned_dist_obs, assigned_treatment_obs, assigned_dist_group_obs, cluster_size, 
          iter_data
        ) %>% 
        mutate(iter_data = map(iter_data, select, iter_id, prob, iter_num_takeup)) %>%
        unnest(iter_data) %>% 
        group_by(iter_id, mu_assigned_treatment, assigned_treatment, assigned_dist_group) %>% 
        summarize(iter_prop_takeup = sum(iter_num_takeup) / sum(cluster_size)) %>% 
        ungroup() %>% 
        nest(iter_data = c(iter_id, iter_prop_takeup)) %>%
        mutate(
          mean_est = map_dbl(iter_data, ~ mean(.$iter_prop_takeup)),
          takeup_quantiles = map(iter_data, quantilize_est, iter_prop_takeup, wide = TRUE, quant_probs = c(quant_probs))
        ) %>% 
        unnest(takeup_quantiles)
    })

ate_combo <- est_takeup_level$STRUCTURAL_LINEAR %>% 
  select(mu_assigned_treatment:assigned_dist_group) %>% {
    bind_cols(rename_all(., str_c, "_left"), rename_all(., str_c, "_right")) 
  } %>%
  expand(crossing(!!!syms(names(.)))) %>% 
  filter(mu_assigned_treatment_left != mu_assigned_treatment_right |
           assigned_treatment_left != assigned_treatment_right |
           (fct_match(assigned_dist_group_left, "far") & fct_match(assigned_dist_group_right, "close")))

est_takeup_te <- est_takeup_level %>% 
  map(select, mu_assigned_treatment:assigned_dist_group, iter_data) %>%
  map(select_if, ~ !all(is.na(.))) %>% # Get rid of the NA mu_assigned_treatment in the reduced form results 
  map(function(level_data) {
    present_col <- intersect(names(level_data), c("mu_assigned_treatment", "assigned_treatment", "assigned_dist_group"))
    
    left_data <- inner_join(select(ate_combo, str_c(rep(present_col, each = 2), c("_left", "_right"))) %>% 
                              distinct_all(.keep_all = TRUE),
                            level_data,
                            by = present_col %>% set_names(str_c(.,"_left")))
    
    inner_join(left_data,
               level_data,
               by = present_col %>% set_names(str_c(., "_right")),
               suffix = c("_left", "_right"))
  }) %>% 
  map_if(
    ~ any(str_detect(names(.), "mu_assigned_treatment")),
    ~ filter(., 
      mu_assigned_treatment_left != mu_assigned_treatment_right |
      assigned_treatment_left != assigned_treatment_right |
      assigned_dist_group_left != assigned_dist_group_right),
    .else = ~ filter(., 
      assigned_treatment_left != assigned_treatment_right |
      assigned_dist_group_left != assigned_dist_group_right)) %>% 
  map(mutate, iter_data = map2(iter_data_left, iter_data_right, inner_join, by = "iter_id", suffix = c("_left", "_right")) %>% 
        map(mutate, iter_takeup_te = iter_prop_takeup_left - iter_prop_takeup_right)) %>% 
  map(select, -iter_data_left, -iter_data_right) %>% 
  map(mutate, 
      mean_est = map_dbl(iter_data, ~ mean(.$iter_takeup_te)),
      takeup_te_quantiles = map(iter_data, quantilize_est, iter_takeup_te, wide = TRUE, quant_probs = c(quant_probs))) %>% 
  map(unnest, takeup_te_quantiles)

est_takeup_dist_te <- est_takeup_te %>% 
  map_if(~ any(str_detect(names(.), "mu_assigned_treatment")), filter, mu_assigned_treatment_left == assigned_treatment_left, mu_assigned_treatment_right == assigned_treatment_right) %>% 
  map_if(~ any(str_detect(names(.), "mu_assigned_treatment")), select, -starts_with("mu_assigned_treatment")) %>% 
  map(filter, assigned_treatment_left == assigned_treatment_right, fct_match(assigned_dist_group_left, "far"), fct_match(assigned_dist_group_right, "close")) %>% 
  map(mutate, assigned_treatment_right = "control") %>% 
  map(select, -mean_est, -starts_with("per_"), -starts_with("assigned_dist_group")) %>% 
  map(~ inner_join(., select(., -assigned_treatment_right), by = c("assigned_treatment_right" = "assigned_treatment_left"), suffix = c("_left", "_right"))) %>% 
  map(filter, assigned_treatment_left != assigned_treatment_right) %>% 
  map(mutate, iter_data = map2(iter_data_left, iter_data_right, inner_join, by = "iter_id", suffix = c("_left", "_right")) %>% 
        map(transmute, iter_id, iter_takeup_dist_te = iter_takeup_te_left - iter_takeup_te_right)) %>% 
  map(select, -iter_data_left, -iter_data_right) %>% 
  map(mutate, 
      mean_est = map_dbl(iter_data, ~ mean(.$iter_takeup_dist_te)),
      takeup_te_quantiles = map(iter_data, quantilize_est, iter_takeup_dist_te, wide = TRUE, quant_probs = quant_probs)) %>% 
  map(unnest, takeup_te_quantiles)

# est_bbar_vs_takeup <- cluster_cf_benefit_cost %>% 
#   map(filter, !is.na(obs_num_takeup)) %>% 
#   map(mutate, iter_data = map2(iter_data, assigned_treatment, 
#                                ~ if (is.factor(.x$mu_assigned_treatment)) filter(.x, fct_match(mu_assigned_treatment, c("control", as.character(.y)))) else .x))

# save(cluster_cf_benefit_cost, file = file.path("temp-data", "cluster_cf_benefit_cost.RData"))

save(est_takeup_level, est_takeup_te, est_takeup_dist_te, file = file.path("temp-data", "est_takeup.RData")) 
```

```{r, eval=FALSE}
load(file.path("temp-data", "cluster_cf_benefit_cost.RData"))
```

```{r, eval=FALSE}
load(file.path("temp-data", "est_takeup.RData"))
```

```{r, fig.width=8, fig.height=5, fig.cap="Take-up levels in response to an incentive treatment intervention.", eval=FALSE}
est_takeup_level %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  filter(is.na(mu_assigned_treatment) | assigned_treatment == mu_assigned_treatment) %>%
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
    labs(
      title = "Take-up levels in response to an incentive treatment intervention",
      subtitle = TeX("E\\[Y_{z}\\]"),
      x = "Take-up Probability",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  coord_cartesian(xlim = c(0, 0.6)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8, fig.height=4.25,fig.cap="Take-up levels in response to a signaling intervention, holding the private consumption utility at the control level.", eval=FALSE}
est_takeup_level %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  filter(fct_match(assigned_treatment, "control"), !is.na(mu_assigned_treatment)) %>%
  ggplot(aes(x = per_0.5, y = mu_assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete(TeX("Assigned Signaling Treatment (z')"), labels = str_to_title) +
    labs(
      title = "Take-up levels in response to a signaling intervention,\nholding the private consumption utility at the control level",
      subtitle = TeX("E\\[Y_{z=control,\\bar{B}_{z'}}\\]"),
      x = "Take-up Probability",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  coord_cartesian(xlim = c(0, 0.6)) + 
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r,fig.width=8,fig.height=10,eval=FALSE}
reduced_form_results <- with(
  reduced_form_env,
  summ_level_mean %>%
    filter(is.na(subgroup_by)) %>% 
    select(assigned_treatment = cluster_treatment, dist.pot.group = dist_pot_treatment, est_percentiles) %>% 
    mutate(
      mu_assigned_treatment = assigned_treatment,
      est_percentiles = map(est_percentiles, pivot_wider, names_from = per, values_from = est, names_prefix = "per_")
    ) %>% 
    unnest(est_percentiles)
)

est_takeup_level[c("REDUCED_FORM", "REDUCED_FORM_NO_RESTRICT")] %>%
  bind_rows(.id = "model") %>% 
  select(-starts_with("per_"), -mean_est, -iter_data) %>% 
  unnest(dist_group_data) %>% 
  filter(is.na(mu_assigned_treatment) | assigned_treatment == mu_assigned_treatment) %>%
  bind_rows(reduced_form_results %>% mutate(model = "OLD_REDUCED_FORM")) %>%
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model), position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
    labs(
      title = "Take-up Levels, split by assignd distance to treatment",
      subtitle = TeX("E\\[Y_{z} | D \\in{}D^*\\]"),
      x = "Take-up Probability",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  coord_cartesian(xlim = c(0, 0.6)) +
  facet_wrap(vars(dist.pot.group), ncol = 1, labeller = as_labeller(. %>% str_to_title() %>% str_c("D^* = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8,fig.height=10, fig.cap="Take-up levels in response to an incentive treatment intervention, split by assigned distance group."}
dist_fit_data %>%
  mutate(est_takeup_level = map(est_takeup_level, filter, is.na(mu_assigned_treatment) | mu_assigned_treatment == assigned_treatment)) %>%  
  select(est_takeup_level, model, model_name) %>% 
  unnest(est_takeup_level) %>% 
  # magrittr::extract(names(model_names)) %>% 
  # bind_rows(.id = "model") %>% 
  # mutate(model = factor(model, levels = names(model_names))) %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model_name), position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model_name), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model_name), width = 0.4, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model_name), fatten = 3, size = 0.8, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.01, xmax = per_0.99, color = model_name), linetype = "dotted", fatten = 3, size = 0.75, position = plot_pos) +
  geom_point(aes(x = mean_est, color = model_name), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors) + #, labels = model_names) +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
    labs(
      title = "Take-up levels in response to an incentive treatment intervention,\nsplit by assigned distance group",
      subtitle = TeX("E\\[Y_{zg}\\]"),
      x = "Take-up Probability",
      caption = "Dotted line range: 98% credible interval. Line range: 90% credible interval. 
                 Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  # coord_cartesian(xlim = c(0, 0.6)) +
  coord_cartesian(xlim = c(0, 1)) +
  facet_wrap(vars(assigned_dist_group), ncol = 1) +
  # facet_wrap(vars(assigned_dist_group), ncol = 1, labeller = as_labeller(. %>% str_c("g = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8,fig.height=7, fig.cap="Take-up levels in response to a signaling intervention, holding the private consumption utility at the control level, and split by assigned distance group.", eval=FALSE}
est_takeup_level %>%
  keep(~ any(!is.na(.$mu_assigned_treatment))) %>% 
  map(filter, fct_match(assigned_treatment, "control")) %>% 
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  ggplot(aes(x = per_0.5, y = mu_assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete(TeX("Assigned Signaling Treatment (z')"), labels = str_to_title) +
    labs(
      title = "Take-up levels in response to a signaling intervention,\nholding the private consumption utility at the control level,\nand split by assigned distance group",
      subtitle = TeX("E\\[Y_{z=control,\\bar{B}_{z'}} | G = g\\]"),
      x = "Take-up Probability",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  coord_cartesian(xlim = c(0, 0.6)) +
  facet_wrap(vars(assigned_dist_group), ncol = 1, labeller = as_labeller(. %>% str_c("g = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8, fig.height=4.5, fig.cap="Average treatment effect on take-up, compared to control.",eval=FALSE}
est_takeup_te %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  filter(
    is.na(mu_assigned_treatment) | assigned_treatment == mu_assigned_treatment,
    (!is.na(mu_compare_to) & (assigned_treatment != compare_to |  assigned_treatment != mu_compare_to)) |
       (is.na(mu_compare_to) & assigned_treatment != compare_to)  
  ) %>%
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
    labs(
      title = "Average treatment effect on take-up, compared to control",
      subtitle = TeX("E\\[Y_{z}\\] - E\\[Y_{control}\\]"),
      x = "Average Treatment Effect",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8, fig.height=4, fig.cap="Average treatment effect of signaling holding consumption utility at the control level, compared to control.", eval=FALSE}
est_takeup_te %>%
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  filter(
    fct_match(assigned_treatment, "control"),
    !is.na(mu_assigned_treatment),
    assigned_treatment != mu_assigned_treatment,
  ) %>%
  ggplot(aes(x = per_0.5, y = mu_assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete("Assigned\nSignaling Treatment (z')", labels = str_to_title) +
    labs(
      title = "Average treatment effect of signaling holding consumption utility at the control level,\ncompared to control",
      subtitle = TeX("E\\[Y_{z=control,\\bar{B}_{z'}}\\] - E\\[Y_{control}\\]"),
      x = "Average Treatment Effect",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8,fig.height=6,eval=FALSE}
reduced_form_te_results <- with(
  reduced_form_env,
  summ_te_mean %>% 
    filter(
      is.na(subgroup_by),
      cluster_treatment_right == "control",
      dist_pot_treatment_left == dist_pot_treatment_right,
    ) %>% 
    select(assigned_treatment = cluster_treatment_left, dist.pot.group = dist_pot_treatment_left, est_percentiles) %>% 
    mutate(
      mu_assigned_treatment = assigned_treatment,
      est_percentiles = map(est_percentiles, pivot_wider, names_from = per, values_from = est, names_prefix = "per_")
    ) %>% 
    unnest(est_percentiles)
)

est_takeup_te[c("REDUCED_FORM", "REDUCED_FORM_NO_RESTRICT")] %>%
  bind_rows(.id = "model") %>% 
  select(-starts_with("per_"), -mean_est, -iter_data) %>% 
  unnest(dist_group_data) %>% 
  filter(
    is.na(mu_assigned_treatment) | assigned_treatment == mu_assigned_treatment,
    (!is.na(mu_compare_to) & (assigned_treatment != compare_to |  assigned_treatment != mu_compare_to)) |
       (is.na(mu_compare_to) & assigned_treatment != compare_to)  
  ) %>%
  bind_rows(mutate(reduced_form_te_results, model = "OLD_REDUCED_FORM")) %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
    labs(
      title = TeX("E\\[Y_{z} | D \\in{}D^*\\] - E\\[Y_{control} | D \\in{}D^*\\]"),
      x = "Average Treatment Effect",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  facet_wrap(vars(dist.pot.group), ncol = 1, labeller = as_labeller(. %>% str_to_title() %>% str_c("D^* = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8,fig.height=9, fig.cap="Average treatment effect in response to an incentive treatment intervention, split by assigned distance group."}
dist_fit_data %>% 
  mutate(est_takeup_te =
# est_takeup_te %>%
    map_if(est_takeup_te, ~ any(str_detect(names(.), "mu_assigned_treatment")), filter, mu_assigned_treatment_left == assigned_treatment_left, mu_assigned_treatment_right == assigned_treatment_right) %>% 
    map(filter, 
        (is.na(assigned_dist_group_left) & is.na(assigned_dist_group_right)) | assigned_dist_group_left == assigned_dist_group_right,
        assigned_treatment_left != assigned_treatment_right,
        fct_match(assigned_treatment_right, c("control", "calendar")))) %>% 
  select(model, model_name, est_takeup_te) %>% 
  unnest(est_takeup_te) %>%
  mutate_at(vars(starts_with("assigned_dist_group")), fct_explicit_na, "Combined") %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment_left, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  # ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.01, xmax = per_0.99, color = model), linetype = "dotted", fatten = 3, size = 0.75, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, size = 0.8, position = plot_pos) +
  geom_point(aes(x = mean_est, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
  scale_color_manual("Model", values = model_colors, labels = dist_fit_data %>% select(model, model_name) %>% deframe()) + #, labels = model_names) +
    labs(
      title = "Average treatment effect in response to an incentive treatment intervention,\nsplit by assigned distance group", 
      subtitle = TeX("E\\[Y_{zg}\\] - E\\[Y_{control,g}\\]"),
      x = "Average Treatment Effect",
      caption = "Dotted line range: 98% credible interval. Line range: 90% credible interval. 
                 Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  facet_grid(rows = vars(assigned_dist_group_left), cols = vars(assigned_treatment_right), labeller = as_labeller(. %>% str_c("g = ", .) %>% TeX(), default = label_parsed)) +
  # facet_wrap(vars(assigned_dist_group_left), ncol = 1) + #, labeller = as_labeller(. %>% str_c("g = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical",
        panel.border = element_rect(colour = "darkgrey", fill = NA)) +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8,fig.height=9, fig.cap="Average treatment effect in response to a change is assigned distance to treatment, split by assigned incentive treatment."}
est_takeup_te %>%
  map_if(~ any(str_detect(names(.), "mu_assigned_treatment")), filter, mu_assigned_treatment_left == assigned_treatment_left, mu_assigned_treatment_right == assigned_treatment_right) %>% 
  map(filter, assigned_treatment_left == assigned_treatment_right, fct_match(assigned_dist_group_left, "far"), fct_match(assigned_dist_group_right, "close")) %>% 
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment_left, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  # ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.01, xmax = per_0.99, color = model), linetype = "dotted", fatten = 3, size = 0.75, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, size = 0.8, position = plot_pos) +
  geom_point(aes(x = mean_est, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
    labs(
      title = "Average treatment effect in response to an incentive treatment intervention,\nsplit by assigned distance group", 
      subtitle = TeX("E\\[Y_{z,g=far}\\] - E\\[Y_{z,g=close}\\]"),
      x = "Average Treatment Effect",
      caption = "Dotted line range: 98% credible interval. Line range: 90% credible interval. 
                 Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=9,fig.height=9, fig.cap="Average difference in the average treatment effect in response to a change in assigned distance to treatment, compared against the control average treatment effect."}
dist_fit_data %>% 
  select(est_takeup_dist_te, model) %>% 
  unnest(est_takeup_dist_te) %>% 
  # magrittr::extract(names(model_names)) %>% 
  # bind_rows(.id = "model") %>% 
  # mutate(model = factor(model, levels = names(model_names))) %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment_left, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  # ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.01, xmax = per_0.99, color = model), linetype = "dotted", fatten = 3, size = 0.75, position = plot_pos) +
  ggstance::geom_linerangeh(aes(xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, size = 0.8, position = plot_pos) +
  geom_point(aes(x = mean_est, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_y_discrete("Assigned Treatment (z)", labels = str_to_title) +
  scale_color_manual("Model", values = model_colors) + #, labels = model_names) +
    labs(
      title = "Average difference in the average treatment effect in response to a change in\nassigned distance to treatment, compared against the control average treatment effect",
      subtitle = TeX("(E\\[Y_{z,g=far}\\] - E\\[Y_{z,g=close}\\]) - (E\\[Y_{control,g=far}\\] - E\\[Y_{control,g=close}\\])"),
      x = "Average Treatment Effect",
      caption = "Dotted line range: 98% credible interval. Line range: 90% credible interval. 
                 Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=8, fig.height=7, fig.cap="Average treatment effect of signaling holding consumption utility at the control level, compared to control, and split by assigned distance group."}
est_takeup_te %>% 
  keep(~ any(str_detect(names(.), "mu_assigned_treatment"))) %>% 
  map(
    filter, 
    mu_assigned_treatment_left != mu_assigned_treatment_right, 
    fct_match(mu_assigned_treatment_right, "control"),
    assigned_dist_group_left == assigned_dist_group_right, 
    assigned_treatment_left == assigned_treatment_right,  assigned_treatment_right == "control"
  ) %>% 
  magrittr::extract(names(model_names)) %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = factor(model, levels = names(model_names))) %>% 
  ggplot(aes(x = per_0.5, y = mu_assigned_treatment_left, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  scale_y_discrete("Assigned Signaling Treatment (z')", labels = str_to_title) +
    labs(
      title = "Average treatment effect of signaling holding consumption utility at the control level,\ncompared to control, and split by assigned distance group",
      subtitle = TeX("E\\[Y_{z=control,g,\\bar{B}_{z'}}\\] - E\\[Y_{z=control,g}\\]"),
      x = "Average Treatment Effect",
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.") +
  facet_wrap(vars(assigned_dist_group_left), ncol = 1, labeller = as_labeller(. %>% str_c("g = ", .) %>% TeX(), default = label_parsed)) +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=10, eval=FALSE}
est_bbar_vs_takeup %>% 
  unnest(iter_data) %>% 
  # ggplot(aes(iter_est, prob)) +
  ggplot(aes(iter_est, v_cutoff)) +
  geom_point(aes(color = iter_est_mu), alpha = 0.05) +
  scale_color_viridis_c() + 
  facet_grid(row = vars(mu_assigned_treatment), cols = vars(assigned_treatment)) +
  NULL
```

```{r, eval=FALSE}
cluster_cf_benefit_cost$REDUCED_FORM_NO_RESTRICT %>% 
  group_nest(assigned_treatment, assigned_dist_group, .key = "treatment_data") %>% 
  mutate(treatment_data = map(treatment_data, unnest, iter_data) %>% 
           map(group_by, iter_id) %>% 
           map(summarize, iter_prop_takeup = sum(iter_num_takeup) / sum(cluster_size)) %>% 
           map(ungroup)) %>% 
  mutate(compare_assigned_treatment = assigned_treatment) %>% 
  left_join(., ., by = c("compare_assigned_treatment" = "assigned_treatment"), suffix = c("_left", "_right")) %>% 
  filter(assigned_dist_group_left != assigned_dist_group_right) %>% 
  mutate(
    te_data = map2(treatment_data_left, treatment_data_right, inner_join, .x, .y, by = c("iter_id"), suffix = c("_left", "_right")) %>% 
      map(mutate, iter_te = iter_prop_takeup_left - iter_prop_takeup_right),
    te_quantiles = map(te_data, quantilize_est, iter_te, quant_probs = quant_probs)
  ) %>% 
  select(-starts_with("treatment_data")) %>% 
  filter(assigned_dist_group == "far")
```

## Model Parameters

```{r, fig.height=5, fig.width=8, fig.cap="Reputational coefficient levels."}
dist_fit_data %>% 
  select(model, model_name, mu_rep) %>% 
  unnest(mu_rep) %>% 
# mu_rep %>%
#   compact %>% 
#   magrittr::extract(names(model_names)) %>% 
#   bind_rows(.id = "model") %>% 
#   mutate(model = factor(model, levels = names(model_names))) %>% 
  mutate(assigned_treatment = fct_relabel(assigned_treatment, str_to_title)) %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos,
                           data = . %>%  unnest(quantiles_est)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos,
                           data = . %>%  unnest(quantiles_est)) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos,
                             data = . %>%  unnest(quantiles_est)) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors) + #, labels = model_names) +
  labs(y = "Assigned Treatment (z)",
       x = TeX("Reputational Returns Coefficient ($\\mu_z$)"),
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.",
       title = "Reputational Returns Cofficients") +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.height=4, fig.width=8, fig.cap="Comparing reputational returns coefficient to control."}
dist_fit_data %>% 
  select(model, model_name, mu_rep) %>% 
  unnest(mu_rep) %>% 
  filter(!fct_match(assigned_treatment, "control")) %>% 
  mutate(assigned_treatment = fct_relabel(assigned_treatment, str_to_title)) %>% 
  ggplot(aes(x = per_0.5, y = assigned_treatment, group = model)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.25, xmax = per_0.75, color = model), width = 0.25, position = plot_pos,
                           data = . %>%  unnest(quantiles_est)) +
  ggstance::geom_crossbarh(aes(xmin = per_0.1, xmax = per_0.9, color = model), width = 0.4, position = plot_pos,
                           data = . %>%  unnest(quantiles_est)) +
  ggstance::geom_pointrangeh(aes(x = mean_est, xmin = per_0.05, xmax = per_0.95, color = model), fatten = 3, position = plot_pos,
                             data = . %>%  unnest(quantiles_est)) +
  geom_point(aes(x = mean_est), color = "white", size = 0.75, position = plot_pos) +
  geom_vline(xintercept = 0, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors) + 
  labs(y = "Assigned Treatment (z)",
       x = TeX("Reputational Returns Coefficient Compared to Control ($\\mu_z - \\mu_{control}$)"),
      caption = "Line range: 90% credible interval. Outer box: 80% credible interval. Inner box: 50% credible interval. 
                 Thick vertical line: median. Point: mean.",
       title = "Reputational Returns Cofficients") +
  theme(legend.position = "top", legend.direction = "vertical") +
  guides(color = guide_legend(ncol = 3)) +
  NULL
```

```{r, fig.width=12, fig.height=6, eval=FALSE}
structural_param %>%
  bind_rows(.id = "model_type") %>% 
  mutate(assigned_treatment = fct_relabel(assigned_treatment, str_to_title)) %>%
  ggplot(aes(assigned_dist)) +
  # geom_line(aes(y = mean_est_super_net_benefit), color = "darkgrey") +
  # geom_ribbon(aes(ymin = per_0.25, ymax = per_0.75), alpha = 0.25,
  #                 data = . %>% unnest(quantiles_est_super_net_benefit)) +
  geom_pointrange(aes(y = per_0.5, ymin = per_0.1, ymax = per_0.9), size = 0.5, fatten = 0.5, alpha = 0.75,
                  data = . %>% unnest(quantiles_est_net_benefit)) +
  facet_grid(rows = vars(model_type), cols = vars(assigned_treatment)) +
  theme_minimal() +
  labs(
    x = "Assigned Distance",
    y = TeX("Direct Benefit"),
    title = "Direct Benefits",
    caption = "Points: median cluster direct benefit at assigned distance
               Vertical line: cluster direct benefit 50% credible interval
               Line plot: mean cluster direct benefit net cluster effects
               Grey ribbon: cluster direct benefit net cluster effects 50% credible interval"
  ) +
  NULL
```

```{r, fig.width=12, fig.height=6, fig.cap="Distance cost."}
structural_param %>%
  magrittr::extract(setdiff(names(model_names), c("REDUCED_FORM_NO_RESTRICT", "STRUCTURAL_SEMIPARAM_NO_REP"))) %>% 
  bind_rows(.id = "model") %>% 
  mutate(
    model = factor(model, levels = names(model_names)),
    assigned_treatment = fct_relabel(assigned_treatment, str_to_title)
  ) %>%
  ggplot(aes(assigned_dist)) +
  geom_line(aes(y = mean_est_cluster_dist_cost, group = assigned_treatment, color = assigned_treatment)) +
  geom_point(aes(y = mean_est_cluster_dist_cost, group = assigned_treatment, color = assigned_treatment)) +
  facet_wrap(vars(model), nrow = 1, labeller = as_labeller(model_names)) +
  scale_color_brewer("Assigned Treatment", palette = "Set2") +
  theme_minimal() +
  labs(
    x = "Assigned Distance",
    y = TeX("Cost"),
    title = "Cost"
    # caption = "Points: median cluster direct benefit at assigned distance
    #            Vertical line: cluster direct benefit 50% credible interval
    #            Line plot: mean cluster direct benefit net cluster effects
    #            Grey ribbon: cluster direct benefit net cluster effects 50% credible interval"
  ) +
  NULL
```

```{r, fig.width=12, fig.cap="Reputational cutoff as a function of consumption benefit.", eval=FALSE}
structural_param %>% 
  magrittr::extract(setdiff(names(model_names), c("REDUCED_FORM_NO_RESTRICT", "STRUCTURAL_SEMIPARAM_NO_REP"))) %>%
  bind_rows(.id = "model") %>% 
  unnest(iter_data) %>% 
  mutate(
    model = factor(model, levels = names(model_names)),
    assigned_treatment = fct_relabel(assigned_treatment, str_to_title)
  ) %>%
  ggplot(aes(iter_est_net_benefit, iter_est_v_cutoff)) +
  geom_point(aes(color = iter_est_mu_rep), alpha = 0.05) +
  geom_abline(intercept = 0, slope = -1, linetype = "dotted") +
  scale_color_viridis_c(TeX("Reputational\nReturns Coefficient ($\\mu_z$)")) +
  facet_grid(rows = vars(model), cols = vars(assigned_treatment), labeller = labeller(.rows = model_names)) +
  coord_fixed() +
  labs(
    title = "Reputational cutoff as a function of consumption benefit",
    x = "Direct Benefit",
    y = TeX("Prosocial Type Cutoff ($V^*$)")
  ) +
  theme(legend.position = "bottom", strip.text.y = element_text(angle = 0)) +
  NULL
```

```{r, fig.width=10, fig.height=8, fig.cap="Reputational returns as a function of reputational cutoff.", eval=FALSE}
structural_param %>% 
  bind_rows(.id = "model_type") %>% 
  unnest(iter_data) %>% 
  mutate(assigned_treatment = fct_relabel(assigned_treatment, str_to_title)) %>%
  ggplot(aes(iter_est_v_cutoff, iter_est_rep)) +
  geom_point(aes(color = iter_est_mu_rep), alpha = 0.05) +
  facet_grid(rows = vars(model_type), cols = vars(assigned_treatment), labeller = labeller(.rows = model_names)) +
  scale_color_viridis_c(TeX("Reputational\nReturns Coefficient ($\\mu_z$)")) +
  labs(
    title = "Reputational returns as a function of reputational cutoff",
    x = TeX("Prosocial Type Cutoff ($V^*$)"),
    y = "Reputational Returns (R)"
  ) +
  theme(legend.position = "bottom", strip.text.y = element_text(angle = 0)) +
  NULL
```

```{r, fig.width=16, fig.height=10, eval=FALSE}
structural_param %>% 
  bind_rows(.id = "model_type") %>% 
  mutate(assigned_treatment = fct_relabel(assigned_treatment, str_to_title)) %>%
  ggplot(aes(assigned_dist)) +
  geom_crossbar(aes(y = prop_takeup, ymin = prop_takeup_lb, ymax = prop_takeup_ub, color = "Observed"), size = 0.5, width = 60) +
  geom_pointrange(aes(y = per_0.5, ymin = per_0.25, ymax = per_0.75, color = "Estimated"), size = 0.5, fatten = 0.75, data = . %>% unnest(quantiles_est_takeup_prob)) +
  facet_wrap(vars(assigned_treatment), ncol = 2) +
  # facet_grid(rows = vars(model_type), cols = vars(assigned_treatment)) +
  scale_color_manual("", values = c(Observed = "darkred", Estimated = "black")) +
  labs(
    x = "Assigned Distance",
    y = ""
  ) +
  theme_minimal() +
  NULL
```

# Model Checking

## Cross Validation

```{r, eval=FALSE}
dist_kfold[[1]]$value %>% {
  mutate(kfold_compare(x = .),
         stacking_weight = map(., pluck, "pointwise") %>% 
           do.call(rbind, .) %>% 
           t() %>% 
           stacking_weights())
}

```

```{r, eval=FALSE}
dist_kfold$STRUCTURAL_SALIENCE$value %>%
  kfold() %>% 
  lst(reduced = takeup_kfold, struct = .) %>% 
  kfold_compare(x = .)
```

```{r}
dist_kfold %>% 
  # magrittr::extract(names(model_names)) %>%
  compact() %>% { 
    comparison <- kfold_compare(x = .) 
    stacking_weight <- map(., pluck, "pointwise") %>% 
      do.call(rbind, .) %>% 
      t() %>% 
      stacking_weights()
    
    comparison %>%  
      mutate(model = str_replace_all(model, set_names(model_names, map_chr(names(model_names), ~ str_c("^", ., "$")))) %>% 
               str_replace("\n", " "),
             stacking_weight)
  }
```

```{r, eval=FALSE}
dist_kfold %>% 
  magrittr::extract(names(model_names)) %>%
  map(pluck, "pointwise") %>% 
  do.call(rbind, .) %>% 
  t() %>% 
  stacking_weights()
```

## Posterior Prediction Checks

```{r, eval=FALSE}
rep_benefit_cost <- dist_fit %>% 
  map(extract_rep_level, "cluster_rep_benefit_cost", stan_data = stan_data) %>% 
  map(arrange, assigned_dist) %>% 
  map(mutate,
      cluster_id = factor(cluster_id, levels = cluster_id),
      obs_prop = obs_num_takeup / cluster_size) %>% 
  map(nest, iter_data = c(assigned_treatment, iter_data)) %>% 
  map(mutate, iter_data = map(iter_data, unnest, iter_data)) %>% 
  lst(benefit_cost = ., mu_rep, total_error_sd) %>%
  pmap(function(benefit_cost, mu_rep, total_error_sd) {
    if (!is_null(mu_rep)) {
      mutate(benefit_cost, 
             iter_data = pbmclapply(mc.cores = 12,
                                    iter_data, 
                                    left_join, 
                                    unnest(mu_rep, iter_data) %>% 
                                      select(mu_assigned_treatment = assigned_treatment, iter_id, iter_est) %>%  
                                      inner_join(total_error_sd, by = c("iter_id"), suffix = c("_mu", "_error_sd")),
                                    by = c("iter_id", "assigned_treatment" = "mu_assigned_treatment")))
    } else {
      mutate(benefit_cost, 
             iter_data = pbmclapply(mc.cores = 12,
                                    iter_data, 
                                    inner_join, 
                                    total_error_sd, 
                                    by = c("iter_id"), 
                                    suffix = c("", "_error_sd")) %>% 
               map(mutate, mu_assigned_treatment = NA_character_, iter_est_mu = 0))
    } 
  }) %>% 
  map(
    mutate,
    iter_data = pbmclapply(mc.cores = 12,
                           iter_data,
                           function(curr_iter_data) {
                             mutate(
                               curr_iter_data,
                               no_rep_prob = pnorm(iter_est, sd = iter_est_error_sd),
                               v_cutoff = map2_dbl(iter_est, iter_est_mu, ~ nleqslv(x = - ..1, fn = generate_v_cutoff_fixedpoint(..1, ..2)) %>% pluck("x")),
                               delta_rep = rep_normal(v_cutoff), 
                               prob = pnorm(- v_cutoff, sd = iter_est_error_sd)
                             ) %>% 
                               group_nest(assigned_treatment, .key = "iter_data")
                           }) 
  ) %>% 
  map(unnest, iter_data)
```

```{r, fig.height=16, eval=FALSE}
rep_benefit_cost %>% 
# rep_benefit_cost["STRUCTURAL_QUADRATIC"] %>% 
  bind_rows(.id = "model") %>% 
  ggplot(aes(y = cluster_id)) +
  geom_point(aes(x = obs_prop), color = "darkred") +
  geom_density_ridges(aes(prob, fill = model), quantile_lines = TRUE, quantiles = c(0.05, 0.5, 0.95), alpha = 0.25,
                      data = . %>% unnest(iter_data)) +
  labs(y = "") +
  scale_x_continuous("Takeup Prop", breaks = seq(0, 1, 0.1)) +
  facet_wrap(vars(assigned_treatment), scales = "free") + 
  theme(axis.text.y = element_blank())
```

<!-- # Diagnostics -->

```{r, eval=FALSE}
dist_fit %>% iwalk(~ { cat(rep("-", 40), str_interp("\n${.y}:\n")); check_hmc_diagnostics(.x) })
```

<!-- ## Divergent Transitions -->

```{r,eval=FALSE}
color_scheme_set("darkgray")

fit_post <- map(dist_fit, as.array) %>% 
  map(~ magrittr::extract(., (seq(nrow(.)) %% 2) == 0 ,,)) # Need to think out the iterations to fit in memory
fit_np <- map(dist_fit, nuts_params)
```

```{r, fig.width=10, eval=FALSE}
mcmc_parcoord(
  fit_post$STRUCTURAL_LINEAR, np = fit_np$STRUCTURAL_LINEAR, 
  regex_pars = c("^beta\\[", "^mu_rep\\[", "^dist_beta_v\\["),
  np_style = parcoord_style_np(div_color = "red", div_size = 0.3, div_alpha = 0.5),
  alpha = 0.1
)
```

```{r, fig.width=12, eval=FALSE}
mcmc_parcoord(
  fit_post$STRUCTURAL_LINEAR, np = fit_np$STRUCTURAL_LINEAR, 
  regex_pars = c("^beta\\[", "^mu_rep\\[", "^dist_beta_v\\["),
  # regex_pars = c("mu_cluster_effects_raw\\[2", "mu_cluster_effects_sd", "^mu_rep\\[", "cluster_mu_rep\\[2,[1-2]", "beta", "dist_beta_v"),
  np_style = parcoord_style_np(div_color = "red", div_size = 0.1, div_alpha = 0.125),
  alpha = 0.5
)
```

```{r, fig.width=10, eval=FALSE}
mcmc_pairs(
  fit_post$STRUCTURAL_LINEAR, np = fit_np$STRUCTURAL_LINEAR, 
  regex_pars = c("^beta\\[", "^mu_rep\\[", "^dist_beta_v\\[[1-2]"))
 # pars = c("mu_cluster_effects_raw[2,2]", "mu_cluster_effects_sd[2]"),
```

```{r, fig.width=10, eval=FALSE,fig.width=12}
mcmc_pairs(
  fit_post[[1]], np = fit_np[[1]], 
  regex_pars = c("^beta\\[", "^mu_rep\\[", "^dist(_quadratic)?_beta_v\\[[1-2]", "structural_beta_cluster_sd\\[[1-2]")
)
```

```{r, eval=FALSE}
mcmc_pairs(fit_post[[1]], np = fit_np[[1]], pars = c("beta_control", "beta_ink_effect", "beta_calendar_effect", "beta_bracelet_effect"))
mcmc_pairs(fit_post$STRUCTURAL_SALIENCE, np = fit_np$STRUCTURAL_SALIENCE, regex_pars = c("^beta\\["))
```

```{r, eval=FALSE}
mcmc_pairs(fit_post$STRUCTURAL_SALIENCE, np = fit_np$STRUCTURAL_SALIENCE, 
           pars = c("structural_beta_cluster[1,1]", "structural_beta_cluster_sd[1]",
                    "structural_beta_cluster[2,2]", "structural_beta_cluster_sd[2]"))
```

```{r, eval=FALSE}
mcmc_pairs(fit_post$STRUCTURAL_SALIENCE, np = fit_np$STRUCTURAL_SALIENCE, 
           pars = c("structural_beta_county[1,1]", "structural_beta_county_sd[1]",
                    "structural_beta_county[2,2]", "structural_beta_county_sd[2]"))
```

# Comparison with Reduced Form Model

```{r, eval=FALSE}
load("stan_analysis_data/takeup_model_4_always_predict_processed.RData")
```

```{r, eval=FALSE}
summ_level_mean %>% 
  unnest(est_percentiles) %>% 
  filter(per == 0.5, fct_match(cluster_treatment, c("control", "bracelet")), is.na(subgroup_for)) %>% 
  select(cluster_treatment, dist_pot_treatment, per, est)

summ_te_mean %>% 
  unnest(est_percentiles) %>% 
  filter(per == 0.5, fct_match(cluster_treatment_left, "bracelet"), fct_match(cluster_treatment_right, "control"), is.na(subgroup_for)) %>% 
  select(starts_with("cluster_treatment"), starts_with("dist_pot_treatment"), est)
```

```{r, eval=FALSE}
summ_level_mean %>% 
  unnest(est_percentiles) %>% 
  filter(per == 0.5, fct_match(cluster_treatment, c("control", "bracelet")), subgroup_for == "level", fct_match(subgroup_by, "cluster")) %>% 
  select(cluster_id = subgroup_id, cluster_treatment, dist_pot_treatment, per, est)
```

\newpage
\blandscape

```{r, fig.width=16, fig.height=10, fig.cap="Comparing the fit of all the models."}
structural_param %>% 
  magrittr::extract(names(model_names)) %>%
  bind_rows(.id = "model") %>% 
  left_join(distinct(nosms_data, cluster_id, old_cluster_id = cluster.id), by = c("obs_index" = "cluster_id")) %>% 
  ggplot(aes(assigned_dist)) +
  geom_crossbar(aes(y = prop_takeup, ymin = prop_takeup_lb, ymax = prop_takeup_ub), color = "lightgrey", size = 0.5, width = 80,
                data = observed_takeup) +
  geom_pointrange(aes(y = per_0.5, ymin = per_0.25, ymax = per_0.75, color = model), size = 0.5, fatten = 0.75, position = position_dodge(width = 75), 
                  data = . %>% unnest(quantiles_est_takeup_prob)) +
  geom_vline(xintercept = 1250, linetype = "dotted") +
  scale_color_manual("Model", values = model_colors, labels = model_names) +
  facet_wrap(vars(assigned_treatment), ncol = 1, labeller = as_labeller(str_to_title)) +
  labs(
    x = "Assigned Distance",
    y = "",
    title = "Observed and fitted village level take-up"
  ) +
  NULL
```

```{r, fig.width=16, fig.height=10, fig.cap="Comparing the fit of the structural and reduced-form models.", eval=FALSE}
load("stan_analysis_data/takeup_model_4_always_predict.RData")

structural_param %>% 
  bind_rows(.id = "model_type") %>% 
  left_join(distinct(nosms_data, cluster_id, old_cluster_id = cluster.id), by = c("obs_index" = "cluster_id")) %>% 
  left_join(
   summ_level_mean %>% 
     filter(subgroup_for == "level", fct_match(subgroup_by, "cluster")) %>% 
     left_join(distinct(stan_data$prepared_analysis_data, 
                        cluster_id, 
                        obs_dist_pot_treatment = dist_pot_treatment, 
                        obs_assigned_treatment = assigned.treatment, 
                        old_cluster_id = cluster.id), 
               by = c("subgroup_id" = "cluster_id")) %>% 
     filter(obs_dist_pot_treatment == dist_pot_treatment, obs_assigned_treatment == cluster_treatment) %>% 
     select(old_cluster_id, cluster_treatment, dist_pot_treatment, est_percentiles),
   
   by = c("old_cluster_id"), #, "assigned_treatment" = "cluster_treatment") 
  ) %>% 
  mutate(
    assigned_treatment = fct_relabel(assigned_treatment, str_to_title),
    est_percentiles = map(est_percentiles, pivot_wider, names_from = per, values_from = est, names_prefix = "per_"),
    combined_percentiles = map2(quantiles_est_takeup_prob, est_percentiles, ~ bind_rows(struct = .x, reduced = .y, .id = "model"))
  ) %>% 
  filter(fct_match(assigned_treatment, c("Control", "Bracelet", "Ink"))) %>% 
  ggplot(aes(assigned_dist)) +
  # geom_crossbar(aes(y = prop_takeup, ymin = prop_takeup_lb, ymax = prop_takeup_ub, color = "Observed"), size = 0.5, width = 30, alpha = 0.125) +
  geom_crossbar(aes(y = prop_takeup, ymin = prop_takeup_lb, ymax = prop_takeup_ub), color = "lightgrey", size = 0.5, width = 30) +
  # geom_pointrange(aes(y = per_0.5, ymin = per_0.25, ymax = per_0.75, color = "Estimated"), size = 0.5, fatten = 0.75, data = . %>% unnest(quantiles_est_takeup_prob)) +
  geom_pointrange(aes(y = per_0.5, ymin = per_0.25, ymax = per_0.75, color = assigned_treatment), size = 0.5, fatten = 0.75, position = position_dodge(width = 10),
                  data = . %>% unnest(combined_percentiles)) +
  # geom_smooth(aes(y = per_0.5, color = assigned_treatment, linetype = assigned_treatment), method = lm, se = FALSE,
  #                 data = . %>% unnest(combined_percentiles)) +
  geom_vline(xintercept = 1250, linetype = "dotted") +
  # facet_wrap(vars(assigned_treatment), ncol = 1) +
  facet_wrap(vars(model), ncol = 1, labeller = as_labeller(c("reduced" = "Reduced Form Model", "struct" = "Structural Causal Model"))) +
  # facet_grid(rows = vars(model_type), cols = vars(assigned_treatment)) +
  # scale_color_manual("", values = c(Observed = "darkred", Estimated = "black")) +
  scale_color_discrete("Assigned Treatment") +
  labs(
    x = "Assigned Distance",
    y = "",
    title = "Observed and Fitted Village Level Take-up"
  ) +
  theme_minimal() +
  NULL
```

\elandscape
\newpage