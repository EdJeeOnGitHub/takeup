---
title: Optim
output: 
  pdf_document:
    extra_dependencies: ["amsmath", "threeparttable"]
---


```{r, include=FALSE}
knitr::opts_chunk$set(warning = TRUE, message = FALSE) 

library(tidyverse)
library(ggplot2)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk)
```

# Maximisation Problem

Suppose there are $n$ villages, indexed by $i$, and $m$ points of treatment (PoT) which we index 
by $j$:

\begin{align*}
\max \sum_{i = 1}^n \sum_{j = 1}^m &takeup_{ij} x_{ij} \\
s.t. \ \ 
\sum_{j = 1}^m y_j &\leq \overline{M} = 10 \\
    \sum_{j=1}^{m} x_{ij} &\leq 1, \forall i \\
    x_{ij} &\leq y_j, \forall i, j  \\
 x_{ij} &\in \{0,1\}, y_j \in\{0,1\}
\end{align*}


In words, $x_{ij}$ is an indicator switched on if village $i$ 'uses' point of 
treatment $j$. $y_{j}$ is an indicator switched on if PoT $j$ is open/available/funded/whatever.


Line 1 just says we maximise takeup across all individuals and clinic. Notice that 
$x_{ij}$ must be switched on for us to count the clinic-village pair's takeup in 
our maximisation problem.


Line 2 says there can be no more than $\overline{M}$ funded/chosen PoTs.

Line 3 says that each village can only use one point of treatment. That is, 
there's no return to situating another PoT just $\epsilon$ units away from the 
closest PoT - all the villagers will still use the closest PoT and demand is 
unchanged.


Line 4 just says a village cannot use an unfunded/unavailable PoT.


```{r}
generate_data = function(...){
    grid_size <- 10000
    n <- 200
    customer_locations <- data.frame(
    id = 1:n,
    x = round(runif(n) * grid_size),
    y = round(runif(n) * grid_size)
    )

    m <- 50
    warehouse_locations <- data.frame(
    id = 1:m,
    x = round(runif(m) * grid_size),
    y = round(runif(m) * grid_size)
    )
    fixedcost <- abs(round(rnorm(m, mean = grid_size/20, sd = grid_size)))
    return(
        lst(
            grid_size,
            n,
            customer_locations,
            m,
            warehouse_locations,
            fixedcost
        )
    )
}


sim_data = generate_data()


logit = function(x){
    y = exp(x)/(1 + exp(x))
    return(y)
}

demand_function = function(i, 
                           j, 
                           customer_locations, 
                           warehouse_locations, 
                           subsidy = 0){
    customer <- customer_locations[i, ]
    warehouse <- warehouse_locations[j, ]
    distance_away = sqrt((customer$x - warehouse$x)^2 + (customer$y - warehouse$y)^2)
    distance_away = distance_away*(1 - subsidy)
    max_distance = sqrt(2)*10000 # gridsize hardcoded booo
    unit_interval_distance = distance_away/max_distance - 0.5
    demand = 1 - logit(5*unit_interval_distance)
    return(demand)
}





transportcost <- function(i, j, customer_locations, warehouse_locations, subsidy = 0) {
  customer <- customer_locations[i, ]
  warehouse <- warehouse_locations[j, ]
  cost = round(sqrt((customer$x - warehouse$x)^2 + (customer$y - warehouse$y)^2))
  cost = pmax(cost*(1-subsidy), 0)
  return(cost)
}

```


```{r}

p_customer = sim_data$customer_locations %>%
    ggplot(aes(
        x = x,
        y = y
    )) +
    geom_point() +
    geom_point(
        data = sim_data$warehouse_locations, 
        color = "red", 
        shape = 17,
        size = 4) +
    theme_bw() +
    labs(
        title = "Facility Location Problem",
        subtitle = "Black dots indicate villages. Red triangles indicate potential clinic locations."
    )

p_customer


demands = map_dbl(1:50, 
    ~demand_function(i = 1, 
                     j = .x, 
                     sim_data$customer_locations,
                     sim_data$warehouse_locations)) 

demand_df = tibble(
    i = 1,
    demand = demands,
    c_x = sim_data$customer_locations[1, "x"],
    c_y = sim_data$customer_locations[1, "y"],
    w_x = sim_data$warehouse_locations$x,
    w_y = sim_data$warehouse_locations$y
) %>%
    mutate(distance = sqrt((c_x - w_x)^2 + (c_y - w_y)^2)) 

demand_df %>%
    ggplot(aes(
        x = distance, 
        y = demand
    )) +
    geom_point() +
    geom_line(alpha = 0.5) +
    theme_bw() +
    labs(
        x = "Distance",
        y = "Demand", 
        title = "Simulated Demand-Distance Curve"
    ) 

demand_df %>%
    ggplot(aes(
        x = w_x, 
        y = w_y
    )) +
    geom_point(shape = 17, color = "red", size = 4) +
    geom_point(data = demand_df[1, ], aes(x = c_x, y = c_y), size = 4) +
    geom_segment(aes(
        x = c_x, 
        xend = w_x, 
        y = c_y, 
        yend = w_y, 
        alpha = demand
    )) +
    theme_bw()
```



```{r}
define_MIPModel = function(sim_data, subsidy = 0) {
    n = sim_data$n 
    m = sim_data$m 
    customer_locations = sim_data$customer_locations
    warehouse_locations = sim_data$warehouse_locations
    fixedcost = sim_data$fixedcost

    model = MIPModel() %>%
        # 1 iff i gets assigned to warehouse j
        add_variable(x[i, j], i = 1:n, j = 1:m, type = "binary") %>%
        # 1 iff warehouse j is built
        add_variable(y[j], j = 1:m, type = "binary") %>%
        # maximize the preferences
        set_objective(
                sum_over(
                    x[i,j] * log(demand_function(
                        i,
                        j,
                        customer_locations = customer_locations,
                        warehouse_locations = warehouse_locations,
                        subsidy = subsidy
                    )), i = 1:n, j = 1:m), "max") %>%
        # every customer needs to be assigned to a warehouse
        add_constraint(sum_over(x[i, j], j = 1:m) == 1, i = 1:n) %>% 
        # if a customer is assigned to a warehouse, then this warehouse must be built
        add_constraint(x[i,j] <= y[j], i = 1:n, j = 1:m) %>%
        # there can be no more than 10 warehouses
        add_constraint(sum_over(y[j], j = 1:m) <= 15  )
    return(model)
}



```

```{r}

model = define_MIPModel(sim_data, subsidy = 0)
sm_model = define_MIPModel(sim_data, subsidy = 0.5)

result = solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))
sm_result = solve_model(sm_model, with_ROI(solver = "glpk", verbose = TRUE))

```

```{r}


clean_output = function(model_fit, data){
    matching = model_fit %>%
        get_solution(x[i,j]) %>%
        filter(value > .9) %>%  
        select(i, j) %>%
        as_tibble()
    tidy_output = matching %>%
        inner_join(data$customer_locations %>% 
                        rename(customer_x = x, customer_y = y), by = c("i" = "id")) %>% 
        inner_join(data$warehouse_locations %>%
                        rename(warehouse_x = x, warehouse_y = y), by = c("j" = "id")) %>%
        mutate( 
            fixed_cost = data$fixedcost[j]
        )
    return(tidy_output)
}

tidy_output = clean_output(
    result,
    sim_data
)
sm_tidy_output = clean_output(
    sm_result,
    sim_data
)


comp_output = bind_rows(
    tidy_output %>% mutate(type = "Original"),
    sm_tidy_output %>% mutate(type = "Subsidy")
)


calculate_pot_change = function(tidy_output_1, tidy_output_2){
    diff_1_2 = setdiff(tidy_output_1$j, tidy_output_2$j)
    diff_2_1 = setdiff(tidy_output_2$j, tidy_output_1$j)
    return(
        lst(
            diff_1_2,
            diff_2_1
        )
    )
}

diff_pot_df = calculate_pot_change(
    tidy_output_1 = tidy_output,
    tidy_output_2 = sm_tidy_output
)


sim_data$customer_locations %>%
    ggplot(aes(
        x = x,
        y = y
    )) +
    geom_point(alpha = 0.2) +
    geom_point(
        data = sim_data$warehouse_locations %>%
                mutate(
                    clinic_type = case_when(
                        id %in% diff_pot_df$diff_1_2 ~ "Removed w/ Sub",
                        id %in% diff_pot_df$diff_2_1 ~ "Added w/ Sub",
                        TRUE ~ "Unchanged"
                    )
                    ),
        aes(color = clinic_type),
        shape = 17,
        size = 4, 
        alpha = 1) +
    theme_bw() +
    labs(
        title = "Facility Location Problem",
        subtitle = "Black dots indicate villages. Red triangles indicate potential clinic locations."
    ) +
  geom_segment(
    data = comp_output, 
    aes(x = customer_x, 
        y = customer_y, 
        xend = warehouse_x, 
        yend = warehouse_y),
    alpha = 0.2) +
  facet_wrap(~type, ncol = 1)
```


```{r}
flat_sim_data = sim_data()
flat_sim_data$customer_locations$y = 1
flat_sim_data$warehouse_locations$y = 1


flat_model = define_MIPModel(flat_sim_data, subsidy = 0)
flat_sm_model = define_MIPModel(flat_sim_data, subsidy = 0.5)

flat_result = solve_model(flat_model, with_ROI(solver = "glpk", verbose = TRUE))
flat_sm_result = solve_model(flat_sm_model, with_ROI(solver = "glpk", verbose = TRUE))


```



```{r}
flat_tidy_output = clean_output(
    flat_result,
    flat_sim_data
)

flat_sm_tidy_output = clean_output(
    flat_sm_result,
    flat_sim_data
)



flat_comp_output = bind_rows(
    flat_tidy_output %>% mutate(type = "Original"),
    flat_sm_tidy_output %>% mutate(type = "Subsidy")
)

flat_diff_pot = calculate_pot_change(flat_tidy_output, flat_sm_tidy_output)

flat_sim_data$customer_locations %>%
    ggplot(aes(
        x = x,
        y = y
    )) +
    geom_point(alpha = 0.2) +
    geom_point(
        data = flat_sim_data$warehouse_locations %>%
                mutate(
                    clinic_type = case_when(
                        id %in% flat_diff_pot$diff_1_2 ~ "Removed w/ Sub",
                        id %in% flat_diff_pot$diff_2_1 ~ "Added w/ Sub",
                        TRUE ~ "Unchanged"
                    )
                    ),
        aes(color = clinic_type),
        shape = 17,
        size = 4, 
        alpha = 1) +
    theme_bw() +
    labs(
        title = "Facility Location Problem",
        subtitle = "Black dots indicate villages. Red triangles indicate potential clinic locations."
    ) +
  geom_segment(
    data = flat_comp_output, 
    aes(x = customer_x, 
        y = customer_y, 
        xend = warehouse_x, 
        yend = warehouse_y),
    alpha = 0.2) +
  facet_wrap(~type, ncol = 1)

```