---
title: "Tables"
output: 
  pdf_document:
    keep_tex: yes
header-includes:
    - \usepackage{booktabs}
    - \usepackage{longtable}
    - \usepackage{array}
    - \usepackage{multirow}
    - \usepackage{wrapfig}
    - \usepackage{float}
    - \usepackage{colortbl}
    - \usepackage{pdflscape}
    - \usepackage{tabu}
    - \usepackage{threeparttable}
    - \usepackage{threeparttablex}
    - \usepackage[normalem]{ulem}
    - \usepackage[utf8]{inputenc}
    - \usepackage{makecell}
    - \usepackage{xcolor}
params:
    fit_version: 85
    rf_fit_version: 85
    input_path: data/stan_analysis_data
    output_path: temp-data 
    optim_input_path: "optim/data/agg-log-full-many-pots"
    table_output_path: presentations/tables
    models: STRUCTURAL_LINEAR_U_SHOCKS_PHAT_MU_REP
---



```{r, "startup", include=FALSE}
library(tidyverse)
library(broom)
library(knitr)
library(kableExtra)
library(ggthemes)
library(fixest)
library(magrittr)

if (interactive()) {
    params = lst(
        fit_version = 85,
        rf_fit_version = 85,
        input_path = "data/stan_analysis_data",
        output_path = "temp-data",
        optim_input_path = "optim/data/agg-log-full-many-pots",
        table_output_path = "presentations/tables",
        models = "STRUCTURAL_LINEAR_U_SHOCKS_PHAT_MU_REP"
    )
    source(file.path("rct-design-fieldwork", "takeup_rct_assign_clusters.R"))
    source(file.path("analysis_util.R"))
    source(file.path( "dist_structural_util.R"))
    source(file.path("multilvlr", "multilvlr_util.R"))
} else {
    source(file.path("rct-design-fieldwork", "takeup_rct_assign_clusters.R"))
    source(file.path("analysis_util.R"))
    source(file.path( "dist_structural_util.R"))
    source(file.path("multilvlr", "multilvlr_util.R"))
    # source(file.path("..", "rct-design-fieldwork", "takeup_rct_assign_clusters.R"))
    # source(file.path("..", "analysis_util.R"))
    # source(file.path("..", "dist_structural_util.R"))
}

models_we_want = params$models

options(
    dplyr.show_progress = FALSE, 
    digits = 4, 
    knitr.kable.NA = '')

knitr::opts_chunk$set(
    echo = FALSE, 
    cache = TRUE, 
    warnings = FALSE,
    warning = FALSE,
    cache.path = str_glue("takeup-{params$models}-table-cache/"), 
    fig.path = str_glue("takeup-{params$models}-table-fig-cache/"), 
    fig.align = "center")

dir.create("presentations/tables", showWarnings = FALSE)

```




```{r, "load_analysis_data"}

fit_version = params$fit_version

treat_levels_c = c("control", "ink", "calendar", "bracelet")
treat_levels = c("ink", "calendar", "bracelet")
dist_levels = c("close", "far")
model_level_order = c("reduced form", "structural")

quant_probs <- c(0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99)

output_basepath = file.path(
  params$output_path,
  str_glue("output_dist_fit{params$fit_version}")
)


canva_palette_vibrant <- "Primary colors with a vibrant twist"

theme_set(theme_minimal() +
            theme(legend.position = "bottom"))

wgs.84 <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
kenya.proj4 <- "+proj=utm +zone=36 +south +ellps=clrk80 +units=m +no_defs"
if (interactive()) {
    rct.schools.data <- read_rds(file.path("data", "takeup_rct_schools.rds"))
    rct.cluster.selection <- read_rds(file.path("data", "rct_cluster_selection_2.0.rds"))
    cluster.strat.data <- read_rds(file.path("data", "takeup_processed_cluster_strat.rds"))
    load(file.path("data", "takeup_village_pot_dist.RData"))
    load(file.path("data", "analysis.RData"))
} else {
    rct.schools.data <- read_rds(file.path("data", "takeup_rct_schools.rds"))
    rct.cluster.selection <- read_rds(file.path("data", "rct_cluster_selection_2.0.rds"))
    cluster.strat.data <- read_rds(file.path("data", "takeup_processed_cluster_strat.rds"))
    load(file.path("data", "takeup_village_pot_dist.RData"))
    load(file.path("data", "analysis.RData"))
    # rct.schools.data <- read_rds(file.path("..", "data", "takeup_rct_schools.rds"))
    # rct.cluster.selection <- read_rds(file.path("..", "data", "rct_cluster_selection_2.0.rds"))
    # cluster.strat.data <- read_rds(file.path("..", "data", "takeup_processed_cluster_strat.rds"))
    # load(file.path("..", "data", "takeup_village_pot_dist.RData"))
    # load(file.path("..", "data", "analysis.RData"))
}


standardize <- as_mapper(~ (.) / sd(.))
unstandardize <- function(standardized, original) standardized * sd(original)

nosms_data <- analysis.data %>% 
  filter(sms.treatment.2 == "sms.control") %>% 
  left_join(village.centers %>% select(cluster.id, cluster.dist.to.pot = dist.to.pot),
            by = "cluster.id") %>% 
  mutate(standard_cluster.dist.to.pot = standardize(cluster.dist.to.pot)) %>% 
  group_by(cluster.id) %>% 
  mutate(cluster_id = cur_group_id()) %>% 
  ungroup()

monitored_nosms_data <- analysis.data %>% 
  filter(mon_status == "monitored", sms.treatment.2 == "sms.control") %>% 
  left_join(village.centers %>% select(cluster.id, cluster.dist.to.pot = dist.to.pot),
            by = "cluster.id") %>% 
  mutate(standard_cluster.dist.to.pot = standardize(cluster.dist.to.pot)) %>% 
  group_by(cluster.id) %>% 
  mutate(cluster_id = cur_group_id()) %>% 
  ungroup()


analysis_data <- monitored_nosms_data

```


```{r}

## Fit Loading
if (interactive()) {
    load(file.path("temp-data", str_interp("processed_dist_fit${fit_version}_lite.RData")))
} else {
    load(file.path("temp-data", str_interp("processed_dist_fit${fit_version}_lite.RData")))
    # load(file.path("..", "temp-data", str_interp("processed_dist_fit${fit_version}_lite.RData")))
}


if (params$fit_version != params$rf_fit_version) {
  # Only load structural
  dist_fit_data = dist_fit_data %>%
    filter(model %in% c(models_we_want))

  rf_env = new.env()

  with_env = function(f, e = parent.frame()) {
      stopifnot(is.function(f))
      environment(f) = e
      f
  }

  load_rf_function = function(){
      load(file.path("temp-data", str_interp("processed_dist_fit${params$rf_fit_version}_lite.RData")))
      return(dist_fit_data)
  }


  rf_fit_data = with_env(load_rf_function, rf_env)() %>%
    filter(model %in% c("REDUCED_FORM_NO_RESTRICT"))

  dist_fit_data = bind_rows(
    rf_fit_data, 
    dist_fit_data
  )

}

dist_fit_data %<>%
  left_join(tribble(
    ~ fit_type,        ~ model_color,
      "fit",           "black", 
      "prior-predict", "darkgrey",
  ), by = "fit_type") %>%
  filter(fct_match(fit_type, "fit"), fct_match(model, c(models_we_want, "REDUCED_FORM_NO_RESTRICT")))

dist_fit_data = dist_fit_data %>%
  filter(model %in% c("REDUCED_FORM_NO_RESTRICT", models_we_want))



delta <- function(v, ...) dnorm(v, ...) / ((pnorm(v, ...) * pnorm(v, ..., lower.tail = FALSE)))

belief_data = dist_fit_data %>%
  filter(fct_match(fit_type, "fit"), fct_match(model, c(models_we_want))) %>%
  pull(beliefs_results) %>%
  first() 


cols_we_want = c(
    "est_takeup_level",
    "beliefs_results",
    "wtp_results",
    "est_takeup_te",
    "est_takeup_dist_te"
)
```


## Sample Info
```{r, sample_table}


stan_data = (dist_fit_data %>%
  filter(fct_match(model_type, "structural")) %>%
  select(stan_data) %>%
  pull())[[1]]



```

```{r}

# 9,935 adults of which 2,250 adults are surveyed at baseline, 
# 3,750 adults surveyed at endline 
# and 3,935 adults selected for text messaging intervention


# KEY - surveyCTO key HH ID
# KEY.individ individual's key
# KEY.hh hh's key

# rct-design-fieldwork/takeup_field_notebook.Rmd > the randomisation, 
# cleaning of columns, baseline 

# prepare_analysis_data.R <-- look in here
# census file 


# census 40,000
# (had permission to use non-monitored)
# had the census but needed to match names using strings
# using census names was extremely messy
#     didn't improve estimates, TEs don't change, 
#     didn't want to add judgement calls on name merges so just stick to sample we 
#     know.


# random-subset for part of experiment
# in that 144 villages we did run a sub-census
# did this for logistics and so we could sample from them. 

# had self-reported deworming for all of sub-census
# some of subcensus are in endline but not in monitored sample
# but use PoT data for takeup model.

# is endline subsample of monitored sample or endline some new combined sample

# analysis_data %>%
#   select(individ.baseline.sample.pool, monitored) %>%
#   group_by(individ.baseline.sample.pool, monitored) %>%
#   summarise(
#     n = n()
#   )


# analysis_data %>%
#   select(sms.treatment.2) %>%
#   unique()

# analysis_data %>%
#   group_by(baseline = individ.baseline.sample.pool, endline) %>%
#   summarise(
#     dewormed = mean(dewormed)
#   )

# analysis_data %>%
#   group_by(baseline = individ.baseline.sample.pool, endline, monitored = true.monitored) %>%
#   summarise(
#    n = n() 
#   )

# analysis_data %>%
#   group_by(endline) %>%
#   summarise(
#     n_indiv = n_distinct(KEY.individ)
#   )

# analysis_data %>%
#   group_by(endline) %>%
#   summarise(
#    n = n() 
#   )

# analysis_data %>%
#   summarise(
#     n_analysis = n_distinct(KEY.individ)
#   )

# analysis_data %>%
#   select(contains("KEY")) %>%
#   colnames()



```


```{r}
#| balance-setup
baseline.data = baseline.data %>%
  mutate(
    baseline_neighbours_worm_knowledge = case_when(
      neighbours_worms_affect == "yes" ~ TRUE, 
      neighbours_worms_affect == "no" ~ FALSE
    )
  )

baseline.data = baseline.data %>%
  mutate(
    schooling_years_plus = case_when(
      str_detect(school, "Primary") ~ 0, 
      str_detect(school, "Secondary") ~ 8, 
      str_detect(school, "College") ~ 16, 
      str_detect(school, "University") ~ 16
    ), 
    digits_schooling = str_extract(school, "\\d+") %>% as.numeric(), 
    years_schooling = digits_schooling + schooling_years_plus, 
    years_schooling = if_else(school == "Never gone to school", 0, years_schooling), 
    years_schooling = if_else(str_detect(school, "College|University"), 16, years_schooling)
  ) %>%
  select(-digits_schooling, schooling_years_plus)

baseline.data = baseline.data %>%
  mutate(
    treated_digit = str_extract(treated_when, "\\d+") %>% as.numeric, 
    treated_months = case_when(
      str_detect(treated_when, "year") ~ 12, 
      str_detect(treated_when, "mon") ~ 1, 
      TRUE ~ NA_real_
    )
    ) %>%
    mutate(
      months_since_treatment = treated_digit*treated_months
    ) %>%
    select(-treated_digit, -treated_months)

baseline.data = baseline.data %>%
  mutate(
    have_phone_lgl = case_when(
      have_phone == "Yes" ~ TRUE, 
      have_phone == "No" ~ FALSE, 
      TRUE ~ NA
    ), 
    treated_lgl = case_when(
      treated == "yes" ~ TRUE, 
      treated == "no" ~ FALSE, 
      TRUE ~ NA
    ), 
  )
baseline.data = baseline.data %>%
  mutate(
    all_can_get_worms = map_lgl(who_worms, ~any(str_detect(.x, "everyone") | (str_detect(.x, "adult") & str_detect(.x, "child")))), 
    correct_when_treat = map_lgl(when_treat, ~any(.x == "every 6 months")), 
    know_deworming_stops_worms = map_lgl(stop_worms, ~any(.x == "medicine"))
  ) 



cluster_treat_df = analysis_data %>%
  mutate(
      treat_dist = paste0(
      "treat: ", 
      assigned.treatment,
      ", dist: ", dist.pot.group
      ) %>% factor()
  ) %>%
  select(cluster.id, treat_dist) %>%
  unique()

baseline_balance_data = baseline.data %>%
  inner_join(
    cluster_treat_df, 
    by = "cluster.id"
  )

baseline_vars = c(
  "years_schooling", 
  "know_deworming_stops_worms",
  "treated_lgl", 
  "months_since_treatment",
  "all_can_get_worms",
  "correct_when_treat",
  "baseline_neighbours_worm_knowledge"
)


baseline_balance_fit = feols(
    data = baseline_balance_data, 
    .[baseline_vars] ~ 0 + treat_dist, 
    ~county
    # vcov = "HC"
    ) 



# TODO: Do test within distance groups and overall
balance_variables = c(
# "Pupil.Teacher.Ratio",
# "Pupil.Classroom.Ratio",
# "Pupil.Toilet.Ratio",
# "Total.Number.of.Classrooms",
# "Total.Enrolment", 
# "GOK.TSC.Male",
# "GOK.TSC.Female",
# "Non.Teaching.Staff.Male",
# "Non.Teaching.Staff.Female",
"cluster.dist.to.pot"
)

indiv_balance_vars = c(
  "female", 
  "phone_owner", 
  "age"
)

rct_school_df = rct.schools.data %>% 
    as_tibble()


analysis_school_data = left_join(
    analysis_data,
    rct_school_df %>% mutate(cluster.id = as.numeric(cluster.id)) ,
    by = "cluster.id"
)


analysis_school_data = analysis_school_data %>%
mutate(
    treat_dist = paste0(
    "treat: ", 
    assigned.treatment,
    ", dist: ", dist.pot.group
    ) %>% factor()
)  %>%
mutate(
  female = fct_match(gender, "female")
)

  

indiv_balance_fit = feols(
    data = analysis_school_data, 
    .[indiv_balance_vars] ~ 0 + treat_dist,
    cluster = ~county
    ) 

# Probably a better way to get the schools in the sample
school_treat_df = analysis_school_data %>%
  filter(!is.na(assigned.treatment)) %>%
  select(any_of(colnames(rct_school_df)), treat_dist, cluster.dist.to.pot, constituency, county) %>%
  unique()


school_balance_fit = feols(
    data = school_treat_df, 
    .[balance_variables] ~ 0 + treat_dist,
    ~county

  )

#### Endline
endline_balance_data = endline.data %>%
  inner_join(
    cluster_treat_df, 
    by = "cluster.id"
  ) %>%
  mutate(
    endline_neighbours_worm_knowledge = case_when(
      neighbours_worms_affect == "yes" ~ TRUE, 
      neighbours_worms_affect == "no" ~ FALSE, 
      TRUE ~ NA
    )
  ) %>%
  mutate(
    all_can_get_worms = map_lgl(who_worms, ~any(str_detect(.x, "everyone") | (str_detect(.x, "adult") & str_detect(.x, "child")))), 
    correct_when_treat = map_lgl(when_treat, ~any(.x == "every 6 months")), 
    know_deworming_stops_worms = map_lgl(stop_worms, ~any(.x == "medicine"))
  ) 
  


endline_and_baseline_data = bind_rows(
  endline_balance_data %>%
    select(
      treat_dist, 
      neighbours_worm_knowledge = endline_neighbours_worm_knowledge, 
      all_can_get_worms,
      correct_when_treat, 
      know_deworming_stops_worms,
      constituency, county) %>%
    mutate(
      type = "endline"
    ),
  baseline_balance_data %>%
    select(
      treat_dist, 
      neighbours_worm_knowledge = baseline_neighbours_worm_knowledge, 
      all_can_get_worms,
      correct_when_treat, 
      know_deworming_stops_worms,
      constituency, county) %>%
    mutate(
      type = "baseline"
    )
) %>%
  na.omit()

endline_vars = c(
  "endline_neighbours_worm_knowledge", 
  "all_can_get_worms", 
  "correct_when_treat", 
  "know_deworming_stops_worms"
  )
endline_balance_fit = feols(
    data = endline_balance_data, 
    .[endline_vars] ~ 0 + treat_dist, 
    cluster = ~county
    ) 

balance_fits = c(
  indiv_balance_fit,
  list("lhs: cluster.dist.to.pot" = school_balance_fit),
  baseline_balance_fit
)


balance_tidy_df = balance_fits %>%
    map_dfr(tidy, .id = "lhs") %>%
    mutate(
        lhs = str_remove(lhs, "lhs: ")
    ) %>%
    select(
        lhs, term, estimate, std.error
    )   %>%
    mutate(
      lhs = str_replace_all(lhs, "\\.", " ") %>% str_to_title()
    )

```

```{r}
#| joint-tests
# Number of dist groups x treatment
n_variables = 8
# matrix R for test 
hyp_matrix = cbind(
  matrix(-1, nrow = n_variables - 1, ncol = 1 ), 
  diag(x = 1, nrow = n_variables - 1, ncol = n_variables)[, 1:(n_variables - 1)]
)

zero_matrix = matrix(0, nrow = 3, ncol = n_variables - 1) 
part_hyp_matrix = zero_matrix
for (i in 1:3) {
  part_hyp_matrix[i, 2*i] = 1
}

hyp_matrix_close = cbind(
  matrix(-1, nrow = 3, ncol = 1), 
  part_hyp_matrix
)

hyp_matrix_far = cbind(
  matrix(0, nrow = 3, ncol = 1),
  matrix(-1, nrow = 3, ncol = 1), 
  part_hyp_matrix[, 1:(ncol(part_hyp_matrix) - 1)]
)

library(fwildclusterboot)

perform_cluster_boot = function(data, var, joint_R, close_R, far_R) {
  subset_data = data %>%
    select(all_of(var), treat_dist, county, constituency) %>%
    na.omit()


  fml = as.formula(paste0(var, " ~ 0 + treat_dist"))
  fit = lm(
    formula = fml, 
    data = subset_data
  )
  joint_boot_output = mboottest(
    object = fit, 
    clustid = c("county", "constituency"), 
    bootcluster = "constituency", 
    B = 9999, 
    R = joint_R
  )
  close_boot_output = mboottest(
    object = fit, 
    clustid = c("county", "constituency"), 
    bootcluster = "constituency", 
    B = 9999, 
    R = close_R
  )
  far_boot_output = mboottest(
    object = fit, 
    clustid = c("county", "constituency"), 
    bootcluster = "constituency", 
    B = 9999, 
    R = far_R
  )
  return(lst(
    joint_pval = joint_boot_output$p_val, 
    close_pval = close_boot_output$p_val, 
    far_pval = far_boot_output$p_val))
}

indiv_boot = map(
  indiv_balance_vars, 
  ~perform_cluster_boot(
    data = analysis_school_data, 
    var = .x, 
    joint_R = hyp_matrix,
    close_R = hyp_matrix_close,
    far_R = hyp_matrix_far
     )
)


baseline_boot = map(
  baseline_vars, 
  ~perform_cluster_boot(
    data = baseline_balance_data,
    var = .x, 
    joint_R = hyp_matrix,
    close_R = hyp_matrix_close,
    far_R = hyp_matrix_far
  )
)

school_boot = map(
  balance_variables,
  ~perform_cluster_boot(
    data = school_treat_df,
    var = .x,
    joint_R = hyp_matrix,
    close_R = hyp_matrix_close,
    far_R = hyp_matrix_far
  )
)

endline_boot = map(
  endline_vars,
  ~perform_cluster_boot(
    data = endline_balance_data,
    var = .x,
    joint_R = hyp_matrix,
    close_R = hyp_matrix_close,
    far_R = hyp_matrix_far
  )
)


boot_fits = c(
  indiv_boot, 
  school_boot, 
  baseline_boot
  # endline_boot
)

joint_signif_fstats = map_dbl(
  boot_fits, "joint_pval"
) %>% round(4)

close_joint_signif_fstats = map_dbl(
  boot_fits, "close_pval"
) %>% round(4)

far_joint_signif_fstats = map_dbl(
  boot_fits, "far_pval"
) %>%
  round(4)

col_order = c(
  "lhs", 
  paste0(treat_levels_c, "_close"),
  "close_joint_p",
  paste0(treat_levels_c, "_far"),
  "far_joint_p",
  "joint_p"
)

create_balance_input = function(tidy_df, col_order, digits = 3) {
bal_input_df = tidy_df %>%
    mutate(
    estimate = round(estimate, digits),
    std.error = round(std.error, digits)
    ) %>%
    mutate(
    estim_std = linebreak(paste0(estimate, "\n", str_glue("({std.error})")), align = "c") 
    )  %>%
    mutate(lhs_treat = str_extract(term, "(?<=disttreat: ).*(?=\\,)")) %>%
    mutate(lhs_dist = str_extract(term, "(?<=dist: ).*$")) %>%
    select(lhs, lhs_treat, lhs_dist, estim_std) %>%
    mutate(
    lhs_treat = factor(lhs_treat, treat_levels_c) %>% fct_rev(), 
    lhs_dist = factor(lhs_dist, dist_levels) %>% fct_rev()
    ) %>%
    pivot_wider(
    names_from = c(lhs_treat, lhs_dist),
    values_from = estim_std, 
    )    %>%
    select(
    any_of(col_order)
    )  %>%
    mutate(
        lhs = str_to_title(lhs),
        lhs = str_replace_all(lhs, "_", " ")
    )
return(bal_input_df)
}


N_beliefs_obs_df = analysis_school_data[stan_data$beliefs_obs_index, ] %>%
  group_by(
    treat_dist
  ) %>%
  summarise(
    N_indiv = n_distinct(KEY.individ),
    N_pot = n_distinct(cluster.id)
  )  




stratum_map = analysis.data %>% 
  mutate(stratum = county) %>%
  mutate(stratum_id = as.integer(stratum)) %>% 
  distinct(stratum_id, stratum)

incentive_choice_data <- analysis.data %>%
  filter(!is.na(gift_choice) & gift_choice != "neither",
          assigned.treatment == "control",
          sms.treatment.2 == "sms.control") %>%
  # select(county, cluster.id, gift_choice, phone_owner) %>%
  mutate(offer = 0,
          response = "keep")

incentive_choice_data <- wtp.data %>%
  semi_join(analysis.data, "cluster.id") %>% # Make sure we have the same clusters
  filter(!is.na(first_choice)) %>%
  transmute(county, cluster.id,
            gift_choice = first_choice,
            offer = price,
            response = second_choice) %>%
  bind_rows(incentive_choice_data) %>%
  left_join(stratum_map, c("county" = "stratum")) %>%
  mutate(gift_choice = 2 * (gift_choice == "calendar") - 1,
          response = 2 * (response == "switch") - 1) 


N_wtp_obs_df = analysis_school_data %>%
  filter(KEY.individ %in% incentive_choice_data$KEY.individ) %>%
  filter(!is.na(KEY.individ)) %>%
  group_by(
    treat_dist
  ) %>%
  summarise(
    N_indiv = n_distinct(KEY.individ),
    N_pot = n_distinct(cluster.id)
  )  %>%
  mutate(type = "WTP")



N_baseline_obs = baseline_balance_data %>%
  group_by(treat_dist) %>%
  summarise(
    N_indiv = n_distinct(KEY), 
    N_pot = n_distinct(cluster.id)
  ) %>%
  mutate(
    type = "baseline"
  )


# baseline_balance_fit$`lhs: years_schooling` %>%
#   tidy(conf.int = TRUE) %>%
#   mutate(dist_close = str_detect(term, "close")) %>%
#   ggplot(aes(
#     x = estimate, 
#     xmin = conf.low, 
#     xmax = conf.high, 
#     y = term
#   )) +
#   geom_pointrange() +
#   facet_wrap(~dist_close)


N_by_treat_dist_df = analysis_school_data %>%
  group_by(
    treat_dist
  ) %>%
  summarise(
    N_indiv = n_distinct(KEY.individ),
    N_pot = n_distinct(cluster.id)
  )  %>% 
  mutate(type = "takeup") %>%
  bind_rows(
    N_baseline_obs,
    N_beliefs_obs_df %>% mutate(type = "beliefs"), 
    N_wtp_obs_df
  ) %>%
  mutate(
    treatment = str_extract(treat_dist, "(?<=treat: ).*(?=\\,)"), 
    distance = str_extract(treat_dist, "(?<=dist: ).*$")
  ) %>%
  select(-treat_dist)  %>%
  pivot_longer(
    cols = c(N_indiv, N_pot), names_to = "lhs"
  ) %>%
  pivot_wider(
    names_from = c(treatment, distance),
    values_from = value
  )  %>%
  mutate(
    type = factor(type, levels = c("baseline", "takeup", "beliefs", "WTP"))
  ) %>%
  arrange(type)







```


```{r}
#| baseline-learning


comp_endline_vars = endline_vars %>%
  str_remove(., "endline_")
comp_endline_vars = comp_endline_vars[comp_endline_vars != "know_deworming_stops_worms"]
baseline_endline_externality_fit = feols(
      data = endline_and_baseline_data, 
      .[comp_endline_vars] ~ 0 + treat_dist:type, 
      ~county
      ) 

perform_externality_cluster_boot = function(data, var, R) {
  subset_data = data %>%
    select(all_of(var), treat_dist, type, county, constituency) %>%
      na.omit()


  fml = as.formula(paste0(var, " ~ 0 + treat_dist:type"))
  fit = lm(
    formula = fml, 
    data = subset_data
  )

  if (is.matrix(R)) {
    joint_boot_output = mboottest(
      object = fit, 
      clustid = c("county", "constituency"), 
      bootcluster = "constituency", 
      B = 9999, 
      R = R
    )
  } else {
    joint_boot_output = boottest(
      object = fit, 
      clustid = c("county", "constituency"),
      param = names(coef(fit)), 
      bootcluster = "constituency", 
      B = 999, 
      R = R
    )
  }
  return(joint_boot_output$p_val)
}


library(marginaleffects)
# indiv_externality_comp_test 

indiv_externality_comp_test = baseline_endline_externality_fit %>%
  map(
    ~comparisons(
      .x,
      variable = list(type = "reference"), 
      newdata = datagrid(
        treat_dist = unique(baseline_balance_data$treat_dist)
      )
    )
  )

indiv_externality_comp_df = tibble(
  lhs = names(indiv_externality_comp_test), 
  p.value = map(indiv_externality_comp_test, "p.value"), 
  treat_dist = list(unique(baseline_balance_data$treat_dist)) 
) %>%
  mutate(lhs = str_remove(lhs, "lhs: ")) %>%
    unnest(c(p.value, treat_dist))

generate_joint_externality_hyp_m = function(fit, treat_term, dist_term) {
  hyp_df = fit %>%
    tidy() %>%
    select(term) %>% 
    mutate(
      treat = str_extract(term, "(?<=treat: ).*(?=,)"),
      dist = str_extract(term, "(?<=dist: ).*(?=:)"), 
      type = str_extract(term, "(?<=type).*$")
    ) %>%
    mutate(
      val = 0,
      val = if_else(
        treat == treat_term &
        dist == dist_term &
        type == "baseline", 
        -1, 
        val
        ),
      val = if_else(
        treat == treat_term &
        dist == dist_term &
        type == "endline", 
        1, 
        val
        )
    )
  return(hyp_df$val)
}

dist_treat_grid = expand_grid(
  treat = c("bracelet", "calendar", "ink", "control"), 
  dist = c("close", "far")
) %>%
  arrange(dist)

externality_joint_hyp_matrix = map2(
  dist_treat_grid$treat, 
  dist_treat_grid$dist, 
  ~generate_joint_externality_hyp_m(fit = baseline_endline_externality_fit[[1]], .x, .y )
) %>%
  do.call(rbind, .)


joint_externality_p_value =  map_dbl(
  comp_endline_vars,
  ~perform_externality_cluster_boot(
    data = endline_and_baseline_data, 
    var = .x, 
    R = externality_joint_hyp_matrix
  )
)

gen_close_p_val = function(x){
  map(
      c(split(externality_joint_hyp_matrix[1:4, ], 1:4), list(externality_joint_hyp_matrix[1:4, ])),
      ~perform_externality_cluster_boot(endline_and_baseline_data, x, .x)
  )
}

indiv_close_externality_p_value =  map(
  comp_endline_vars, 
  gen_close_p_val
)

gen_far_p_val = function(x) {
  map(
    c(split(externality_joint_hyp_matrix[5:8, ], 1:4), list(externality_joint_hyp_matrix[5:8, ])),
    ~perform_externality_cluster_boot(endline_and_baseline_data,x,  .x)
)
}

indiv_far_externality_p_value = map(comp_endline_vars, gen_far_p_val)



endline_p_val_df = map(1:length(comp_endline_vars), ~c(comp_endline_vars[.x], indiv_close_externality_p_value[[.x]] %>% unlist(), indiv_far_externality_p_value[[.x]] %>% unlist(), joint_externality_p_value[[.x]])) %>%
  bind_rows()

colnames(endline_p_val_df) = col_order

endline_p_val_df = endline_p_val_df %>%
  mutate(across(c(everything(), -lhs), as.numeric)) %>%
  mutate(fit_type = "pval") 


endline_tidy_df = endline_balance_fit %>%
    map_dfr(tidy, .id = "lhs") %>%
    mutate(
        lhs = str_remove(lhs, "lhs: ")
    ) %>%
    select(
        lhs, term, estimate, std.error
    )   %>%
    mutate(
      lhs = str_replace_all(lhs, "\\.", " ") %>% str_to_title()
    ) 

```



```{r}
#| balance-creation, dependson="balance-setup"
1+10
wide_indiv_bal_df = create_balance_input(
    balance_tidy_df, 
    col_order = col_order, 
    digits = 3
)  %>%
  mutate(
    close_joint_p = close_joint_signif_fstats,
    far_joint_p = far_joint_signif_fstats,
    joint_p = joint_signif_fstats
  ) %>%
  select(all_of(col_order))  %>%
  bind_rows(
    N_by_treat_dist_df %>%
      mutate(
        lhs = str_replace_all(lhs, "_", " ") %>% 
          str_to_title()
      ) %>%
      mutate(across(where(is.numeric), as.character)) %>%
      mutate(across(where(is.numeric), replace_na, "-")) 
  ) %>%
  select(-type) %>%
  mutate(across(where(is.character), ~if_else(.x == "", "-", .x))) %>%
  mutate(across(where(is.character), replace_na, "-")) %>%
  mutate(
    lhs = case_when(
      lhs == "N Indiv" ~ "N individuals", 
      lhs == "N Pot" ~ "N points of treatment",
      lhs == "Cluster Dist To Pot" ~ "Cluster distance to PoT",
      lhs == "Baseline neighbours worm knowledge" ~ "Understand deworming externality, baseline",
      lhs == "Endline neighbours worm knowledge" ~ "Understand deworming externality, endline",
      lhs == "Treated lgl" ~ "Dewormed self", 
      lhs == "Months since treatment" ~ "Months since last dewormed",
      lhs == "Know deworming stops worms" ~ "Knowledge of deworming medication", 
      lhs == "All can get worms" ~ "Know everyone can be infected", 
      lhs == "Correct when treat" ~ "Know bi-yearly treatment recommended", 
      TRUE ~ lhs
    )
  )

```

## Balance

```{r, results="asis"}
#| balance-table,
#| dependson=c("balance-setup", "balance-creation")
3+1
# TODO: add tests for imbalance
treat_colnames = str_to_title(treat_levels_c)
bal_table = wide_indiv_bal_df %>% 
knitr::kable(
    format = "latex",
    escape = FALSE, 
    col.names = c("", treat_colnames, "F-test $p$-value", treat_colnames, "F-test $p$-value", "Joint F-test $p$-value"), 
    booktabs = TRUE, 
    caption = "Balance Table", 
    align = "lccccccccccc"
) %>%
kable_styling(
  latex_options = c("scale_down")
) %>%
add_header_above(c("", "Close" = 5, "Far" = 5, "")) %>%
footnote(general = "Insert footnote here.")  %>%
  pack_rows(
    index = c(
      "Individual-level Covariates" = 11, 
      # "Point of Treatment Covariates" = 10, 
      "Baseline Sample" = 2,
      "Takeup Sample" = 2,
      "Belief Sample" = 2,
      "WTP Sample" = 2
    ), 
    # latex_gap_space = latex_group_gap_space, 
    hline_after = TRUE, 
    # hline_before = TRUE,
    bold = TRUE
  ) 

bal_table

custom_save_latex_table = function(table, table_name){
  table_conn = file(
    file.path(
      params$table_output_path, paste0(table_name, ".tex")
    )
  )
  table %>%
    str_remove(
      ., 
      fixed("\\begin{table}")
    ) %>%
    str_remove(
      .,
      "\\\\caption\\{.*\\}"
    ) %>%
    str_remove(
      ., 
      "\\\\end\\{table\\}"
    )  %>%
    writeLines(
      table_conn
    )
    close(table_conn)
    return(NULL)
}


bal_table %>%
  custom_save_latex_table("balance-table")

```


```{r}
#| endline-table

endline_p_val_df %>%  
      mutate(across(where(is.numeric), round, 3)) %>%
      mutate_all(as.character) %>%
      mutate(
        lhs = str_replace_all(lhs, "\\.", " ") %>% str_to_title(), 
        lhs = str_replace_all(lhs, "_", " ")
      )  %>% 
      mutate(type = "pval") %>%
      pull(lhs)

endline_balance_df = create_balance_input(
    endline_tidy_df, 
    col_order = col_order[!str_detect(col_order, "_p$")], 
    digits = 3
)   %>%
  mutate(type = "fit") %>%
  bind_rows(
    endline_p_val_df %>%  
      mutate(across(where(is.numeric), round, 3)) %>%
      mutate_all(as.character) %>%
      mutate(
        lhs = str_replace_all(lhs, "\\.", " ") %>% str_to_title(), 
        lhs = str_replace_all(lhs, "_", " ")
      )  %>% 
      mutate(type = "pval")
  ) %>%
  arrange(lhs, type) %>%
  mutate(
    lhs = case_when(
      lhs == "N Indiv" ~ "N individuals", 
      lhs == "N Pot" ~ "N points of treatment",
      lhs == "Cluster Dist To Pot" ~ "Cluster distance to PoT",
      lhs == "Neighbours worm knowledge" ~ "Understand deworming externality",
      lhs == "Endline neighbours worm knowledge" ~ "Understand deworming externality",
      lhs == "Treated lgl" ~ "Dewormed self", 
      lhs == "Months since treatment" ~ "Months since last dewormed",
      lhs == "Know deworming stops worms" ~ "Knowledge of deworming medication", 
      lhs == "All can get worms" ~ "Know everyone can be infected", 
      lhs == "Correct when treat" ~ "Know bi-yearly treatment recommended", 
      TRUE ~ lhs
    )
  ) %>%
  mutate(lhs = if_else(type == "pval", paste0("$\\Delta$", lhs, ", $p$-value"), lhs)) %>%
  select(-type) %>%
  mutate(across(where(is.character), ~if_else(.x == "", "-", .x))) %>%
  mutate(across(where(is.character), replace_na, "-")) %>%
  select(all_of(col_order)) %>%
  filter(lhs != "Knowledge of deworming medication")
endline_balance_df %>%
  select(far_joint_p)

treat_colnames = str_to_title(treat_levels_c)
endline_bal_table = endline_balance_df %>% 
knitr::kable(
    format = "latex",
    escape = FALSE, 
    col.names = c("", treat_colnames, "F-test $p$-value", treat_colnames, "F-test $p$-value", "Joint F-test $p$-value"), 
    booktabs = TRUE, 
    caption = "Endline Table", 
    align = "lccccccccccc"
) %>%
kable_styling(
  latex_options = c("scale_down")
) %>%
add_header_above(c("", "Close" = 5, "Far" = 5, "")) %>%
footnote(general = "$\\Delta ..., p$-value corresponds to the null hypothesis that endline and baseline levels are the same.") 

endline_bal_table %>%
  custom_save_latex_table("endline-table")

endline_bal_table

```

WTP obs in "stan_data" is 998 but when I count indivs I get 458. Think it's a 
coding error.

```{r, sample_n, results="asis"}

sample_meta_df = N_by_treat_dist_df %>%
  gather(variable, value, -type, -lhs) %>%
  group_by(
    type, lhs
  ) %>%
  summarise(
    n = sum(value, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  spread(lhs, n) %>%
  mutate(
    sample = case_when(
      type == "beliefs" ~ "Beliefs", 
      type == "takeup" ~ "Takeup", 
      type == "WTP" ~ "WTP"
    )
  ) %>%
  select(-type) %>%
  select(sample, everything())



sample_meta_tbl = sample_meta_df %>%
    kbl(
        booktabs = TRUE, 
        format = "latex", 
        caption = "Sample Size Across Experiments", 
        align = "lcc",
        col.names = c("Experiment", "N Individuals", "N PoTs")
    )  %>%
    kable_styling()
sample_meta_tbl

```


```{r}

full_data_env = new.env()

with_env = function(f, e = parent.frame()) {
    stopifnot(is.function(f))
    environment(f) = e
    f
}

load_full_data_function = function(){
    load(file.path("temp-data", str_interp("processed_dist_fit${fit_version}.RData")))
    return(dist_fit_data)
}


full_dist_fit_data = with_env(load_full_data_function, full_data_env)() %>%
  filter(model %in% c("REDUCED_FORM_NO_RESTRICT", models_we_want))


pr_comparison_te_df = full_dist_fit_data %>%
  filter(fit_type == "fit") %>%
  select(model_type, fit_type, est_takeup_te) %>%
  unnest(est_takeup_te)  %>%
  unnest(iter_data)   %>%
  group_by(
    model_type, 
    fit_type, 
    assigned_treatment_left,
    assigned_treatment_right,
    mu_assigned_treatment_left, 
    mu_assigned_treatment_right, 
    assigned_dist_group_left, 
    assigned_dist_group_right
  ) %>%
  summarise(
    pr_greater = mean(iter_takeup_te > 0, na.rm = TRUE)
  ) %>%
  ungroup()

b_c_draws = full_dist_fit_data %>%
  filter(fit_type == "fit") %>%
  select(model_type, fit_type, est_takeup_te) %>%
  unnest(est_takeup_te)  %>%
  unnest(iter_data)   %>%
  filter(
    assigned_treatment_left == mu_assigned_treatment_left,
    assigned_treatment_right == mu_assigned_treatment_right,
    assigned_dist_group_left == assigned_dist_group_right, 
    assigned_treatment_right == "control"
  )

b_c_draws %>%
  select(-mean_est, -contains("per")) %>% 
  select(
    assigned_treatment_left, assigned_treatment_right, assigned_dist_group_left, iter_id, iter_takeup_te
  )  %>%
  pivot_wider(
    names_from = assigned_treatment_left, 
    values_from = iter_takeup_te
  ) %>%
  ggplot(aes(
    x = bracelet, 
    y = calendar, 
    colour = assigned_dist_group_left
  )) +
  geom_point() +
  geom_smooth(
    method = lm, 
    se = FALSE
  ) +
  geom_abline(
    linetype = "longdash"
  ) +
  labs(
    title = "Plotting Overall ATE Posterior Draws - Very Correlated Estimates", 
    subtitle = "Bracelet vs Calendar"
  )
  ggsave(
    "temp-plots/correlated-beta.png", 
    width = 8, 
    height = 6,
    dpi = 500
  )



```



```{r}
#| setup-res-table

incentive_te = dist_fit_data %>%
  mutate(
    est_takeup_te =
      map_if(est_takeup_te, fct_match(model_type, "structural"),
             filter, mu_assigned_treatment_left == assigned_treatment_left, mu_assigned_treatment_right == assigned_treatment_right) %>%
        map(filter,
            (is.na(assigned_dist_group_left) & is.na(assigned_dist_group_right)) | (assigned_dist_group_left == assigned_dist_group_right),
            assigned_treatment_left != assigned_treatment_right,
            fct_match(assigned_treatment_right, c("control")),
            fct_match(assigned_treatment_left, "bracelet") | !fct_match(assigned_treatment_right, "calendar")),
    model_color = canva_pal(canva_palette_vibrant)(n())
  ) %>% 
  select(model, model_type, model_name, est_takeup_te, fit_type, model_color) %>% 
  mutate(
    est_takeup_te = map(
      est_takeup_te,
      mutate,
      assigned_dist_group_left = fct_explicit_na(assigned_dist_group_left, "Combined") %>% 
        fct_relabel(str_to_title) %>% 
        fct_relevel("Combined"),
      assigned_treatment_left = str_to_title(assigned_treatment_left)
    )) %>%
    unnest(est_takeup_te)  %>%
    select( 
      model_type,
      assigned_treatment = assigned_treatment_left, 
      assigned_dist = assigned_dist_group_left,
      mean_est, 
      per_0.05, 
      per_0.95
    )


incentive_control_mean = dist_fit_data %>%
  select(model_type, fit_type, model, est_takeup_level) %>%
  unnest(
    est_takeup_level
  ) %>%
  filter(
    mu_assigned_treatment == assigned_treatment # PB = mu
    ) %>%
  filter(assigned_treatment == "control") %>%
  select( 
    model_type,
    assigned_treatment = assigned_treatment, 
    assigned_dist = assigned_dist_group,
    mean_est, 
    per_0.05, 
    per_0.95
  ) %>%
  mutate(
    assigned_treatment = str_to_title(assigned_treatment), 
    assigned_dist = fct_explicit_na(assigned_dist, "Combined") %>% 
      fct_relabel(str_to_title) %>% 
      fct_relevel("Combined")
  )

signalling_te = dist_fit_data %>% 
  filter(fct_match(fit_type, "fit"), fct_match(model_type, "structural")) %>%
  select(model, model_type, model_name, est_takeup_te, fit_type) %>% 
  mutate(
    est_takeup_te = map(
      est_takeup_te,
      filter,
      (is.na(assigned_dist_group_left) & is.na(assigned_dist_group_right)) | (assigned_dist_group_left == assigned_dist_group_right),
      across(c(assigned_treatment_left, assigned_treatment_right), fct_match, "control"),
      !is.na(mu_assigned_treatment_left),
      fct_match(mu_assigned_treatment_left, "bracelet") | !fct_match(mu_assigned_treatment_right, "calendar"),
      fct_match(mu_assigned_treatment_right, "control"),
    ) %>% 
      map(
        mutate,
        assigned_dist_group_left = fct_explicit_na(assigned_dist_group_left, "Combined") %>% 
          fct_relabel(str_to_title) %>% 
          fct_relevel("Combined"),
        mu_assigned_treatment_left = str_to_title(mu_assigned_treatment_left),
      ),
    model_color = canva_pal(canva_palette_vibrant)(n())) %>%
    unnest(est_takeup_te)  %>%
    select(
      assigned_treatment = mu_assigned_treatment_left, 
      assigned_dist = assigned_dist_group_left, 
      model_type,
      mean_est,
      per_0.05,
      per_0.95
    )




private_te = dist_fit_data %>% 
  filter(fct_match(fit_type, "fit"), fct_match(model_type, "structural")) %>%
  select(model, model_type, model_name, est_takeup_te, fit_type) %>% 
  mutate(
    est_takeup_te = map(
      est_takeup_te,
      filter,
      (is.na(assigned_dist_group_left) & is.na(assigned_dist_group_right)) | (assigned_dist_group_left == assigned_dist_group_right),
      !is.na(mu_assigned_treatment_left),
      !is.na(mu_assigned_treatment_right),
      across(c(mu_assigned_treatment_left, mu_assigned_treatment_right), fct_match, "control"),
      fct_match(assigned_treatment_left, "bracelet") | !fct_match(assigned_treatment_right, "calendar"),
      fct_match(assigned_treatment_right, "control"),
    ) %>% 
      map(
        mutate,
        assigned_dist_group_left = fct_explicit_na(assigned_dist_group_left, "Combined") %>% 
          fct_relabel(str_to_title) %>% 
          fct_relevel("Combined"),
        assigned_treatment_left = str_to_title(assigned_treatment_left),
      ),
    model_color = canva_pal(canva_palette_vibrant)(n())) %>%
    unnest(est_takeup_te) %>%
    select(
      assigned_treatment = assigned_treatment_left,
      assigned_dist = assigned_dist_group_left, 
      model_type,
      mean_est, 
      per_0.05, 
      per_0.95
    )

## Differences Between Bracelet and Calendar
incentive_bracelet_calendar_diff_df = pr_comparison_te_df %>%
    filter(
      (assigned_dist_group_left == assigned_dist_group_right) | (is.na(assigned_dist_group_left) & is.na(assigned_dist_group_right)), # same dist group
      model_type == "reduced form" | (model_type == "structural" & (mu_assigned_treatment_left == assigned_treatment_left)), # same mu and B
      model_type == "reduced form" | (model_type == "structural" & (mu_assigned_treatment_right == assigned_treatment_right)), # same mu and B
      fct_match(assigned_treatment_right, "calendar"), 
      fct_match(assigned_treatment_left, "bracelet")
    )  %>%
    mutate(
        assigned_dist_group_left = fct_explicit_na(assigned_dist_group_left, "Combined") %>% 
          fct_relabel(str_to_title) %>% 
          fct_relevel("Combined"),
        assigned_treatment_left = str_to_title(assigned_treatment_left),
      ) %>%
    select(
      assigned_treatment = assigned_treatment_left,
      assigned_dist = assigned_dist_group_left, 
      model_type,
      pr_greater
    ) %>%
    mutate(
      assigned_treatment = "Pr(Bracelet > Calendar)"
    )



signal_bracelet_calendar_diff_df = pr_comparison_te_df %>%
  filter(
    (assigned_dist_group_left == assigned_dist_group_right) | (is.na(assigned_dist_group_left) & is.na(assigned_dist_group_right)), # same dist group
    (assigned_treatment_left == assigned_treatment_right), # same B on LHS and RHS
    (mu_assigned_treatment_left == "bracelet" & mu_assigned_treatment_right == "calendar"), 
    assigned_treatment_left == "control" 
) %>%
    mutate(
        assigned_dist_group_left = fct_explicit_na(assigned_dist_group_left, "Combined") %>% 
          fct_relabel(str_to_title) %>% 
          fct_relevel("Combined"),
        assigned_treatment_left = str_to_title(assigned_treatment_left),
      ) %>%
    select(
      assigned_treatment = assigned_treatment_left,
      assigned_dist = assigned_dist_group_left, 
      model_type,
      pr_greater
    ) %>%
    mutate(
      assigned_treatment = "Pr(Bracelet > Calendar)"
    )




te_df = bind_rows(
  incentive_te %>% mutate(estimand = "incentive"),
  incentive_bracelet_calendar_diff_df %>% mutate(estimand = "incentive", is_diff = TRUE),
  private_te %>% mutate(estimand = "private"),
  signalling_te %>% mutate(estimand = "signal"),
  signal_bracelet_calendar_diff_df %>% mutate(estimand = "signal", is_diff = TRUE),
  incentive_control_mean %>% mutate(estimand = "control mean")
) %>%
  mutate(
    assigned_treatment = if_else(
      assigned_treatment == "Pr(Bracelet > Calendar)", 
      "Pr(Bracelet > Calendar)", 
      assigned_treatment
      ),
    assigned_treatment = if_else(
      assigned_treatment == "Control", 
      "Control mean", 
      assigned_treatment
    ),
    assigned_treatment = factor(
      assigned_treatment, 
      levels = c("Bracelet", "Calendar", "Ink", "Control mean", "Pr(Bracelet > Calendar)"))
  )




rf_te_input_df = te_df %>%
  filter(model_type == "reduced form") %>%
  mutate(across(where(is.numeric), round, 3)) %>%
  mutate(
    estim_value = if_else(
      is_diff == FALSE | is.na(is_diff),
      linebreak(
        paste0(mean_est, "\n", "(", per_0.05, ", ", per_0.95, ")"), 
        align = "c"
        ), 
      as.character(round(pr_greater, 3))
    )
  ) %>%
  select(
    model_type, 
    assigned_treatment, 
    assigned_dist, 
    estim_value, 
    estimand
  ) %>%
  pivot_wider(
    names_from = assigned_dist, 
    values_from = estim_value
  )  %>%
  rename(
    rf_Close = Close, 
    rf_Far = Far, 
    rf_Combined = Combined
  )

structural_te_input_df = te_df %>%
  filter(model_type == "structural") %>%
  mutate(across(where(is.numeric), round, 3)) %>%
  mutate(
    estim_value = if_else(
      is_diff == FALSE | is.na(is_diff),
      linebreak(
        paste0(mean_est, "\n", "(", per_0.05, ", ", per_0.95, ")"), 
        align = "c"
        ), 
      as.character(round(pr_greater, 3))
    )
  ) %>%
  select(
    model_type, 
    assigned_treatment, 
    assigned_dist, 
    estim_value, 
    estimand
  ) %>%
  pivot_wider(
    id_cols = c(assigned_treatment, estimand),
    names_from = assigned_dist, 
    values_from = estim_value
  )  %>%
  mutate(across(
    c(Close, Far), 
    ~if_else(
      estimand == "private", 
      NA_character_, 
      .x
    )
  ))


te_input_df = right_join(
  rf_te_input_df,
  structural_te_input_df,
  by = c("estimand", "assigned_treatment")
)  %>%
  select(-model_type) %>%
  select(
    Estimand = estimand, 
    Treatment = assigned_treatment, 
    everything()
  ) %>%
  mutate(across(c(contains("rf_"), Close, Far), replace_na, "-")) %>%
  mutate(Estimand = factor(Estimand, levels = c("incentive", "signal", "private", ""))) %>%
  arrange(Estimand) %>%
  select(
    Estimand, 
    Treatment, 
    rf_Combined, 
    rf_Close,
    rf_Far,
    Combined,
    Close,
    Far
  )






latex_group_gap_space = "2em"

```


```{r, results="asis"}
1+1
te_kbl_df = te_input_df %>%
  arrange(Estimand, Treatment) %>%
  mutate(
    Estimand = if_else(
      Treatment == "Ink", 
      Estimand, 
      factor("")
    )
  ) %>%
  select(-Estimand) %>%
  kbl(
    col.names = c(
      # "Estimand", 
      # "Treatment", 
      "Dependent variable: Take-up",
      paste0("(", 1:6, ")")
    ), 
    format = "latex", 
    linesep = "\\addlinespace \\addlinespace \\addlinespace",
    booktabs = TRUE, 
    escape = FALSE, 
    align = "lcccccc", 
    caption = "Results"
  ) %>%
  kable_styling(
    latex_options = c("scale_down")
  ) %>%
  add_header_above(
    c(" ", 
      "Combined", 
      "Close", 
      "Far", 
      "Combined",
      "Close", 
      "Far"
      ), 
    line = FALSE
  ) %>%
  add_header_above(
    c(
      " " = 1,
      "Reduced Form" = 3, 
      "Structural" = 3
      )
  ) %>%
  pack_rows(
    index = c(
      "Panel A: Overall" = 4, 
      "Panel B: Signalling" = 4, 
      "Panel C: Private" = 3
    ), 
    italic = TRUE,
    escape = FALSE,
    # latex_gap_space = latex_group_gap_space, 
    hline_after = TRUE, 
    hline_before = TRUE,
    bold = TRUE
  ) %>%
  # add_indent(c(4, 8)) %>%
  row_spec(11, hline_after = TRUE) %>%
  add_indent(12) %>%
  footnote(
    escape = FALSE,
    threeparttable = TRUE,
    # general = 
        # str_glue(
        #     "Point estimates represent posterior means, 90\\\\% percent credibility intervals are shown in parentheses.
        #     'Overall' indicates the total treatment effect; 'Signalling' and 'Private' use the structural model to 
        #     isolate the effect of reputational returns and the private utility derived from each treatment. 
        #     \\\\textit{{Bracelet - Calendar}} shows the posterior difference in takeup across bracelet and calendar conditions.
        #     Structural estimates use all three samples: {stan_data$num_obs} individuals' deworming status; {stan_data$num_beliefs_obs} individual's elicited first-order beliefs; and 
        #     data from {stan_data$num_wtp_obs} individual's Willingness-To-Pay choices. Reduced form estimates use {stan_data$num_obs} individuals' deworming status.

        #     Private utility derived from each treatment doesn't vary with distance, therefore we only display Combined results 
        #     in the interest of brevity.

        #     Whilst credibility intervals overlap for bracelet vs calendar comparison, the posterior estimates are highly 
        #     correlated and therefore the probability that bracelet exceeds calendar is very low.
        #     "
        # ) 
  )


te_kbl_df %>%
  custom_save_latex_table(
    "te-table"
  )

x = 1 + 5
te_kbl_df 

```


#### Split Table ####
```{r}
#| overall-table-only

overall_te_kbl_df = te_input_df %>%
  filter(Estimand == "incentive" | Treatment == "Control mean") %>%
  arrange(Estimand, Treatment) %>%
  mutate(
    Estimand = if_else(
      Treatment == "Ink", 
      Estimand, 
      factor("")
    )
  ) %>%
  select(-Estimand) %>%
  kbl(
    col.names = c(
      # "Estimand", 
      # "Treatment", 
      "Dependent variable: Take-up",
      paste0("(", 1:6, ")")
    ), 
    format = "latex", 
    linesep = "\\addlinespace \\addlinespace \\addlinespace",
    booktabs = TRUE, 
    escape = FALSE, 
    align = "lcccccc", 
    caption = "Results"
  ) %>%
  kable_styling(
    latex_options = c("scale_down")
  ) %>%
  add_header_above(
    c(" ", 
      "Combined", 
      "Close", 
      "Far",
      "Combined", 
      "Close", 
      "Far"
      ), 
    line = FALSE
  ) %>%
  add_header_above(
    c(
      " " = 1,
      "Reduced Form" = 3, 
      "Structural" = 3
      )
  ) %>%
  # add_indent(4) %>%
  row_spec(4, hline_after = TRUE) %>%
  add_indent(1:5) %>%
  footnote(
    escape = FALSE,
    threeparttable = TRUE,
    # general = 
    #     str_glue(
    #         "Point estimates represent posterior means, 90\\\\% percent credibility intervals are shown in parentheses.
    #         'Overall' indicates the total treatment effect; 'Signalling' and 'Private' use the structural model to 
    #         isolate the effect of reputational returns and the private utility derived from each treatment. 
    #         \\\\textit{{Bracelet - Calendar}} shows the posterior difference in takeup across bracelet and calendar conditions.
    #         Structural estimates use all three samples: {stan_data$num_obs} individuals' deworming status; {stan_data$num_beliefs_obs} individual's elicited first-order beliefs; and 
    #         data from {stan_data$num_wtp_obs} individual's Willingness-To-Pay choices. Reduced form estimates use {stan_data$num_obs} individuals' deworming status.

    #         Private utility derived from each treatment doesn't vary with distance, therefore we only display Combined results 
    #         in the interest of brevity.

    #         Whilst credibility intervals overlap for bracelet vs calendar comparison, the posterior estimates are highly 
    #         correlated and therefore the probability that bracelet exceeds calendar is very low.
    #         "
    #     ) 
  )


overall_te_kbl_df %>%
  custom_save_latex_table(
    "overall-te-table"
  )

overall_te_kbl_df

```


```{r}

decomposed_te_kbl_df = te_input_df %>%
  select(-contains("rf_")) %>%
  filter(Estimand == "private" | Estimand == "signal" | Treatment == "Control mean") %>%
  arrange(Estimand, Treatment) %>%
  mutate(
    Estimand = if_else(
      Treatment == "Ink", 
      Estimand, 
      factor("")
    )
  ) %>%
  select(-Estimand) %>%
  kbl(
    col.names = c(
      # "Estimand", 
      # "Treatment", 
      "Dependent variable: Take-up",
      paste0("(", 1:3, ")")
    ), 
    format = "latex", 
    linesep = "\\addlinespace \\addlinespace \\addlinespace",
    booktabs = TRUE, 
    escape = FALSE, 
    align = "lccc", 
    caption = "Results"
  ) %>%
  kable_styling(
    # latex_options = c("scale_down")
  ) %>%
  add_header_above(
    c(" ", 
      "Combined", 
      "Close", 
      "Far"
      ), 
    line = FALSE
  ) %>%
  add_header_above(
    c(
      " " = 1,
      "Structural" = 3
      )
  ) %>%
  pack_rows(
    index = c(
      "Panel A: Signal" = 4, 
      "Panel B: Private" = 3
    ), 
    italic = TRUE,
    escape = FALSE,
    # latex_gap_space = latex_group_gap_space, 
    hline_after = TRUE, 
    hline_before = TRUE,
    bold = TRUE
  ) %>%
  row_spec(7, hline_after = TRUE) %>%
  add_indent(1:8) %>%
  footnote(
    escape = FALSE,
    threeparttable = TRUE,
    # general = 
    #     str_glue(
    #         "Point estimates represent posterior means, 90\\\\% percent credibility intervals are shown in parentheses.
    #         'Overall' indicates the total treatment effect; 'Signalling' and 'Private' use the structural model to 
    #         isolate the effect of reputational returns and the private utility derived from each treatment. 
    #         \\\\textit{{Bracelet - Calendar}} shows the posterior difference in takeup across bracelet and calendar conditions.
    #         Structural estimates use all three samples: {stan_data$num_obs} individuals' deworming status; {stan_data$num_beliefs_obs} individual's elicited first-order beliefs; and 
    #         data from {stan_data$num_wtp_obs} individual's Willingness-To-Pay choices. Reduced form estimates use {stan_data$num_obs} individuals' deworming status.

    #         Private utility derived from each treatment doesn't vary with distance, therefore we only display Combined results 
    #         in the interest of brevity.

    #         Whilst credibility intervals overlap for bracelet vs calendar comparison, the posterior estimates are highly 
    #         correlated and therefore the probability that bracelet exceeds calendar is very low.
    #         "
    #     ) 
  )

decomposed_te_kbl_df %>%
  custom_save_latex_table(
    "private-signal-te-table"
  )

decomposed_te_kbl_df


```


```{r}
#| beliefs


belief_data = dist_fit_data %>%
  filter(fct_match(fit_type, "fit"), fct_match(model_type, "structural")) %>%
  pull(beliefs_results) %>%
  first() 

belief_close_far_input_df = belief_data$ate_knows %>%
  filter(assigned_treatment_left != "control") %>%
  filter(assigned_treatment_right == "control") %>%
  mutate(assigned_treatment_left = fct_drop(assigned_treatment_left))  %>%
  filter(assigned_dist_group_right == assigned_dist_group_left) %>%
  mutate(treatment = fct_relabel(assigned_treatment_left, str_to_title))  %>%
  select(
    treatment, 
    distance = assigned_dist_group_right, 
    estimate = per_0.5, 
    conf.low = per_0.05, 
    conf.high = per_0.95, 
    order = ord
  )


#### Belief ATEs combined ####
belief_data_control = belief_data$prob_knows %>%
    filter(assigned_treatment == "control")  %>%
    select(assigned_treatment, assigned_dist_group, iter_data, ord) %>%
    unnest(iter_data)

combined_belief_ate = belief_data$prob_knows %>%
    filter(assigned_treatment != "control") %>%
    select(assigned_treatment, iter_data, ord) %>%
    unnest(iter_data) %>%
    rename(assigned_treatment_left = assigned_treatment) %>%
    left_join(
        belief_data_control %>% 
            rename(assigned_treatment_right = assigned_treatment) %>%
            select(iter_est_right = iter_est, iter_id, ord, assigned_treatment_right),
        by = c("iter_id", "ord")
    ) %>%
    mutate(
        iter_est_te = iter_est - iter_est_right
    )  %>%
    select(-.chain, -.iteration, -.draw) %>%
    nest(iter_data = c(iter_id, iter_est_te, iter_est, iter_est_right)) %>%
    mutate(
        mean_est = map_dbl(iter_data, ~mean(.x$iter_est_te)), 
        quants = map(iter_data, quantilize_est, iter_est_te, quant_probs = quant_probs, na.rm = TRUE)
    )  %>%
    unnest(quants) %>%
    mutate(assigned_dist_group_left = "Combined", assigned_dist_group_right = "Combined") %>%
    mutate(
        assigned_treatment_left = fct_drop(assigned_treatment_left), 
        assigned_treatment_right = fct_drop(assigned_treatment_right)
    )  %>%
    mutate(treatment = fct_relabel(assigned_treatment_left, str_to_title))  %>%
    select( 
      treatment = treatment, 
      distance = assigned_dist_group_right, 
      estimate = per_0.5, 
      conf.low = per_0.05,
      conf.high = per_0.95,
      order = ord
    )


belief_input_df = bind_rows(
  belief_close_far_input_df,
  combined_belief_ate
) %>% 
  mutate(
    distance = str_to_title(distance), 
    treatment = fct_rev(treatment), 
    distance = factor(distance, levels = c("Combined", "Close", "Far"))
    )



wide_belief_input_df = belief_input_df %>%
  mutate(across(where(is.numeric), round, 3)) %>%
  mutate(
    estim_value = linebreak(
      paste0(estimate, "\n", "(", conf.low, ", ", conf.high, ")"), 
      align = "c"
      )
  ) %>%
  select(treatment, distance, order, estim_value) %>%
  pivot_wider(
    names_from = c(distance, order), 
    values_from = estim_value
  ) %>%
  select( 
    treatment, 
    contains("_1"), 
    contains("_2")
  ) %>%
  arrange(treatment)  %>%
  select(
    treatment, 
    Combined_1, 
    Close_1,
    Far_1, 
    Combined_2, 
    Close_2, 
    Far_2
  )


wide_belief_tbl = wide_belief_input_df %>%
  kbl(
    col.names = c(
      # "Estimand", 
      # "Treatment", 
      "",
      paste0("(", 1:6, ")")
    ), 
    # format = "latex", 
    booktabs = TRUE, 
    escape = FALSE, 
    align = "lcccccc", 
    caption = "Beliefs Results"
  ) %>%
  kable_styling(
    # latex_options = c("scale_down")
  ) %>%
  add_header_above(
    c(" ", 
      "Combined",
      "Close", 
      "Far", 
      "Combined",
      "Close", 
      "Far"
      ), 
    line = FALSE
  )  %>%
  add_header_above(
    c(
      " " = 1,
      "First-Order Beliefs" = 3, 
      "Second-Order Beliefs" = 3
      )
  ) %>%
  footnote(
    escape = FALSE,
    threeparttable = TRUE,
    # general = 
    #     str_glue(
    #         "Point estimates represent posterior means, 90\\\\% percent credibility intervals are shown in parentheses.
    #         {stan_data$num_beliefs_obs} individual's elicited first-order beliefs.
    #         "
    #     ) 
  )
wide_belief_tbl

wide_belief_tbl %>%
  custom_save_latex_table(
    "beliefs-table"
  )
```



```{r}
#| disagg-beliefs



disagg_base_belief_data = analysis_data %>%
  mutate(assigned_treatment = assigned.treatment, assigned_dist_group = dist.pot.group) %>%
  nest_join(
    endline.know.table.data %>% 
      filter(fct_match(know.table.type, "table.A")),
    by = "KEY.individ", 
    name = "knowledge_data"
  ) %>% 
  mutate(
    map_dfr(knowledge_data, ~ {
      tibble(
        obs_know_person = sum(.x$num.recognized),
        obs_know_person_prop = mean(.x$num.recognized),
        knows_other_dewormed = sum(fct_match(.x$dewormed, c("yes", "no")), na.rm = TRUE),
        knows_other_dewormed_yes = sum(fct_match(.x$dewormed, "yes"), na.rm = TRUE),
        knows_other_dewormed_no = sum(fct_match(.x$dewormed, "no"), na.rm = TRUE),
        thinks_other_knows = sum(fct_match(.x$second.order, c("yes", "no")), na.rm = TRUE),
        thinks_other_knows_yes = sum(fct_match(.x$second.order, "yes"), na.rm = TRUE),
        thinks_other_knows_no = sum(fct_match(.x$second.order, "no"), na.rm = TRUE),
      )
    }
  )) %>%
    filter(obs_know_person > 0)  %>%
    select(KEY.individ, contains("know"), assigned.treatment, dist.pot.group, assigned_dist_group) %>%
    mutate(
        doesnt_know_other_dewormed = obs_know_person - knows_other_dewormed, 
        doesnt_think_other_knows = obs_know_person - thinks_other_knows
    ) %>% 
    select(KEY.individ, 
           assigned.treatment,
           assigned_dist_group,
           obs_know_person,
           knows_other_dewormed_yes,
           knows_other_dewormed_no,
           doesnt_know_other_dewormed, 
           thinks_other_knows_yes, 
           thinks_other_knows_no, 
           doesnt_think_other_knows
           ) %>%
    gather(variable, value, 
        knows_other_dewormed_yes:doesnt_think_other_knows)   %>%
    mutate(knowledge_type = case_when(
        str_detect(variable, "_yes") ~ "yes",
        str_detect(variable, "_no") ~ "no",
        str_detect(variable, "doesnt") ~ "doesn't know"
    )) %>%
    mutate(belief_type = if_else(str_detect(variable, "think"), "2ord", "1ord")) %>%
    mutate(prop = value/obs_know_person) 

cv = function(alpha){
  qnorm(1 - (alpha/2))
}

close_far_disagg_belief = disagg_base_belief_data  %>%
    group_by(assigned.treatment, assigned_dist_group, knowledge_type, belief_type)  %>%
    summarise(
        mean_est = mean(prop), 
        std.error = sd(prop)/sqrt(n()),
        per_0.5 = mean(prop), 
        per_0.05 = per_0.5 - cv(0.05)*std.error, 
        per_0.95 = per_0.5 + cv(0.05)*std.error,
        per_0.1 =  per_0.5 - cv(0.1)*std.error,
        per_0.9 =  per_0.5 + cv(0.1)*std.error,
        per_0.25 =  per_0.5 - cv(0.5)*std.error,
        per_0.75 =  per_0.5 + cv(0.5)*std.error
    ) %>%
    mutate(
      knowledge_type = factor(knowledge_type, levels = c("yes", "no", "doesn't know")), 
      knowledge_type = fct_relabel(knowledge_type, str_to_title) %>% fct_rev
    ) %>%
    mutate(
      assigned.treatment = factor(assigned.treatment, 
                                  levels = c("bracelet",
                                             "calendar", 
                                             "ink",
                                             "control")) %>%
                          fct_relabel(str_to_title) %>%
                          fct_rev
    )


cv = function(alpha){
  qnorm(1 - (alpha/2))
}

combined_disagg_belief = disagg_base_belief_data  %>%
    group_by(assigned.treatment, knowledge_type, belief_type)  %>%
    summarise(
        mean_est = mean(prop), 
        std.error = sd(prop)/sqrt(n()),
        per_0.5 = mean(prop), 
        per_0.05 = per_0.5 - cv(0.05)*std.error, 
        per_0.95 = per_0.5 + cv(0.05)*std.error,
        per_0.1 =  per_0.5 - cv(0.1)*std.error,
        per_0.9 =  per_0.5 + cv(0.1)*std.error,
        per_0.25 =  per_0.5 - cv(0.5)*std.error,
        per_0.75 =  per_0.5 + cv(0.5)*std.error
    ) %>%
    mutate(
      knowledge_type = factor(knowledge_type, levels = c("yes", "no", "doesn't know")), 
      knowledge_type = fct_relabel(knowledge_type, str_to_title) %>% fct_rev
    ) %>%
    mutate(
      assigned.treatment = factor(assigned.treatment, 
                                  levels = c("bracelet",
                                             "calendar", 
                                             "ink",
                                             "control")) %>%
                          fct_relabel(str_to_title) %>%
                          fct_rev
    ) %>%
    mutate(
      assigned_dist_group = "Combined"
    )


comp_belief_data = bind_rows(
  combined_disagg_belief,
  close_far_disagg_belief
)




```


```{r}


wide_disagg_belief_input_df = comp_belief_data %>%
  select(
    treatment = assigned.treatment, 
    distance = assigned_dist_group, 
    knowledge_type,
    mean_est, 
    per_0.05, 
    per_0.95, 
    ord = belief_type
  )  %>%
  mutate(across(where(is.numeric), round, 3)) %>%
  mutate(
    estim_value = linebreak(
      paste0(mean_est, "\n", "(", per_0.05, ", ", per_0.95, ")"), 
      align = "c"
      )
  ) %>%
  select( 
    treatment,
    distance, 
    knowledge_type, 
    ord, 
    estim_value
  ) %>%
  mutate(ord = factor(ord, levels = c("1ord", "2ord"))) %>%
  pivot_wider(
    names_from = c(ord, distance), 
    values_from = estim_value
  ) %>%
  select(
    treatment, knowledge_type, 
    contains("1ord"), 
    contains("2ord")
  ) %>%
  mutate(
    treatment = fct_rev(treatment)
  ) %>%
  select(
    treatment, knowledge_type, `1ord_Combined`, `1ord_close`, `1ord_far`, 
    `2ord_Combined`, `2ord_close`, `2ord_far`
  )




all_wide_disagg_belief_tbl = wide_disagg_belief_input_df %>%
  arrange(treatment) %>%
  ungroup() %>%
  select(-treatment) %>%
  kbl(
    col.names = c(
      # "Estimand", 
      # "Treatment", 
      "Knowledge",
      paste0("(", 1:6, ")")
    ), 
    format = "latex", 
    booktabs = TRUE, 
    escape = FALSE, 
    align = "lcccccc", 
    caption = "Beliefs Results"
  ) %>%
  kable_styling(
    # latex_options = c("scale_down")
  ) %>%
  add_header_above(
    c(" ", 
      "Combined", 
      "Close", 
      "Far", 
      "Combined",
      "Close", 
      "Far"
      ), 
    line = FALSE
  )  %>%
  add_header_above(
    c(
      " " = 1,
      "First-Order Beliefs" = 3, 
      "Second-Order Beliefs" = 3
      )
  ) %>%
  group_rows(
    index = c(
      "Bracelet" = 3,
      "Calendar" = 3,
      "Ink" = 3,
      "Control" = 3
    ), 
    hline_after = TRUE,
    hline_before = TRUE
  ) %>%
  footnote(
    escape = FALSE,
    threeparttable = TRUE,
    # general = 
    #     str_glue(
    #         "Point estimates represent posterior means, 90\\\\% percent credibility intervals are shown in parentheses.
    #         {stan_data$num_beliefs_obs} individual's elicited first-order beliefs.
    #         "
    #     ) 
  )

all_wide_disagg_belief_tbl

all_wide_disagg_belief_tbl %>%
  custom_save_latex_table(
    "all-disagg-beliefs-table"
  )


```



```{r}

wide_disagg_belief_tbl = wide_disagg_belief_input_df %>%
  select(-contains("2")) %>%
  arrange(treatment) %>%
  ungroup() %>%
  select(-treatment) %>%
  kbl(
    col.names = c(
      # "Estimand", 
      # "Treatment", 
      "Knowledge",
      paste0("(", 1:3, ")")
    ), 
    format = "latex", 
    booktabs = TRUE, 
    escape = FALSE, 
    align = "lcccccc", 
    caption = "Beliefs Results"
  ) %>%
  kable_styling(
    # latex_options = c("scale_down")
  ) %>%
  add_header_above(
    c(" ", 
      "Combined", 
      "Close", 
      "Far"
      ), 
    line = FALSE
  )  %>%
  add_header_above(
    c(
      " " = 1,
      "First-Order Beliefs" = 3
      )
  ) %>%
  group_rows(
    index = c(
      "Bracelet" = 3,
      "Calendar" = 3,
      "Ink" = 3,
      "Control" = 3
    ), 
    hline_after = TRUE,
    hline_before = TRUE
  ) %>%
  footnote(
    escape = FALSE,
    threeparttable = TRUE,
    # general = 
    #     str_glue(
    #         "Point estimates represent posterior means, 90\\\\% percent credibility intervals are shown in parentheses.
    #         {stan_data$num_beliefs_obs} individual's elicited first-order beliefs.
    #         "
    #     ) 
  )

wide_disagg_belief_input_df



wide_disagg_belief_tbl %>%
  custom_save_latex_table(
    "fob-disagg-beliefs-table"
  )
```



#### WTP Table ####


```{r}
1+1
wtp_summ_df = dist_fit_data %>% 
  filter(fct_match(model_type, "structural")) %>% 
  pull(wtp_results) %>%
  first()  %>%
  group_by(variable)  %>%
  filter(variable == "hyper_wtp_mu") %>%
  select( 
    per_0.5,
    per_0.05, 
    per_0.95
  ) %>%
  mutate(across(where(is.numeric), ~.x*100)) %>%
  mutate(across(where(is.numeric), round, 3))



pr_wtp_greater_df = read_csv(
  file.path(
    params$output_path, 
    str_interp("wtp_phi_summary_draws_dist_fit${params$fit_version}.csv")
  )
)

pr_wtp_greater_input_df = pr_wtp_greater_df %>%
  mutate(
    variable = "$\\textrm{Pr}(V_{\\textrm{calendar}} > V_{\\textrm{bracelet}} + 0\\textrm{Ksh})$"
  ) %>%
  select(
    variable, 
    per_0.5 = phi_mu_std, 
    per_0.05 = conf.low, 
    per_0.95 = conf.high) 

misc_param_summaries = read_csv(
  file.path(
      params$output_path,
      str_glue("misc_processed_dist_fit{params$fit_version}.csv")
  )
) %>%
  mutate(across(where(is.numeric), ~.x*100)) %>%
  mutate(across(where(is.numeric), round, 2))


wtp_summ_input_df = bind_rows(
  wtp_summ_df,
  misc_param_summaries %>%
    filter(variable == "wtp_sigma"),
   pr_wtp_greater_input_df,
  dist_fit_data %>% 
    filter(fct_match(model_type, "structural")) %>% 
    pull(wtp_results) %>%
    first()  %>%
    filter(variable == "prob_prefer_calendar") %>%
    left_join(tibble(index = 1:21, val_diff = -seq(-100, 100, 10)), by = "index")  %>%
    filter(val_diff %in% c(50, 0, -50)) %>%
    select(variable, val_diff, per_0.5, per_0.05, per_0.95) %>%
    mutate(
      variable = "Pr(prefer calendar)",
      variable = paste0(
        variable, ", offered: ", val_diff, "KSh"
      )
    ) %>%
    select(-val_diff)
) 



wtp_summ_tbl = wtp_summ_input_df %>%
  mutate(
    variable = case_when(
      variable == "hyper_wtp_mu" ~ "Valuation difference (Ksh) mean, $\\mu$", 
      variable == "wtp_sigma" ~ "Valuation difference (Ksh) standard deviation, $\\sigma$", 
      TRUE ~ variable
      )
  ) %>%
  mutate(across(where(is.numeric), round, 3)) %>%
  mutate(
    estim_value = 
      linebreak(
        paste0(per_0.5, "\n", "(", per_0.05, ", ", per_0.95, ")"), 
        align = "c"
        )
  ) %>%
  select( 
    variable, estim_value
  ) %>%
  kbl(
    col.names = c("Parameter", "Posterior estimates"), 
    booktabs = TRUE, 
    escape = FALSE,
    format = "latex",
    align = "lc"
  ) %>%
  pack_rows(
    index = c(
      "Panel A: Model parameters" = 2, 
      "Panel B: Estimated preferences" = 4
    ), 
    italic = TRUE,
    escape = FALSE,
    # latex_gap_space = latex_group_gap_space, 
    hline_after = TRUE, 
    hline_before = TRUE,
    bold = TRUE
  )  %>%
  footnote(
    escape = FALSE,
    threeparttable = TRUE,
  )



wtp_summ_tbl

wtp_summ_tbl %>%
  custom_save_latex_table(
    "wtp-summ-table"
  )
  
  

```

```{r}

all_optim_df = read_csv(
  file.path(
    params$optim_input_path,
    "posterior-clean-summ-optim.csv"
  )
) 


all_optim_df %>%
  filter(rep_type  == "rep") %>%
  filter(
    private_benefit_z == "control" & visibility_z == "bracelet"
  ) %>%
  summarise(
    mean = mean(n_pot), 
    conf.low = quantile(n_pot, 0.05), 
    conf.high = quantile(n_pot, 0.95)
  )



summ_optim_df = all_optim_df %>%
        group_by(
            private_benefit_z,
            visibility_z, 
            model, 
            rep_type,
            cutoff_type
        ) %>%
        filter(
            model %in% models_we_want
        ) %>%
        filter(
            cutoff_type  == "cutoff"
        ) %>%
        summarise(
            across(
                everything(),
                list(
                    estimate = mean,
                    CI = ~paste0("(", round(quantile(.x, 0.025), 3), ", ", round(quantile(.x, 0.975), 3), ")")
                )
            )
        )   %>%
        ungroup() %>%
        select(-model, -cutoff_type) %>%
        arrange(
            private_benefit_z,
            visibility_z,
            rep_type
        ) %>%
    rename(
        B_z = private_benefit_z, 
        mu_z = visibility_z
    )


wide_summ_df_rep = summ_optim_df %>%
  filter(rep_type == "rep") %>%
  gather(variable, value, -B_z, -mu_z)  %>%
  mutate(CI = if_else(str_detect(variable, "CI"), "ci", "estim")) %>%
  mutate(variable = str_remove(variable, "_CI")) %>%
  mutate(variable = str_remove(variable, "_estimate")) %>%
  pivot_wider(
    id_cols = c(B_z, mu_z, variable), 
    names_from = CI, 
    values_from = value
  )   %>%
  mutate(estim = as.numeric(estim) %>% round(3))  %>%
  mutate(
    estim_value = 
    linebreak(
      paste0(
        estim, "\n", 
        ci
      ), 
      align = "c"
    )
  ) %>%
  select(
    -estim, -ci
  )  %>%
  spread(variable, estim_value)

wide_summ_df_sup_rep = summ_optim_df %>%
  filter(rep_type == "suppress_rep")  %>%
  gather(variable, value, -B_z, -mu_z)  %>%
  mutate(CI = if_else(str_detect(variable, "CI"), "ci", "estim")) %>%
  mutate(variable = str_remove(variable, "_CI")) %>%
  mutate(variable = str_remove(variable, "_estimate")) %>%
  pivot_wider(
    id_cols = c(B_z, mu_z, variable), 
    names_from = CI, 
    values_from = value
  )   %>%
  mutate(estim = as.numeric(estim) %>% round(3))  %>%
  mutate(
    estim_value = 
    linebreak(
      paste0(
        estim, "\n", 
        ci
      ), 
      align = "c"
    )
  ) %>%
  select(
    -estim, -ci
  )  %>%
  spread(variable, estim_value)




optim_summ_input_df = bind_rows(
  wide_summ_df_rep %>% 
    mutate(rep_type = "rep") %>%
    filter(B_z == "control"),
  wide_summ_df_sup_rep %>% mutate(rep_type = "suppress_rep") %>% filter(B_z == mu_z)
) %>%
  mutate(
    mu_z = if_else(rep_type == "suppress_rep", "No visibility", mu_z)
  ) %>%
  mutate(mu_z = factor(mu_z, c("bracelet", "calendar", "ink", "control", "No visibility")))  %>%
  mutate(B_z = factor(B_z, c("bracelet", "calendar", "ink", "control")))  %>%
  mutate(B_z = fct_relabel(B_z, str_to_title)) %>%
  mutate(mu_z = fct_relabel(mu_z, str_to_title))

optim_summ_tbl = optim_summ_input_df %>%
  arrange(rep_type, mu_z, B_z) %>%
  select(B_z, mu_z, n_pot, mean_demand, overshoot) %>%
  knitr::kable(
    col.names = c(
      "Private Benefit", 
      "Visibility",
      "Assigned PoTs", 
      "Mean Take-up", 
      "Percent Overshoot"
    ),
    align = "llccc",
    booktabs = TRUE,
    format = "latex",
    escape = FALSE
    ) %>%
  kableExtra::kable_styling(
    # latex_options =  c("scale_down")
  ) %>%
  pack_rows(
    index = c(
      "Panel A: Visibility" = 4, 
      "Panel B: No visibility" = 4
    ), 
    italic = TRUE,
    escape = FALSE,
    # latex_gap_space = latex_group_gap_space, 
    hline_after = TRUE, 
    hline_before = TRUE,
    bold = TRUE
  ) 


optim_summ_tbl %>%
  custom_save_latex_table("optim-summ-table")

optim_summ_tbl 

```