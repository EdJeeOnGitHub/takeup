---
title: "TakeUp Bayesian Analysis Notebook"
author:
- Anne Karing^[University of California Berkeley]
- Karim Naguib^[Evidence Action]
output:
  html_notebook:
    fig_align: "center"
    fig_caption: yes
    fig_height: 5
    fig_width: 8
    number_sections: yes
    theme: flatly
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 5
header-includes:
   - \usepackage{bbm}
date: "`r format(Sys.time(), '%B %d, %Y')`"
---

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r setup, include=FALSE}
library(magrittr)
library(purrr)
library(plyr)
library(dplyr)
library(multidplyr)
library(tibble)
library(tidyr)
library(lubridate)
library(forcats)
library(readr)
library(haven)
library(broom)
library(ggplot2)
library(ggrepel)
library(ggmap)
library(stringr)
library(knitr)
library(modelr)
library(rstan)

library(econometr)

source("takeup_rct_assign_clusters.R")
source("analysis_util.R")

knitr::read_chunk("analysis_util.R", labels = "analysis-util")

config <- yaml::yaml.load_file("../local_config.yaml")

options(dplyr.show_progress = FALSE, digits = 4, mc.cores = max(1, parallel::detectCores() - 1))
```

```{r load-data, include=FALSE}
load(file.path("data", "analysis.RData"))
```

```{stan, output.var="basic_model_0"}
data {
  int<lower = 0> num_obs;
  int<lower = 1> num_treatments;
  int<lower = 1> num_clusters;
  int<lower = 1> num_strata;
  
  int<lower = 1, upper = num_clusters> cluster_id[num_obs];
  int<lower = 1, upper = num_strata> stratum_id[num_clusters];
 
  matrix[num_obs, num_treatments] treatment_design_matrix;
 
  // Binary deworming outcome 
  
  int<lower = 0, upper = 1> dewormed_any[num_obs];
}

parameters {
  real<lower=-4, upper=10> mu_strata; // uniformly distributed

  //vector[num_strata] stratum_intercept;
  real stratum_intercept[num_strata];
  vector[num_treatments] beta;
  
  // vector[num_treatments] mu; // Hyperparameter for beta_stratum
  
  // Scale hyperparameters for betas 
  
  // corr_matrix[num_treatments] Omega_beta;
  vector<lower = 0>[num_treatments] tau_beta;
}

model {
  // Some hyperpriors with temp parameter values from the Stan Manual
  
  //Omega_beta ~ lkj_corr(50);
  tau_beta ~ cauchy(0, 10);
  //tau_beta ~ normal(0, 2);
  //tau_beta ~ gamma(2, 1/10);
  
  //mu ~ normal(0, 100);
  
  stratum_intercept ~ normal(mu_stratum, 100);
  
  // beta ~ multi_normal(mu, quad_form_diag(Omega_beta, tau_beta));
  beta ~ normal(0, tau_beta);
  
  // dewormed_any ~ bernoulli_logit(treatment_design_matrix * beta);
  dewormed_any ~ bernoulli_logit(stratum_intercept[stratum_id[cluster_id]] + treatment_design_matrix * beta);
}

```

```{r}
basic_model_0_fit <- analysis.data %>% 
  filter(monitored, sms.treatment.2 == "sms.control", !hh.baseline.sample) %>% 
  mutate(new_cluster_id = factor(cluster.id) %>% as.integer()) %>% 
  anti_join(outlier.cells, c("assigned.treatment","sms.treatment", "mon_status", "cluster.id")) %>% {
    lst(
      #treatment_design_matrix = model_matrix(., ~ assigned.treatment - 1),
      treatment_design_matrix = model_matrix(., ~ assigned.treatment) %>% 
        magrittr::extract(, -1),
      
      cluster_id = .$new_cluster_id,
      stratum_id = distinct(., new_cluster_id, county_dist_stratum) %>% 
        arrange(new_cluster_id) %$% 
        as.integer(county_dist_stratum),
      
      dewormed_any = .$dewormed.any,
      
      num_obs = nrow(treatment_design_matrix),
      num_treatments = ncol(treatment_design_matrix),
      num_clusters = n_distinct(cluster_id),
      num_strata = n_distinct(stratum_id)
    )
  } %>% 
  sampling(basic_model_0, data = ., control = lst(adapt_delta = 0.99, max_treedepth = 15))

basic_model_0_fit
```

```{stan, output.var="basic_model_1"}
data {
  int<lower = 0> num_obs;
  int<lower = 1> num_treatments;
  int<lower = 1> num_clusters;
  int<lower = 1> num_strata;
  
  int<lower = 1, upper = num_obs> individ_id[num_obs];
  int<lower = 1, upper = num_clusters> cluster_id[num_obs];
  int<lower = 1, upper = num_strata> stratum_id[num_clusters];
 
  matrix[num_obs, num_treatments] treatment_design_matrix;
  matrix[num_obs * (num_treatments - 1), num_treatments] treatment_design_matrix;
 
  // Binary deworming outcome 
  
  int<lower = 0, upper = 1> dewormed_any[num_obs];
}

transformed data {
  int <lower = 0> num_missing_treatments = num_treatments - 1; // Number of unobserved counterfactuals
}

parameters {
  vector[num_treatments] beta_stratum[num_strata];
  
  vector[num_treatments] mu; // Hyperparameter for beta_stratum
  
  // Scale hyperparameters for betas 
  
  corr_matrix[num_treatments] Omega_strata;
  vector<lower = 0>[num_treatments] tau_strata;
}

model {
  // Some hyperpriors with temp parameter values from the Stan Manual
  
  Omega_strata ~ lkj_corr(2);
  tau_strata ~ cauchy(0, 2.5);
  
  mu ~ normal(0, 100);
  
  // Model treatment effects hierarchical over clusters and strata
  
  for (stratum_index in 1:num_strata) {
    beta_stratum[stratum_index] ~ multi_normal(mu, quad_form_diag(Omega_strata, tau_strata));
  }
  
  // Model the outcome (deworming) in response to experimental treatment
  
  { // The part in this block apparently optimizes analysis
    vector[num_obs] treatment_beta_cluster;
    
    for (i in 1:num_obs) {
      treatment_beta_cluster[i] = treatment_design_matrix[i] * beta_stratum[stratum_id[cluster_id[i]]];
    }
    
    dewormed_any ~ bernoulli_logit(treatment_beta_cluster);
  }
}
```

```{r}
#analysis.data %>% semi_join(data_grid(., KEY.individ, assigned.treatment), ., c("KEY.individ", "assigned.treatment")) %>% arrange(KEY.individ)

basic_model_1_fit <- analysis.data %>% 
  filter(monitored, sms.treatment.2 == "sms.control", !hh.baseline.sample) %>% 
  mutate(new_cluster_id = factor(cluster.id) %>% as.integer()) %>% 
  anti_join(outlier.cells, c("assigned.treatment","sms.treatment", "mon_status", "cluster.id")) %>% {
    lst(
      treatment_design_matrix = model_matrix(., ~ assigned.treatment),
      cluster_id = .$new_cluster_id,
      stratum_id = distinct(., new_cluster_id, county_dist_stratum) %>% 
        arrange(new_cluster_id) %$% 
        as.integer(county_dist_stratum),
      
      dewormed_any = .$dewormed.any,
      
      num_obs = nrow(treatment_design_matrix),
      num_treatments = ncol(treatment_design_matrix),
      num_clusters = n_distinct(cluster_id),
      num_strata = n_distinct(stratum_id)
    )
  } %>% 
  sampling(basic_model_1) #, control = lst(max_treedepth = 15, adapt_delta = 0.99))
```

```{stan, output.var="basic_model"}
data {
  int<lower = 0> num_obs;
  int<lower = 1> num_treatments;
  int<lower = 1> num_clusters;
  int<lower = 1> num_strata;
  
  int<lower = 1, upper = num_clusters> cluster_id[num_obs];
  int<lower = 1, upper = num_strata> stratum_id[num_clusters];
 
  matrix[num_obs, num_treatments] treatment_design_matrix;
 
  // Binary deworming outcome 
  
  int<lower = 0, upper = 1> dewormed_any[num_obs];
}

transformed data {
  int <lower = 0> num_missing_treatments = num_treatments - 1; // Number of unobserved counterfactuals
}

parameters {
  // We only observe one treatment per cluster so we're actually imputing the betas for the counterfactuals
  vector[num_treatments] beta_cluster[num_clusters]; 
  vector[num_treatments] beta_stratum[num_strata];
  
  vector[num_treatments] mu; // Hyperparameter for beta_stratum
  
  // Scale hyperparameters for betas 
  
  corr_matrix[num_treatments] Omega_strata;
  vector<lower = 0>[num_treatments] tau_strata;
  
  corr_matrix[num_treatments] Omega_clusters;
  vector<lower = 0>[num_treatments] tau_clusters;
}

model {
  // Some hyperpriors with temp parameter values from the Stan Manual
  
  Omega_strata ~ lkj_corr(2);
  tau_strata ~ cauchy(0, 2.5);
  
  Omega_clusters ~ lkj_corr(2);
  tau_clusters ~ cauchy(0, 2.5);
  
  mu ~ normal(0, 100);
  
  // Model treatment effects hierarchical over clusters and strata
  
  for (stratum_index in 1:num_strata) {
    beta_stratum[stratum_index] ~ multi_normal(mu, quad_form_diag(Omega_strata, tau_strata));
  }
  
  for (cluster_index in 1:num_clusters) {
    beta_cluster[cluster_index] ~ multi_normal(beta_stratum[stratum_id[cluster_index]], quad_form_diag(Omega_clusters, tau_clusters));
  }
  
  // Model the outcome (deworming) in response to experimental treatment
  
  { // The part in this block apparently optimizes analysis
    vector[num_obs] treatment_beta_cluster;
    
    for (i in 1:num_obs) {
      treatment_beta_cluster[i] = treatment_design_matrix[i] * beta_cluster[cluster_id[i]];
    }
    
    dewormed_any ~ bernoulli_logit(treatment_beta_cluster);
  }
}
```

```{r}
basic_model_fit <- analysis.data %>% 
  filter(monitored, sms.treatment.2 == "sms.control", !hh.baseline.sample) %>% 
  mutate(new_cluster_id = factor(cluster.id) %>% as.integer()) %>% 
  anti_join(outlier.cells, c("assigned.treatment","sms.treatment", "mon_status", "cluster.id")) %>% {
    lst(
      treatment_design_matrix = model_matrix(~ assigned.treatment, data = .),
      cluster_id = .$new_cluster_id,
      stratum_id = distinct(., new_cluster_id, county_dist_stratum) %>% 
        arrange(new_cluster_id) %$% 
        as.integer(county_dist_stratum),
      
      dewormed_any = .$dewormed.any,
      
      num_obs = nrow(treatment_design_matrix),
      num_treatments = ncol(treatment_design_matrix),
      num_clusters = n_distinct(cluster_id),
      num_strata = n_distinct(stratum_id)
    )
  } %>% 
  sampling(basic_model, control = lst(max_treedepth = 15, adapt_delta = 0.99))
```

