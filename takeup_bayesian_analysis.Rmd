---
title: "TakeUp Bayesian Analysis Notebook"
author:
- Anne Karing^[University of California Berkeley]
- Karim Naguib^[Evidence Action]
output:
  html_notebook:
    fig_align: "center"
    fig_caption: yes
    fig_height: 5
    fig_width: 8
    number_sections: yes
    theme: flatly
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 5
header-includes:
   - \usepackage{bbm}
date: "`r format(Sys.time(), '%B %d, %Y')`"
---

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r setup, include=FALSE}
library(magrittr)
library(purrr)
library(plyr)
library(dplyr)
library(multidplyr)
library(tibble)
library(tidyr)
library(lubridate)
library(forcats)
library(readr)
library(haven)
library(broom)
library(ggplot2)
library(ggrepel)
library(ggmap)
library(stringr)
library(knitr)
library(modelr)
library(rstan)

library(econometr)

source("takeup_rct_assign_clusters.R")
source("analysis_util.R")

knitr::read_chunk("analysis_util.R", labels = "analysis-util")

options(dplyr.show_progress = FALSE, digits = 4, mc.cores = max(1, parallel::detectCores()))
rstan_options(auto_write = TRUE)
```

```{r load-data, include=FALSE}
load(file.path("data", "analysis.RData"))
```

```{r name-match-priors}
name_match_false_pos_alpha <- 1
name_match_false_pos_beta <- 15

ggplot(tibble(x = c(0, 1)), aes(x)) + 
  stat_function(fun = . %>% dbeta(shape1 = name_match_false_pos_alpha, shape2 = name_match_false_pos_beta)) + 
  labs(x = "Probability of False Positive", y = "Density", title = "Prior Distribution for the Name Matching Model") +
  scale_x_continuous(breaks = seq(0, 1, 0.1))
```

```{r scale-prior-plots}
ggplot(tibble(x = c(0, 20)), aes(x)) + 
  stat_function(aes(color = "Cauchy"), fun = . %>% dcauchy(0, 2.5)) + 
  stat_function(aes(color = "Student t(2)"), fun = . %>% dt(2)) + 
  stat_function(aes(color = "Student t(4)"), fun = . %>% dt(4)) + 
  stat_function(aes(color = "Student t(7)"), fun = . %>% dt(7)) + 
  stat_function(aes(color = "N(0, 5)"), fun = . %>% dnorm(0, 5)) + 
  scale_x_continuous(breaks = seq(0, 50, 1))
```

```{r ate}
sms_control_ate <- tribble(
  ~ assigned.treatment_left, ~ assigned.treatment_right,
  "ink",                     "control",
  "calendar",                "control",
  "bracelet",                "control",
  "bracelet",                "calendar"
) %>%
  bind_rows("close" = ., "far" = ., .id = "dist.pot.group") %>% 
  bind_rows(`TRUE` = ., `FALSE` = ., .id = "phone_owner") %>%
  mutate(sms.treatment.2_left = "sms.control", sms.treatment.2_right = "sms.control",
         phone_owner = as.logical(phone_owner))  

phone_owners_ate <- tribble(
  ~ assigned.treatment_left, ~ sms.treatment.2_left, ~ assigned.treatment_right, ~ sms.treatment.2_right,
  "control",                 "reminder.only",        "control",                  "sms.control",
  "control",                 "social.info",          "control",                  "sms.control",
  "control",                 "social.info",          "control",                  "reminder.only",
  
  "ink",                     "social.info",          "control",                  "sms.control",
  "ink",                     "social.info",          "control",                  "social.info",
  "ink",                     "social.info",          "ink",                      "sms.control",
  
  "calendar",                "social.info",          "control",                  "sms.control",
  "calendar",                "social.info",          "control",                  "social.info",
  "calendar",                "social.info",          "calendar",                 "sms.control",
  
  "bracelet",                "social.info",          "control",                  "sms.control",
  "bracelet",                "social.info",          "control",                  "social.info",
  "bracelet",                "social.info",          "calendar",                 "social.info",
  "bracelet",                "social.info",          "bracelet",                 "sms.control"
) %>%
  bind_rows("close" = ., "far" = ., .id = "dist.pot.group") %>% 
  mutate(phone_owner = TRUE)  

all_ate <- bind_rows(sms_control_ate, phone_owners_ate) %>%
  mutate(hh.baseline.sample = FALSE) 
```

```{r model-data}
stan_data <- analysis.data %>%
  filter(!name_matched) %>% # | sms.treatment.2 == "sms.control") %>% 
  prepare_bayesian_analysis_data(
    wtp.data,
    treatment_map = data_grid(., assigned.treatment, dist.pot.group, sms.treatment.2, hh.baseline.sample, phone_owner) %>% 
      filter(phone_owner | sms.treatment.2 == "sms.control",
             sms.treatment.2 != "reminder.only" | assigned.treatment == "control"),
    subgroup_col = "phone_owner",
    
    all_ate = all_ate,
    
    name_match_false_pos_alpha, 
    name_match_false_pos_beta,
    
    # wtp_utility_df = 3,
    tau_mu_wtp_diff = 100,
    mu_wtp_df_student_t = 7,
    tau_sigma_wtp_diff = 50,
    sigma_wtp_df_student_t = 2.5,
  )
```

```{r basic-model-0}
basic_model_0 <- stan_model(file = "takeup_model_0.stan", model_name = "model_0")
basic_model_0_fit <- sampling(basic_model_0, data = stan_data, chains = 2, iter = 100, sample_file = file.path("stanfit", "basic_model_0.csv"), control = lst(max_treedepth = 15)) # adapt_delta = 0.99, 
```

```{r}
print(basic_model_0_fit, pars = c("non_phone_takeup", "phone_takeup", "non_phone_takeup_ate", "phone_takeup_ate"))
```

# Covariates Model

```{r covar-model-0, eval=FALSE}
covar_model_0 <- stan_model(file = "takeup_covar_model_0.stan", model_name = "covar_model_0")
covar_model_0_fit <- sampling(covar_model_0, data = stan_data, sample_file = file.path("stanfit", "covar_model_0.csv")) #, control = lst(adapt_delta = 0.99, max_treedepth = 15))
```

# Name Matching Model

```{r name-match-model-0, eval=FALSE}
name_match_model_0 <- stan_model(file = "name_matching.stan", model_name = "name_match_model_0")
name_match_model_0_fit <- sampling(name_match_model_0, iter = 4000, data = stan_data, sample_file = file.path("stanfit", "name_match_model_0.csv"), control = lst(adapt_delta = 0.99)) #, max_treedepth = 15))

print(name_match_model_0_fit)
```

# Model Parametrization

## Willingness-to-Pay

```{r}
wtp_model_0 <- stan_model(file = "wtp_model.stan", model_name = "wtp_model_0")
wtp_model_0_fit <- sampling(wtp_model_0, data = stan_data, chains = 4, iter = 2000, sample_file = file.path("stanfit", "wtp_model.csv")) 

print(wtp_model_0_fit, pars = c("sim_gift_choice", "sim_wtp_response"), include = FALSE)
```

### Model Checking

```{r}
wtp_model_0_fit %>% 
  extract(pars = "sim_gift_choice") %$% 
  adply(sim_gift_choice, 1, function(iter) tibble(prop_calendar = mean(iter))) %>% 
  ggplot() +
  geom_density(aes(x = prop_calendar)) +
  geom_vline(xintercept = mean(stan_data$gift_choice)) +
  coord_cartesian(xlim = c(-1, 1))

wtp_model_0_fit %>% 
  extract(pars = "sim_wtp_response") %$% 
  adply(sim_wtp_response, 1, function(iter) tibble(prop_switch = mean(iter))) %>% 
  ggplot() +
  geom_density(aes(x = prop_switch)) +
  geom_vline(xintercept = mean(stan_data$wtp_response)) +
  coord_cartesian(xlim = c(-1, 1))
```

## Calendar-Bracelet Private Utility

```{r}
calendar_param_stan_data <- analysis.data %>% 
  filter(assigned.treatment %in% c("control", "calendar", "bracelet"), 
         sms.treatment.2 == "sms.control",
         !phone_owner,
         true.monitored) %>% 
  mutate(assigned.treatment.2 = fct_collapse(assigned.treatment, 
                                             no_value = c("control", "ink"), 
                                             private_value = c("calendar", "bracelet")),
         assigned.treatment = fct_collapse(assigned.treatment, control = c("control", "calendar"))) %>% 
  prepare_bayesian_analysis_data(
    wtp.data, 
    treatment_formula = ~ (assigned.treatment + assigned.treatment.2) * phone_owner,
    
    scale_df = 3,
    scale_sigma = 1,
    
    coef_df = 7,
    coef_sigma = 10,
    bracelet_val_coef_sigma = 100,
    
    wtp_utility_df = 3,
    tau_mu_wtp_diff = 100,
    mu_wtp_df_student_t = 7,
    tau_sigma_wtp_diff = 50,
    sigma_wtp_df_student_t = 2.5
  )
```

```{r calendar-param-0}
param_model_0 <- stan_model(file = "takeup_param_model_0.stan", model_name = "param_model_0")
param_model_0_fit <- sampling(param_model_0, data = calendar_param_stan_data, chains = 4, iter = 100, 
                              sample_file = file.path("stanfit", "param_model_0.csv"), control = lst(adapt_delta = 0.99, max_treedepth = 15))
```

```{r}
print(param_model_0_fit, pars = c("cluster_effects_raw", "cluster_effects", "latent_utility", "latent_bracelet_val_diff"), include = FALSE)
```

## Full Parameterized Model

```{r param-ate}
param_sms_control_ate <- tribble(
  ~ private_value_left, ~ social_value_left, ~ private_value_right, ~ social_value_right,
  "control",            "ink",               "control",             "control",
  "calendar",           "control",           "control",             "control",
  "bracelet",           "bracelet",          "control",             "control",
  "bracelet",           "bracelet",          "calendar",            "control",
  
  "control",           "bracelet",           "control",            "control" 
) %>%
  bind_rows("close" = ., "far" = ., .id = "dist.pot.group") %>% 
  bind_rows(`TRUE` = ., `FALSE` = ., .id = "phone_owner") %>%
  mutate(sms.treatment.2_left = "sms.control", sms.treatment.2_right = "sms.control",
         phone_owner = as.logical(phone_owner),
         hh.baseline.sample = FALSE) 

param_phone_owners_ate <- tribble(
  ~ private_value_left, ~ social_value_left, ~ sms.treatment.2_left, ~ private_value_right, ~ social_value_right, ~ sms.treatment.2_right,
  "control",            "control",           "reminder.only",        "control",             "control",            "sms.control",
  "control",            "control",           "social.info",          "control",             "control",            "sms.control",
  "control",            "control",           "social.info",          "control",             "control",            "reminder.only",

  "control",            "ink",               "social.info",          "control",             "control",            "sms.control",
  "control",            "ink",               "social.info",          "control",             "control",            "social.info",
  "control",            "ink",               "social.info",          "control",             "ink",                "sms.control",

  "calendar",           "control",           "social.info",          "control",             "control",            "sms.control",
  "calendar",           "control",           "social.info",          "control",             "control",            "social.info",
  "calendar",           "control",           "social.info",          "calendar",            "control",            "sms.control",

  "bracelet",           "bracelet",          "social.info",          "control",             "control",            "sms.control",
  "bracelet",           "bracelet",          "social.info",          "control",             "control",            "social.info",
  "bracelet",           "bracelet",          "social.info",          "calendar",            "control",            "social.info",
  "bracelet",           "bracelet",          "social.info",          "bracelet",            "bracelet",           "sms.control",
  
  "control",           "bracelet",           "social.info",          "control",             "control",            "sms.control",
  "control",           "bracelet",           "social.info",          "control",             "control",            "social.info",
  "control",           "bracelet",           "social.info",          "calendar",            "control",            "social.info",
  "control",           "bracelet",           "social.info",          "bracelet",            "control",            "sms.control"
) %>%
  bind_rows("close" = ., "far" = ., .id = "dist.pot.group") %>%
  mutate(phone_owner = TRUE,
         hh.baseline.sample = FALSE) 

param_all_ate <- bind_rows(param_sms_control_ate, param_phone_owners_ate) 
```

```{r param-model-data}
param_stan_data <- analysis.data %>%
  mutate(private_value = fct_collapse(assigned.treatment, control = c("control", "ink")),
         social_value = fct_collapse(assigned.treatment, control = c("control", "calendar"))) %>% 
  # filter(!name_matched, sms.treatment.2 == "sms.control") %>%
  # filter(sms.treatment.2 == "sms.control") %>%
  prepare_bayesian_analysis_data(
    wtp.data, 
    
    treatment_map = data_grid(., private_value, social_value, dist.pot.group, sms.treatment.2, hh.baseline.sample, phone_owner) %>%
      filter(phone_owner | sms.treatment.2 == "sms.control",
            (private_value == "control" & social_value == "control") | sms.treatment.2 != "reminder.only",
            private_value != "calendar" | social_value == "control",
            private_value != "bracelet" | social_value == "bracelet"),
    
    # treatment_map = data_grid(., private_value, social_value, dist.pot.group, hh.baseline.sample, phone_owner) %>%
    #   filter(private_value != "calendar" | social_value == "control",
    #          private_value != "bracelet" | social_value == "bracelet"),
    
    # treatment_formula = ~ (private_value + social_value) * dist.pot.group * sms.treatment.2 * hh.baseline.sample * phone_owner - phone_owner,
    # treatment_formula = ~ (private_value + social_value) * dist.pot.group * hh.baseline.sample * phone_owner - phone_owner,
    # treatment_formula = ~ (private_value + social_value * (dist.pot.group + hh.baseline.sample)) * phone_owner,
    treatment_formula = ~ (private_value + social_value * sms.treatment.2 * (dist.pot.group + hh.baseline.sample)) * phone_owner,
    
    subgroup_col = NULL,
    
    all_ate = param_all_ate,
    # all_ate = param_sms_control_ate %>% select(-contains("sms.treatment")),
    
    # name_match_false_pos_alpha, 
    # name_match_false_pos_beta,
    
    scale_df = 3,
    scale_sigma = 1,
    # real scale_sigma_ksh_util_gamma = 0.05;
  
    coef_df = 7,
    coef_sigma = 5,
    
    wtp_utility_df = 3,
    tau_mu_wtp_diff = 100,
    mu_wtp_df_student_t = 7,
    tau_sigma_wtp_diff = 50,
    sigma_wtp_df_student_t = 2.5,
    sigma_ksh_util_gamma = 5,
  )
```

```{r basic-model-1}
basic_model_1 <- stan_model(file = "takeup_model_1.stan", model_name = "model_1")
basic_model_1_fit <- sampling(basic_model_1, data = param_stan_data, chains = 8, iter = 200, sample_file = file.path("stanfit", "basic_model_1_10.csv"), control = lst(max_treedepth = 15)) # adapt_delta = 0.99, 
```

```{r, eval=FALSE}
basic_model_1_fit <- dir("stanfit", pattern = "basic_model_1_4_[1-8].csv") %>% 
  file.path("stanfit", .) %>% 
  read_stan_csv()
```

```{r}
print(basic_model_1_fit, pars = c("non_phone_takeup", "phone_takeup", "non_phone_takeup_ate", "phone_takeup_ate"))
```

```{r}
print(basic_model_1_fit, pars = "hyper_ksh_util_gamma_raw", digits_summary = 10)
```

## Dynamic Model

```{r, fig.width=10, fig.height=10}
prop_deworm_day_data <- analysis.data %>% 
  filter(!name_matched) %>% 
  group_by(wave, assigned.treatment, dist.pot.group, sms.treatment.2) %>% 
  mutate(cell_size = n()) %>% 
  group_by(dewormed.date.any, add = TRUE) %>% 
  summarize(prop_dewormed = n() / first(cell_size)) %>% 
  group_by(wave, assigned.treatment, dist.pot.group, sms.treatment.2) %>% 
  mutate(cumul_prop_dewormed = cumsum(prop_dewormed)) %>% 
  ungroup() %>% 
  mutate(dewormed.weekday = factor(weekdays(dewormed.date.any), 
                                   levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")))

base_plot <- function(.data, col, lt = NULL) {
  .data %>% 
    filter(!is.na(dewormed.date.any)) %>% 
    ggplot(aes_string(x = "dewormed.date.any", y = "cumul_prop_dewormed", color = col)) +
    geom_line(aes_string(color = col, linetype = lt)) +
    geom_point() +
    scale_x_date(labels = scales::date_format("%a")) +
    theme(legend.position = "bottom")
}

dist_incentive_plot <- prop_deworm_day_data %>% 
  base_plot("sms.treatment.2") + 
  facet_grid(assigned.treatment ~ dist.pot.group + wave, scales = "free_x")
  # facet_grid(assigned.treatment ~ dist.pot.group, scales = "free_x")

dist_sms_plot <- prop_deworm_day_data %>% 
  base_plot("assigned.treatment", lt = "sms.treatment.2") + 
  facet_grid(~ dist.pot.group + wave, scales = "free_x")
  # facet_grid(~ dist.pot.group, scales = "free_x")

dist_sms_plot_split <- prop_deworm_day_data %>% 
  base_plot("assigned.treatment", lt = "sms.treatment.2") + 
  facet_grid(sms.treatment.2 ~ dist.pot.group + wave, scales = "free_x")

plot(dist_incentive_plot)
```

```{r, fig.width=14, fig.height=6}
plot(dist_sms_plot)
```

```{r, fig.width=14, fig.height=10}
plot(dist_sms_plot_split)
```

```{r, fig.width=10}
analysis.data %>% 
  filter(!is.na(endline_deworm_rate)) %>% 
  ggplot() +
  geom_violin(aes(assigned.treatment, endline_deworm_rate, color = dist.pot.group, linetype = sms.treatment.2), draw_quantiles = c(0.25, 0.5, 0.75)) +
  scale_y_continuous(breaks = 0:10)
```

```{r dyn-param-ate}
dyn_sms_control_ate <- tribble(
  ~ private_value_left, ~ social_value_left, ~ private_value_right, ~ social_value_right,
  "control",            "ink",               "control",             "control",
  "calendar",           "control",           "control",             "control",
  "bracelet",           "bracelet",          "control",             "control",
  "bracelet",           "bracelet",          "calendar",            "control",
  
  "control",           "bracelet",           "control",            "control" 
) %>%
  bind_rows("close" = ., "far" = ., .id = "dist.pot.group") %>% 
  bind_rows(`TRUE` = ., `FALSE` = ., .id = "phone_owner") %>%
  mutate(sms.treatment.2_left = "sms.control", sms.treatment.2_right = "sms.control",
         phone_owner = as.logical(phone_owner),
         signal_observed_left = social_value_left,
         signal_observed_right = social_value_right,
         hh.baseline.sample = FALSE) 

dyn_phone_owners_ate <- tribble(
  ~ private_value_left, ~ social_value_left, ~ sms.treatment.2_left, ~ private_value_right, ~ social_value_right, ~ sms.treatment.2_right,
  "control",            "control",           "reminder.only",        "control",             "control",            "sms.control",
  "control",            "control",           "social.info",          "control",             "control",            "sms.control",
  "control",            "control",           "social.info",          "control",             "control",            "reminder.only",

  "control",            "ink",               "social.info",          "control",             "control",            "sms.control",
  "control",            "ink",               "social.info",          "control",             "control",            "social.info",
  "control",            "ink",               "social.info",          "control",             "ink",                "sms.control",

  "calendar",           "control",           "social.info",          "control",             "control",            "sms.control",
  "calendar",           "control",           "social.info",          "control",             "control",            "social.info",
  "calendar",           "control",           "social.info",          "calendar",            "control",            "sms.control",

  "bracelet",           "bracelet",          "social.info",          "control",             "control",            "sms.control",
  "bracelet",           "bracelet",          "social.info",          "control",             "control",            "social.info",
  "bracelet",           "bracelet",          "social.info",          "calendar",            "control",            "social.info",
  "bracelet",           "bracelet",          "social.info",          "bracelet",            "bracelet",           "sms.control",
  
  "control",           "bracelet",           "social.info",          "control",             "control",            "sms.control",
  "control",           "bracelet",           "social.info",          "control",             "control",            "social.info",
  "control",           "bracelet",           "social.info",          "calendar",            "control",            "social.info",
  "control",           "bracelet",           "social.info",          "bracelet",            "control",            "sms.control"
) %>%
  bind_rows("close" = ., "far" = ., .id = "dist.pot.group") %>%
  mutate(phone_owner = TRUE,
         hh.baseline.sample = FALSE, 
         signal_observed_left = social_value_left,
         signal_observed_right = social_value_right)

dyn_all_ate <- bind_rows(dyn_sms_control_ate, dyn_phone_owners_ate) 
```

```{r dyn-model-data, dependson="param-ate"}
dyn_stan_data <- analysis.data %>%
  mutate(private_value = fct_collapse(assigned.treatment, control = c("control", "ink")),
         social_value = fct_collapse(assigned.treatment, control = c("control", "calendar")),
         signal_observed = social_value) %>% 
  filter(!name_matched, sms.treatment.2 == "sms.control") %>%
  prepare_bayesian_analysis_data(
    wtp.data, 
    
    # treatment_map = data_grid(., private_value, social_value, dist.pot.group, sms.treatment.2, hh.baseline.sample, phone_owner) %>%
    #   filter(phone_owner | sms.treatment.2 == "sms.control",
    #         (private_value == "control" & social_value == "control") | sms.treatment.2 != "reminder.only",
    #         private_value != "calendar" | social_value == "control",
    #         private_value != "bracelet" | social_value == "bracelet"),
    
    treatment_map = data_grid(., private_value, social_value, signal_observed, dist.pot.group, hh.baseline.sample, phone_owner) %>%
      filter(private_value != "calendar" | social_value == "control",
             private_value != "bracelet" | social_value == "bracelet",
             signal_observed == social_value | signal_observed == "control"),
    
    dynamic_treatment_map = lst(formula = ~ signal_observed*phone_owner, 
                                trends = tibble(signal_observed = 0:11)),
    
    treatment_formula = ~ (private_value + social_value * (dist.pot.group + hh.baseline.sample)) * phone_owner,
    subgroup_col = NULL,
    
    # all_ate = param_all_ate,
    all_ate = dyn_sms_control_ate %>% select(-contains("sms.treatment")),
    
    # name_match_false_pos_alpha, 
    # name_match_false_pos_beta,
    
    scale_df = 7,
    scale_sigma = 1,
    scale_sigma_dynamic = 1,
   
    coef_df = 7,
    coef_sigma = 1,
    coef_sigma_dynamic = 5,
    
    wtp_utility_df = 3,
    tau_mu_wtp_diff = 100,
    mu_wtp_df_student_t = 7,
    tau_sigma_wtp_diff = 50,
    sigma_wtp_df_student_t = 2.5,
    sigma_ksh_util_gamma = 5,
  )
```

```{r basic-model-2-simple}
basic_model_2_simple <- stan_model(file = "takeup_model_2_simple.stan", model_name = "model_2_simple")
basic_model_2_simple_fit <- dyn_stan_data %>% 
  sampling(basic_model_2_simple, data = ., #init = .$dynamic_initializer,
                                     chains = 7, iter = 50, control = lst(max_treedepth = 15), # adapt_delta = 0.99, 
                                     sample_file = file.path("stanfit", "basic_model_2_simple_3.csv")) 
```

```{r basic-model-2-simple-debug}
basic_model_2_simple <- stan_model(file = "takeup_model_2_simple.stan", model_name = "model_2_simple")
basic_model_2_simple_fit <- dyn_stan_data %>% 
  sampling(basic_model_2_simple, data = ., #init = .$dynamic_initializer,
           chains = 1, iter = 20, control = lst(max_treedepth = 15), # adapt_delta = 0.99, 
           sample_file = file.path("stanfit", "basic_model_2_simple_debug.csv")) 
```

```{r}
print(basic_model_2_simple_fit, pars = c(sprintf("all_treatment_cond_takeup[34,%d]", 1:12)))
```

