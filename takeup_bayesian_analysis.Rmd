---
title: "TakeUp Bayesian Analysis Notebook"
author:
- Anne Karing^[University of California Berkeley]
- Karim Naguib^[Evidence Action]
output:
  html_notebook:
    fig_align: "center"
    fig_caption: yes
    fig_height: 5
    fig_width: 8
    number_sections: yes
    theme: flatly
    toc: yes
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 5
header-includes:
   - \usepackage{bbm}
date: "`r format(Sys.time(), '%B %d, %Y')`"
---

```{r, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r setup, include=FALSE}
library(magrittr)
library(purrr)
library(plyr)
library(dplyr)
library(multidplyr)
library(tibble)
library(tidyr)
library(lubridate)
library(forcats)
library(readr)
library(haven)
library(broom)
library(ggplot2)
library(ggrepel)
library(ggmap)
library(stringr)
library(knitr)
library(modelr)
library(rstan)

library(econometr)

source("takeup_rct_assign_clusters.R")
source("analysis_util.R")

knitr::read_chunk("analysis_util.R", labels = "analysis-util")

config <- yaml::yaml.load_file("../local_config.yaml")

options(dplyr.show_progress = FALSE, digits = 4, mc.cores = max(1, parallel::detectCores() - 1))
```

```{r load-data, include=FALSE}
load(file.path("data", "analysis.RData"))
```

```{stan, output.var="basic_model_0"}
data {
  int<lower = 0> num_obs;
  int<lower = 0> num_missing;
  int<lower = 1> num_treatments;
  int<lower = 1> num_clusters;
  int<lower = 1> num_strata;
  
  int<lower = 1, upper = num_clusters> cluster_id[num_obs];
  int<lower = 1, upper = num_clusters> missing_cluster_id[num_missing];
  int<lower = 1, upper = num_strata> stratum_id[num_clusters];
  int<lower = 1> strata_sizes[num_strata]; // Getting around Stan's lack of support for ragged arrays
  int<lower = 1> missing_strata_sizes[num_strata]; 
 
  matrix[num_obs, num_treatments] treatment_design_matrix;
  matrix[num_missing, num_treatments] missing_treatment_design_matrix;
 
  // Binary deworming outcome 
  
  int<lower = 0, upper = 1> dewormed_any[num_obs];
}

transformed data {
  int<lower = 1, upper = num_strata> stratum_id_individ[num_obs] = stratum_id[cluster_id];
  int<lower = 1, upper = num_strata> missing_stratum_id_individ[num_missing] = stratum_id[missing_cluster_id];
  
  // Unmodeled parameters
  
  vector[num_treatments] mu_beta = rep_vector(0, num_treatments);
}

parameters {
  real<lower=-4, upper=10> mu_strata; // uniformly distributed prior

  vector[num_strata] stratum_intercept;
  vector[num_treatments] beta[num_strata];
  vector[num_clusters] cluster_effects;
  
  // Scale hyperparameters for betas 
  
  // corr_matrix[num_treatments] Omega_beta;
  vector<lower = 0>[num_treatments] tau_beta;
  real<lower = 0> tau_cluster_effect;
}

transformed parameters {
  cov_matrix[num_treatments] Sigma_beta = diag_matrix(tau_beta);
}

model {
  // Some hyperpriors with temp parameter values from the Stan Manual
  
  //Omega_beta ~ lkj_corr(50);
  tau_beta ~ cauchy(0, 20); // This is a very weakly informative prior
  tau_cluster_effect ~ cauchy(0, 2.5);
  //tau_beta ~ normal(0, 2);
  //tau_beta ~ gamma(2, 1/10);
  
  stratum_intercept ~ normal(mu_strata, 100); // Weakly informative prior; big SD
  cluster_effects ~ normal(0, tau_cluster_effect);
  
  beta ~ multi_normal(mu_beta, Sigma_beta); // For now assuming no correlation between effects
 
  {
    int strata_pos = 1;
    vector[num_obs] link_model;  
  
    // Looping over strata in the data; Stan doesn't support ragged arrays, so can't split the data into arrays.
    // Otherwise, will have to loop by row, which will slow things down dramatically.
    for (strata_index in 1:num_strata) {
      int curr_stratum_size = strata_sizes[strata_index];
      int stratum_end = strata_pos + curr_stratum_size - 1;
      
      link_model[strata_pos:stratum_end] = treatment_design_matrix[strata_pos:stratum_end] * beta[strata_index];  
      strata_pos = strata_pos + curr_stratum_size;
    }
    
    link_model = link_model + stratum_intercept[stratum_id_individ] + cluster_effects[cluster_id]; 
  
    dewormed_any ~ bernoulli_logit(link_model);
  } 
}

generated quantities {
  int<lower = 0, upper = 1> missing_dewormed_any[num_missing];
  
  {
    int strata_pos = 1;
    vector[num_missing] missing_link_model;  
  
    for (strata_index in 1:num_strata) {
      int curr_stratum_size = missing_strata_sizes[strata_index];
      int stratum_end = strata_pos + curr_stratum_size - 1;
      
      missing_link_model[strata_pos:stratum_end] = missing_treatment_design_matrix[strata_pos:stratum_end] * beta[strata_index];  
      strata_pos = strata_pos + curr_stratum_size;
    }
    
    missing_link_model = missing_link_model + stratum_intercept[missing_stratum_id_individ] + cluster_effects[missing_cluster_id]; 
   
    for (i in 1:num_missing) {
      missing_dewormed_any[i] = bernoulli_logit_rng(missing_link_model[i]);
    } 
  } 
}

```

```{r}
stan_data <- analysis.data %>% 
  # filter(monitored, sms.treatment.2 == "sms.control", !hh.baseline.sample) %>% 
  mutate(new_cluster_id = factor(cluster.id) %>% as.integer()) %>% 
  mutate_at(vars(county_dist_stratum, county_dist_mon_stratum, county), funs(id = as.integer)) %>% 
  anti_join(outlier.cells, c("assigned.treatment","sms.treatment", "mon_status", "cluster.id")) %>% 
  arrange(county_dist_stratum_id) %>% 
  (function(prepared_analysis_data) {
    treatment_map <- data_grid(prepared_analysis_data, assigned.treatment) %>% 
      mutate(treatment_id = seq_len(n()))
    
    treatment_grid <- prepared_analysis_data %>% {
      left_join(data_grid(., KEY.individ, assigned.treatment), 
                select(., KEY.individ, new_cluster_id, county_dist_stratum_id), 
                "KEY.individ") 
    }
    
    missing_treatment <- anti_join(treatment_grid, prepared_analysis_data, c("KEY.individ", "assigned.treatment")) 
    
    lst(
      treatment_map,
      
      treatment_design_matrix = model_matrix(prepared_analysis_data, ~ assigned.treatment) %>% 
        magrittr::extract(, -1),
    
      missing_treatment_design_matrix = model_matrix(missing_treatment, ~ assigned.treatment) %>% 
        magrittr::extract(, -1),
      
      # treatment_id = left_join(prepared_analysis_data, treatment_map, c("assigned.treatment")), 
      # missing_treatment_id = left_join(missing_treatment, treatment_map, c("assigned.treatment")), 
      
      cluster_id = prepared_analysis_data$new_cluster_id,
      missing_cluster_id = missing_treatment$new_cluster_id,
      stratum_id = distinct(prepared_analysis_data, new_cluster_id, county_dist_stratum_id) %>% 
        arrange(new_cluster_id) %$% 
        county_dist_stratum_id,
      
      dewormed_any = prepared_analysis_data$dewormed.any,
      
      num_obs = nrow(treatment_design_matrix),
      num_missing = nrow(missing_treatment_design_matrix),
      num_treatments = ncol(treatment_design_matrix),
      num_clusters = n_distinct(cluster_id),
      num_strata = n_distinct(stratum_id),
      strata_sizes = count(prepared_analysis_data, county_dist_stratum_id) %>% arrange(county_dist_stratum_id) %$% n, 
      missing_strata_sizes = count(missing_treatment, county_dist_stratum_id) %>% arrange(county_dist_stratum_id) %$% n 
    )
  }) 
```

```{r}
basic_model_0_fit <- sampling(basic_model_0, data = stan_data, chains = 4) #, control = lst(adapt_delta = 0.99, max_treedepth = 15))
# basic_model_0_fit <- sampling(basic_model_0, data = stan_data, chains = 1, iter = 1000) #, control = lst(adapt_delta = 0.99, max_treedepth = 15))

print(basic_model_0_fit)
```

```{stan, output.var="basic_model_1"}
data {
  int<lower = 0> num_obs;
  int<lower = 0> num_missing;
  int<lower = 1> num_treatments;
  int<lower = 1> num_clusters;
  int<lower = 1> num_strata;
  
  int<lower = 1, upper = num_clusters> cluster_id[num_obs];
  int<lower = 1, upper = num_clusters> missing_cluster_id[num_missing];
  int<lower = 1, upper = num_strata> stratum_id[num_clusters];
  // int<lower = 1> strata_sizes[num_strata]; // Getting around Stan's lack of support for ragged arrays
  int<lower = 1> treatment_group_sizes[num_treatments + 1]; 
  int<lower = 1> missing_treatment_group_sizes[num_treatments + 1]; 
  // int<lower = 1> missing_strata_sizes[num_strata]; 
 
  matrix[num_obs, num_treatments] treatment_design_matrix;
  matrix[num_missing, num_treatments] missing_treatment_design_matrix;
 
  // Binary deworming outcome 
  
  int<lower = 0, upper = 1> dewormed_any[num_obs];
}

transformed data {
  int<lower = 1, upper = num_strata> stratum_id_individ[num_obs] = stratum_id[cluster_id];
  int<lower = 1, upper = num_strata> missing_stratum_id_individ[num_missing] = stratum_id[missing_cluster_id];
  
  // Unmodeled parameters
  
  vector[num_treatments] mu_beta = rep_vector(0, num_treatments);
}

parameters {
  real<lower=-4, upper=10> mu_strata; // uniformly distributed prior

  vector[num_strata] stratum_intercept;
  vector[num_treatments] beta[num_strata];
  vector[num_clusters] cluster_effects;
  
  // Scale hyperparameters for betas 
  
  // corr_matrix[num_treatments] Omega_beta;
  vector<lower = 0>[num_treatments] tau_beta;
  real<lower = 0> tau_cluster_effect;
}

transformed parameters {
  cov_matrix[num_treatments] Sigma_beta = diag_matrix(tau_beta);
}

model {
  stratum_intercept ~ normal(mu_strata, 100); // Weakly informative prior; big SD
  
  //Omega_beta ~ lkj_corr(50);
  tau_beta ~ cauchy(0, 20); // This is a very weakly informative prior
  tau_cluster_effect ~ cauchy(0, 2.5);
  //tau_beta ~ normal(0, 2);
  //tau_beta ~ gamma(2, 1/10);
  
  cluster_effects ~ normal(0, tau_cluster_effect);
  
  beta ~ multi_normal(mu_beta, Sigma_beta); // For now assuming no correlation between effects
 
  {
    int strata_pos = 1;
    vector[num_obs] link_model;  
  
    // Looping over strata in the data; Stan doesn't support ragged arrays, so can't split the data into arrays.
    // Otherwise, will have to loop by row, which will slow things down dramatically.
    for (strata_index in 1:num_strata) {
      int curr_stratum_size = strata_sizes[strata_index];
      int stratum_end = strata_pos + curr_stratum_size - 1;
      
      link_model[strata_pos:stratum_end] = treatment_design_matrix[strata_pos:stratum_end] * beta[strata_index];  
      strata_pos = strata_pos + curr_stratum_size;
    }
    
    link_model = link_model + stratum_intercept[stratum_id_individ] + cluster_effects[cluster_id]; 
  
    dewormed_any ~ bernoulli_logit(link_model);
  } 
}

generated quantities {
  int<lower = 0, upper = 1> missing_dewormed_any[num_missing];
  
  {
    int strata_pos = 1;
    vector[num_missing] missing_link_model;  
  
    for (strata_index in 1:num_strata) {
      int curr_stratum_size = missing_strata_sizes[strata_index];
      int stratum_end = strata_pos + curr_stratum_size - 1;
      
      missing_link_model[strata_pos:stratum_end] = missing_treatment_design_matrix[strata_pos:stratum_end] * beta[strata_index];  
      strata_pos = strata_pos + curr_stratum_size;
    }
    
    missing_link_model = missing_link_model + stratum_intercept[missing_stratum_id_individ] + cluster_effects[missing_cluster_id]; 
   
    for (i in 1:num_missing) {
      missing_dewormed_any[i] = bernoulli_logit_rng(missing_link_model[i]);
    } 
  } 
}

```

```{stan, output.var="basic_model_2"}
data {
  int<lower = 0> num_obs;
  int<lower = 1> num_treatments;
  int<lower = 1> num_clusters;
  int<lower = 1> num_strata;
  
  int<lower = 1, upper = num_obs> individ_id[num_obs];
  int<lower = 1, upper = num_clusters> cluster_id[num_obs];
  int<lower = 1, upper = num_strata> stratum_id[num_clusters];
 
  matrix[num_obs, num_treatments] treatment_design_matrix;
  matrix[num_obs * (num_treatments - 1), num_treatments] treatment_design_matrix;
 
  // Binary deworming outcome 
  
  int<lower = 0, upper = 1> dewormed_any[num_obs];
}

transformed data {
  int <lower = 0> num_missing_treatments = num_treatments - 1; // Number of unobserved counterfactuals
}

parameters {
  vector[num_treatments] beta_stratum[num_strata];
  
  vector[num_treatments] mu; // Hyperparameter for beta_stratum
  
  // Scale hyperparameters for betas 
  
  corr_matrix[num_treatments] Omega_strata;
  vector<lower = 0>[num_treatments] tau_strata;
}

model {
  // Some hyperpriors with temp parameter values from the Stan Manual
  
  Omega_strata ~ lkj_corr(2);
  tau_strata ~ cauchy(0, 2.5);
  
  mu ~ normal(0, 100);
  
  // Model treatment effects hierarchical over clusters and strata
  
  for (stratum_index in 1:num_strata) {
    beta_stratum[stratum_index] ~ multi_normal(mu, quad_form_diag(Omega_strata, tau_strata));
  }
  
  // Model the outcome (deworming) in response to experimental treatment
  
  { // The part in this block apparently optimizes analysis
    vector[num_obs] treatment_beta_cluster;
    
    for (i in 1:num_obs) {
      treatment_beta_cluster[i] = treatment_design_matrix[i] * beta_stratum[stratum_id[cluster_id[i]]];
    }
    
    dewormed_any ~ bernoulli_logit(treatment_beta_cluster);
  }
}
```

```{r}

basic_model_1_fit <- analysis.data %>% 
  filter(monitored, sms.treatment.2 == "sms.control", !hh.baseline.sample) %>% 
  mutate(new_cluster_id = factor(cluster.id) %>% as.integer()) %>% 
  anti_join(outlier.cells, c("assigned.treatment","sms.treatment", "mon_status", "cluster.id")) %>% {
    lst(
      treatment_design_matrix = model_matrix(., ~ assigned.treatment),
      cluster_id = .$new_cluster_id,
      stratum_id = distinct(., new_cluster_id, county_dist_stratum) %>% 
        arrange(new_cluster_id) %$% 
        as.integer(county_dist_stratum),
      
      dewormed_any = .$dewormed.any,
      
      num_obs = nrow(treatment_design_matrix),
      num_treatments = ncol(treatment_design_matrix),
      num_clusters = n_distinct(cluster_id),
      num_strata = n_distinct(stratum_id)
    )
  } %>% 
  sampling(basic_model_1) #, control = lst(max_treedepth = 15, adapt_delta = 0.99))
```

```{stan, output.var="basic_model"}
data {
  int<lower = 0> num_obs;
  int<lower = 1> num_treatments;
  int<lower = 1> num_clusters;
  int<lower = 1> num_strata;
  
  int<lower = 1, upper = num_clusters> cluster_id[num_obs];
  int<lower = 1, upper = num_strata> stratum_id[num_clusters];
 
  matrix[num_obs, num_treatments] treatment_design_matrix;
 
  // Binary deworming outcome 
  
  int<lower = 0, upper = 1> dewormed_any[num_obs];
}

transformed data {
  int <lower = 0> num_missing_treatments = num_treatments - 1; // Number of unobserved counterfactuals
}

parameters {
  // We only observe one treatment per cluster so we're actually imputing the betas for the counterfactuals
  vector[num_treatments] beta_cluster[num_clusters]; 
  vector[num_treatments] beta_stratum[num_strata];
  
  vector[num_treatments] mu; // Hyperparameter for beta_stratum
  
  // Scale hyperparameters for betas 
  
  corr_matrix[num_treatments] Omega_strata;
  vector<lower = 0>[num_treatments] tau_strata;
  
  corr_matrix[num_treatments] Omega_clusters;
  vector<lower = 0>[num_treatments] tau_clusters;
}

model {
  // Some hyperpriors with temp parameter values from the Stan Manual
  
  Omega_strata ~ lkj_corr(2);
  tau_strata ~ cauchy(0, 2.5);
  
  Omega_clusters ~ lkj_corr(2);
  tau_clusters ~ cauchy(0, 2.5);
  
  mu ~ normal(0, 100);
  
  // Model treatment effects hierarchical over clusters and strata
  
  for (stratum_index in 1:num_strata) {
    beta_stratum[stratum_index] ~ multi_normal(mu, quad_form_diag(Omega_strata, tau_strata));
  }
  
  for (cluster_index in 1:num_clusters) {
    beta_cluster[cluster_index] ~ multi_normal(beta_stratum[stratum_id[cluster_index]], quad_form_diag(Omega_clusters, tau_clusters));
  }
  
  // Model the outcome (deworming) in response to experimental treatment
  
  { // The part in this block apparently optimizes analysis
    vector[num_obs] treatment_beta_cluster;
    
    for (i in 1:num_obs) {
      treatment_beta_cluster[i] = treatment_design_matrix[i] * beta_cluster[cluster_id[i]];
    }
    
    dewormed_any ~ bernoulli_logit(treatment_beta_cluster);
  }
}
```

```{r}
basic_model_fit <- analysis.data %>% 
  filter(monitored, sms.treatment.2 == "sms.control", !hh.baseline.sample) %>% 
  mutate(new_cluster_id = factor(cluster.id) %>% as.integer()) %>% 
  anti_join(outlier.cells, c("assigned.treatment","sms.treatment", "mon_status", "cluster.id")) %>% {
    lst(
      treatment_design_matrix = model_matrix(~ assigned.treatment, data = .),
      cluster_id = .$new_cluster_id,
      stratum_id = distinct(., new_cluster_id, county_dist_stratum) %>% 
        arrange(new_cluster_id) %$% 
        as.integer(county_dist_stratum),
      
      dewormed_any = .$dewormed.any,
      
      num_obs = nrow(treatment_design_matrix),
      num_treatments = ncol(treatment_design_matrix),
      num_clusters = n_distinct(cluster_id),
      num_strata = n_distinct(stratum_id)
    )
  } %>% 
  sampling(basic_model, control = lst(max_treedepth = 15, adapt_delta = 0.99))
```

