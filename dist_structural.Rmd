---
title: "Distance Structural"
output: html_notebook
---

```{r setup}
library(magrittr)
library(tidyverse)
library(HRW)
library(splines2)
library(rstan)
library(loo)
library(bayesplot)

options(mc.cores = 12)
rstan_options(auto_write = TRUE)
```

```{r util-scripts}
source("analysis_util.R")
source(file.path("multilvlr", "multilvlr_util.R"))
```

```{r load-data}
load(file.path("data", "analysis.RData"))
load(file.path("stan_analysis_data", "dist_fit.RData"))
load(file.path("stan_analysis_data", "dist_kfold.RData"))
```

```{r}
plot_takeup <- . %>% 
  map_dfr(extract_sim_level, "sim_takeup_prob", .id = "model", grid_dist = grid_dist) %>% 
  mutate(wide_quantiles = map(quantiles_est, mutate, per = str_c("per_", per)) %>% 
           map(spread, per, est),
         # model = str_extract(model, "[^_]+$")
         ) %>% 
  unnest(wide_quantiles) %>% {
    ggplot(., aes(grid_dist, mean_est, group = model)) +
      geom_line(aes(color = model), 
                show.legend = FALSE) +
      geom_ribbon(aes(ymin = per_0.1, ymax = per_0.9, fill = model), 
                  show.legend = TRUE,
                  alpha = 0.25) +
      # geom_ribbon(aes(ymin = per_0.05, ymax = per_0.95), alpha = 0.25) +
      # geom_point(aes(cluster.dist.to.pot, prop_takeup, color = dist.pot.group),
      geom_point(aes(cluster.dist.to.pot, prop_takeup), inherit.aes = FALSE,
                 data = cluster_analysis_data %>% mutate(assigned_treatment = assigned.treatment)) +
      scale_color_discrete("Model") +
      scale_fill_discrete("Model") +
      labs(
        x = "Distance from PoT [meters]", 
        y = "Take-up", 
        caption = "Points: observed village level proportion of take-up.
                   Grey ribbons: 80% credible intervals."
      ) +
      facet_wrap(vars(assigned_treatment), nrow = 1) +
      theme_minimal() +
      theme(legend.position = "right")
  }
```

```{r, fig.width=16, fig.height=4}
dist_fit[1] %>% 
  plot_takeup()
```

```{r, fig.width=16, fig.height=4}
dist_fit %>% 
  magrittr::extract(
    c(
      # "LINEAR_DIST",
      # "LINEAR_DIST_CE",
      # "QUADRATIC_NONLINEAR_DIST",
      # "QUADRATIC_NONLINEAR_DIST_CE",
      # "CUBIC_NONLINEAR_DIST_CE",
      # "SEMIPARAM_NONLINEAR_DIST_BSPLINE"
      "SEMIPARAM_NONLINEAR_DIST_OSULLIVAN"
      )) %>%
# dist_fit[3:7] %>%
# semiparam_fit %>%
  plot_takeup()
```

```{r, fig.width=8}
dist_fit[c(
  "CUBIC_NONLINEAR_DIST",
  "CUBIC_NONLINEAR_DIST_CE",
  "SEMIPARAM_NONLINEAR_DIST_OSULLIVAN"
  )] %>%
  map_dfr(extract_sim_level, "sim_takeup_prob", .id = "model", grid_dist = grid_dist) %>% 
  mutate(wide_quantiles = map(quantiles_est, mutate, per = str_c("per_", per)) %>% 
           map(spread, per, est)) %>% 
  unnest(wide_quantiles) %>% 
  ggplot(aes(grid_dist, mean_est, group = assigned_treatment)) +
  geom_line(aes(color = assigned_treatment), 
            show.legend = TRUE) +
  # geom_ribbon(aes(ymin = per_0.1, ymax = per_0.9, fill = assigned_treatment), 
  #             show.legend = TRUE,
  #             alpha = 0.25) +
  scale_color_discrete("Assigned Treatment") +
  scale_fill_discrete("Assigned Treatment") +
  labs(
    x = "Distance from PoT [meters]", 
    y = "Take-up", 
    caption = "Points: observed village level proportion of take-up.
               Grey ribbons: 80% credible intervals."
  ) +
  facet_wrap(vars(model), nrow = 1) +
  theme_minimal() +
  theme(legend.position = "right")
```

```{r, fig.width=14, fig.height=4}
semiparam_fit %>%
  map_dfr(extract_obs_fit_level, "obs_takeup_prob", stan_data, .id = "model") %>% 
  mutate(wide_quantiles = map(quantiles_est, mutate, per = str_c("per_", per)) %>% 
           map(spread, per, est),
         model = str_extract(model, "[^_]+$")) %>% 
  unnest(wide_quantiles) %>% 
  ggplot(aes(assigned_dist, mean_est, group = model)) +
  geom_line(aes(color = model)) +
  # geom_ribbon(aes(ymin = per_0.1, ymax = per_0.9), alpha = 0.25) +
  # geom_ribbon(aes(ymin = per_0.05, ymax = per_0.95), alpha = 0.25) +
  # geom_point(aes(cluster.dist.to.pot, prop_takeup, color = dist.pot.group),
  geom_point(aes(cluster.dist.to.pot, prop_takeup), inherit.aes = FALSE,
             data = cluster_analysis_data %>% mutate(assigned_treatment = assigned.treatment)) +
  labs(
    x = "Distance from PoT [meters]", 
    y = "Take-up", 
    # color = "Assigned Distance Group",
    color = "Model"
    # caption = "Points: observed village level proportion of take-up.
    #            Grey ribbons: 80% and 90% credible intervals."
  ) +
  facet_wrap(vars(assigned_treatment), nrow = 1) +
  theme_minimal() +
  theme(legend.position = "right")
```

```{r, fig.width=12, fig.height=4}
dist_fit[c(
  # "LINEAR_DIST", 
  "QUADRATIC_NONLINEAR_DIST"
  # "SEMIPARAM_NONLINEAR_DIST_BSPLINE"
  # "SEMIPARAM_NONLINEAR_DIST_OSULLIVAN"
  )] %>%
  map_dfr(extract_sim_level, "sim_v", .id = "model") %>% 
  mutate(wide_quantiles = map(quantiles_est, mutate, per = str_c("per_", per)) %>% 
           map(spread, per, est),
         # model = str_extract(model, "[^_]+$")
         ) %>% 
  unnest(wide_quantiles) %>% 
  ggplot(aes(grid_dist, mean_est, group = model)) +
  geom_line(aes(color = model),
              show.legend = FALSE) +
  geom_ribbon(aes(ymin = per_0.1, ymax = per_0.9, fill = model), 
              show.legend = FALSE,
              alpha = 0.25) +
  # geom_ribbon(aes(ymin = per_0.05, ymax = per_0.95), alpha = 0.25) +
  geom_rug(aes(cluster.dist.to.pot, prop_takeup), inherit.aes = FALSE,
           alpha = 0.5,
           sides = "b",
           data = cluster_analysis_data %>% mutate(assigned_treatment = assigned.treatment)) +
  scale_color_discrete("Model") +
  scale_fill_discrete("Model") +
  labs(x = "Distance from PoT", 
       y = bquote(~ v^"*"~"(z,d)"), 
       caption = "Points: observed village level proportion of take-up.
                  Grey ribbons: 80% credible intervals.") +
  facet_wrap(vars(assigned_treatment), nrow = 1) +
  theme_minimal() +
  theme(legend.position = "top")
```

```{r, fig.width=8, fig.height=12}
dist_fit[[1]] %>% 
  extract_obs_fit_level("cluster_takeup_prob", stan_data = stan_data, cluster_level = TRUE) %>% 
  ggplot(aes(assigned_dist, mean_est, group = assigned_treatment)) +
  geom_line(aes(color = assigned_treatment)) +
  geom_point(aes(cluster.dist.to.pot, prop_takeup), inherit.aes = FALSE,
             data = cluster_analysis_data %>% mutate(assigned_treatment = assigned.treatment)) +
  facet_wrap(vars(assigned_treatment), ncol = 1)
```

```{r, fig.width=12, fig.height=4}
sim_reputation %>%
  mutate(wide_quantiles = map(quantiles_est, mutate, per = str_c("per_", per)) %>% 
           map(spread, per, est)) %>% 
  unnest(wide_quantiles) %>% 
  ggplot(aes(grid_dist, mean_est)) +
  geom_line() +
  geom_ribbon(aes(ymin = per_0.1, ymax = per_0.9), alpha = 0.25) +
  geom_ribbon(aes(ymin = per_0.05, ymax = per_0.95), alpha = 0.25) +
  geom_rug(aes(cluster.dist.to.pot, prop_takeup, color = dist.pot.group),
           alpha = 0.5,
           sides = "b",
           data = cluster_analysis_data %>% mutate(assigned_treatment = assigned.treatment)) +
  labs(x = "Distance from PoT", y = bquote("r(" ~ v^"*"~"(z,d))"), color = "Assigned Distance Group",
       caption = "Points: observed village level proportion of take-up.
                  Grey ribbons: 80% and 90% credible intervals.") +
  facet_wrap(vars(assigned_treatment), nrow = 1) +
  theme_minimal() +
  theme(legend.position = "top")
```

```{r}
rep_normal <- function(v) dnorm(v) / (pnorm(v) * pnorm(v, lower.tail = FALSE))

tibble(
  v = seq(-5, 5, 0.1),
  # r = Vectorize(reputational_returns_normal)(v)
  # r = rep_normal(v)
  
  r = 0.75 * dnorm(v, mean = -2) + 0.25 * dnorm(v, mean = 2, sd = 2)
) %>% 
  ggplot(aes(v, r)) +
  geom_line() +
  # geom_line(linetype = "dashed", data = . %>% mutate(r = r * 0.75)) +
  NULL
```

```{r}
loo_obj <- dist_fit[1:2] %>% 
  map(extract_log_lik, merge_chains = FALSE) %>% 
  map(~ loo(.x, r_eff = relative_eff(exp(.x)), cores = 2))

#loo_obj %>% walk(print)
  
loo_obj %>% #[c("LINEAR_DIST", "QUADRATIC_NONLINEAR_DIST", "SEMIPARAM_NONLINEAR_DIST_BSPLINE", "SEMIPARAM_NONLINEAR_DIST_OSULLIVAN")] %>% 
  loo_compare()
```

```{r}
dist_kfold %>% kfold_compare(x = .)

# dist_kfold[3:6] %>% 
dist_kfold %>% 
  map(pluck, "pointwise") %>% 
  do.call(rbind, .) %>% 
  t() %>% 
  stacking_weights()
```


